import{assert as t,isPresentArray as e,assertNever as s,getFirst as r,getLast as n,unwrap as a,deprecate as i,asPresentArray as o,assign as l,expect as c,assertPresentArray as h,dict as u}from"@glimmer/util";import{parseWithoutProcessing as p,parse as d}from"@handlebars/parser";import{EventedTokenizer as m,EntityParser as f,HTML5NamedCharRefs as b}from"simple-html-tokenizer";import{SexpOpcodes as g}from"@glimmer/wire-format";var k=function(t){return t[t.NBSP=160]="NBSP",t[t.QUOT=34]="QUOT",t[t.LT=60]="LT",t[t.GT=62]="GT",t[t.AMP=38]="AMP",t}(k||{});const w=/["&\xA0]/u,y=new RegExp(w.source,"gu"),v=/[&<>\xA0]/u,S=new RegExp(v.source,"gu");function x(t){switch(t.charCodeAt(0)){case k.NBSP:return"&nbsp;";case k.QUOT:return"&quot;";case k.AMP:return"&amp;";default:return t}}function P(t){switch(t.charCodeAt(0)){case k.NBSP:return"&nbsp;";case k.AMP:return"&amp;";case k.LT:return"&lt;";case k.GT:return"&gt;";default:return t}}function C(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const E=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]);function N(){return[...E]}const T=/^\S/u;function A(t){return E.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}class B{buffer="";options;constructor(t){this.options=t}handledByOverride(t,e=!1){if(void 0!==this.options.override){let s=this.options.override(t,this.options);if("string"==typeof s)return e&&T.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(t){switch(t.type){case"MustacheStatement":case"BlockStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(t);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(t);case"ConcatStatement":return this.ConcatStatement(t);case"Hash":return this.Hash(t);case"HashPair":return this.HashPair(t);case"ElementModifierStatement":return this.ElementModifierStatement(t)}}Expression(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(t);case"PathExpression":return this.PathExpression(t);case"SubExpression":return this.SubExpression(t)}}Literal(t){switch(t.type){case"StringLiteral":return this.StringLiteral(t);case"BooleanLiteral":return this.BooleanLiteral(t);case"NumberLiteral":return this.NumberLiteral(t);case"UndefinedLiteral":return this.UndefinedLiteral(t);case"NullLiteral":return this.NullLiteral(t)}}TopLevelStatement(t){switch(t.type){case"MustacheStatement":return this.MustacheStatement(t);case"BlockStatement":return this.BlockStatement(t);case"MustacheCommentStatement":return this.MustacheCommentStatement(t);case"CommentStatement":return this.CommentStatement(t);case"TextNode":return this.TextNode(t);case"ElementNode":return this.ElementNode(t);case"Block":return this.Block(t);case"Template":return this.Template(t);case"AttrNode":return this.AttrNode(t)}}Template(t){this.TopLevelStatements(t.body)}Block(t){t.chained&&(t.body[0].chained=!0),this.handledByOverride(t)||this.TopLevelStatements(t.body)}TopLevelStatements(t){t.forEach((t=>this.TopLevelStatement(t)))}ElementNode(t){this.handledByOverride(t)||(this.OpenElementNode(t),this.TopLevelStatements(t.children),this.CloseElementNode(t))}OpenElementNode(t){this.buffer+=`<${t.tag}`;const e=[...t.attributes,...t.modifiers,...t.comments].sort(C);for(const t of e)switch(this.buffer+=" ",t.type){case"AttrNode":this.AttrNode(t);break;case"ElementModifierStatement":this.ElementModifierStatement(t);break;case"MustacheCommentStatement":this.MustacheCommentStatement(t)}t.blockParams.length&&this.BlockParams(t.blockParams),t.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(t){t.selfClosing||A(t.tag)||(this.buffer+=`</${t.tag}>`)}AttrNode(t){if(this.handledByOverride(t))return;let{name:e,value:s}=t;this.buffer+=e,("TextNode"!==s.type||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(t){"TextNode"===t.type?(this.buffer+='"',this.TextNode(t,!0),this.buffer+='"'):this.Node(t)}TextNode(t,e){var s;this.handledByOverride(t)||("raw"===this.options.entityEncoding?this.buffer+=t.chars:this.buffer+=e?(s=t.chars,w.test(s)?s.replace(y,x):s):function(t){return v.test(t)?t.replace(S,P):t}(t.chars))}MustacheStatement(t){this.handledByOverride(t)||(this.buffer+=t.trusting?"{{{":"{{",t.strip.open&&(this.buffer+="~"),this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),t.strip.close&&(this.buffer+="~"),this.buffer+=t.trusting?"}}}":"}}")}BlockStatement(t){this.handledByOverride(t)||(t.chained?(this.buffer+=t.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=t.openStrip.open?"{{~#":"{{#",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),t.program.blockParams.length&&this.BlockParams(t.program.blockParams),t.chained?this.buffer+=t.inverseStrip.close?"~}}":"}}":this.buffer+=t.openStrip.close?"~}}":"}}",this.Block(t.program),t.inverse&&(t.inverse.chained||(this.buffer+=t.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=t.inverseStrip.close?"~}}":"}}"),this.Block(t.inverse)),t.chained||(this.buffer+=t.closeStrip.open?"{{~/":"{{/",this.Expression(t.path),this.buffer+=t.closeStrip.close?"~}}":"}}"))}BlockParams(t){this.buffer+=` as |${t.join(" ")}|`}ConcatStatement(t){this.handledByOverride(t)||(this.buffer+='"',t.parts.forEach((t=>{"TextNode"===t.type?this.TextNode(t,!0):this.Node(t)})),this.buffer+='"')}MustacheCommentStatement(t){this.handledByOverride(t)||(this.buffer+=`{{!--${t.value}--}}`)}ElementModifierStatement(t){this.handledByOverride(t)||(this.buffer+="{{",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),this.buffer+="}}")}CommentStatement(t){this.handledByOverride(t)||(this.buffer+=`\x3c!--${t.value}--\x3e`)}PathExpression(t){this.handledByOverride(t)||(this.buffer+=t.original)}SubExpression(t){this.handledByOverride(t)||(this.buffer+="(",this.Expression(t.path),this.Params(t.params),this.Hash(t.hash),this.buffer+=")")}Params(t){t.length&&t.forEach((t=>{this.buffer+=" ",this.Expression(t)}))}Hash(t){this.handledByOverride(t,!0)||t.pairs.forEach((t=>{this.buffer+=" ",this.HashPair(t)}))}HashPair(t){this.handledByOverride(t)||(this.buffer+=t.key,this.buffer+="=",this.Node(t.value))}StringLiteral(t){this.handledByOverride(t)||(this.buffer+=JSON.stringify(t.value))}BooleanLiteral(t){this.handledByOverride(t)||(this.buffer+=t.value)}NumberLiteral(t){this.handledByOverride(t)||(this.buffer+=t.value)}UndefinedLiteral(t){this.handledByOverride(t)||(this.buffer+="undefined")}NullLiteral(t){this.handledByOverride(t)||(this.buffer+="null")}print(t){let{options:e}=this;if(e.override){let s=e.override(t,e);if(void 0!==s)return s}return this.buffer="",this.Node(t),this.buffer}}function L(t,e={entityEncoding:"transformed"}){return t?new B(e).print(t):""}function O(t,e){return t in H&&(void 0===e||H[t].includes(e))}const H={action:["Call","Modifier"],component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],log:["Call","Append"],modifier:["Call","Modifier"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],yield:["Append"]},$=Object.freeze({line:1,column:0}),F=Object.freeze({source:"(synthetic)",start:$,end:$}),z=Object.freeze({source:"(nonexistent)",start:$,end:$}),M=Object.freeze({source:"(broken)",start:$,end:$});let I=function(t){return t.CharPosition="CharPosition",t.HbsPosition="HbsPosition",t.InternalsSynthetic="InternalsSynthetic",t.NonExistent="NonExistent",t.Broken="Broken",t}({});const _="MATCH_ANY",U="IS_INVISIBLE";class D{_whens;constructor(t){this._whens=t}first(t){for(const s of this._whens){const r=s.match(t);if(e(r))return r[0]}return null}}class V{_map=new Map;get(t,e){let s=this._map.get(t);return s||(s=e(),this._map.set(t,s),s)}add(t,e){this._map.set(t,e)}match(t){const e=function(t){switch(t){case I.Broken:case I.InternalsSynthetic:case I.NonExistent:return U;default:return t}}(t),s=[],r=this._map.get(e),n=this._map.get(_);return r&&s.push(r),n&&s.push(n),s}}function j(t){return t(new G).check()}class G{_whens=new V;check(){return(t,e)=>this.matchFor(t.kind,e.kind)(t,e)}matchFor(s,r){const n=this._whens.match(s);t(e(n),`no match defined for (${s}, ${r}) and no AnyMatch defined either`);const a=new D(n).first(r);return t(null!==a,`no match defined for (${s}, ${r}) and no AnyMatch defined either`),a}when(t,e,s){return this._whens.get(t,(()=>new V)).add(e,s),this}}class K{static synthetic(t){let e=J.synthetic(t);return new K({loc:e,chars:t})}static load(t,e){return new K({loc:J.load(t,e[1]),chars:e[0]})}chars;loc;constructor(t){this.loc=t.loc,this.chars=t.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}}class J{static get NON_EXISTENT(){return new Q(I.NonExistent,z).wrap()}static load(t,e){return"number"==typeof e?J.forCharPositions(t,e,e):"string"==typeof e?J.synthetic(e):Array.isArray(e)?J.forCharPositions(t,e[0],e[1]):e===I.NonExistent?J.NON_EXISTENT:e===I.Broken?J.broken(M):void s(e)}static forHbsLoc(t,e){const s=new tt(t,e.start),r=new tt(t,e.end);return new Y(t,{start:s,end:r},e).wrap()}static forCharPositions(t,e,s){const r=new Z(t,e),n=new Z(t,s);return new R(t,{start:r,end:n}).wrap()}static synthetic(t){return new Q(I.InternalsSynthetic,z,t).wrap()}static broken(t=M){return new Q(I.Broken,t).wrap()}isInvisible;constructor(t){this.data=t,this.isInvisible=t.kind!==I.CharPosition&&t.kind!==I.HbsPosition}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const t=this.data.toHbsSpan();return null===t?M:t.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(t){return W(t.data,this.data.getEnd())}withEnd(t){return W(this.data.getStart(),t.data)}asString(){return this.data.asString()}toSlice(t){const e=this.data.asString();return new K({loc:this,chars:t||e})}get start(){return this.loc.start}set start(t){this.data.locDidUpdate({start:t})}get end(){return this.loc.end}set end(t){this.data.locDidUpdate({end:t})}get source(){return this.module}collapse(t){switch(t){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(t){return W(this.data.getStart(),t.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:t=0,skipEnd:e=0}){return W(this.getStart().move(t).data,this.getEnd().move(-e).data)}sliceStartChars({skipStart:t=0,chars:e}){return W(this.getStart().move(t).data,this.getStart().move(t+e).data)}sliceEndChars({skipEnd:t=0,chars:e}){return W(this.getEnd().move(t-e).data,this.getStart().move(-t).data)}}class R{kind=I.CharPosition;_locPosSpan=null;constructor(t,e){this.source=t,this.charPositions=e}wrap(){return new J(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){}toHbsSpan(){let t=this._locPosSpan;if(null===t){const e=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();t=this._locPosSpan=null===e||null===s?q:new Y(this.source,{start:e,end:s})}return t===q?null:t}serialize(){const{start:{charPos:t},end:{charPos:e}}=this.charPositions;return t===e?t:[t,e]}toCharPosSpan(){return this}}class Y{kind=I.HbsPosition;_charPosSpan=null;_providedHbsLoc;constructor(t,e,s=null){this.source=t,this.hbsPositions=e,this._providedHbsLoc=s}serialize(){const t=this.toCharPosSpan();return null===t?I.Broken:t.wrap().serialize()}wrap(){return new J(this)}updateProvided(t,e){this._providedHbsLoc&&(this._providedHbsLoc[e]=t),this._charPosSpan=null,this._providedHbsLoc={start:t,end:t}}locDidUpdate({start:t,end:e}){void 0!==t&&(this.updateProvided(t,"start"),this.hbsPositions.start=new tt(this.source,t,null)),void 0!==e&&(this.updateProvided(e,"end"),this.hbsPositions.end=new tt(this.source,e,null))}asString(){const t=this.toCharPosSpan();return null===t?"":t.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let t=this._charPosSpan;if(null===t){const e=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!e||!s)return t=this._charPosSpan=q,null;t=this._charPosSpan=new R(this.source,{start:e,end:s})}return t===q?null:t}}class Q{constructor(t,e,s=null){this.kind=t,this.loc=e,this.string=s}serialize(){switch(this.kind){case I.Broken:case I.NonExistent:return this.kind;case I.InternalsSynthetic:return this.string||""}}wrap(){return new J(this)}asString(){return this.string||""}locDidUpdate({start:t,end:e}){void 0!==t&&(this.loc.start=t),void 0!==e&&(this.loc.end=e)}getModule(){return"an unknown module"}getStart(){return new et(this.kind,this.loc.start)}getEnd(){return new et(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return M}}const W=j((t=>t.when(I.HbsPosition,I.HbsPosition,((t,e)=>new Y(t.source,{start:t,end:e}).wrap())).when(I.CharPosition,I.CharPosition,((t,e)=>new R(t.source,{start:t,end:e}).wrap())).when(I.CharPosition,I.HbsPosition,((t,e)=>{const s=e.toCharPos();return null===s?new Q(I.Broken,M).wrap():W(t,s)})).when(I.HbsPosition,I.CharPosition,((t,e)=>{const s=t.toCharPos();return null===s?new Q(I.Broken,M).wrap():W(s,e)})).when(U,_,(t=>new Q(t.kind,M).wrap())).when(_,U,((t,e)=>new Q(e.kind,M).wrap())))),q="BROKEN";class X{static forHbsPos(t,e){return new tt(t,e,null).wrap()}static broken(t=$){return new et(I.Broken,t).wrap()}constructor(t){this.data=t}get offset(){const t=this.data.toCharPos();return null===t?null:t.offset}eql(t){return st(this.data,t.data)}until(t){return W(this.data,t.data)}move(t){const e=this.data.toCharPos();if(null===e)return X.broken();{const s=e.offset+t;return e.source.check(s)?new Z(e.source,s).wrap():X.broken()}}collapsed(){return W(this.data,this.data)}toJSON(){return this.data.toJSON()}}class Z{kind=I.CharPosition;_locPos=null;constructor(t,e){this.source=t,this.charPos=e}toCharPos(){return this}toJSON(){const t=this.toHbsPos();return null===t?$:t.toJSON()}wrap(){return new X(this)}get offset(){return this.charPos}toHbsPos(){let t=this._locPos;if(null===t){const e=this.source.hbsPosFor(this.charPos);this._locPos=t=null===e?q:new tt(this.source,e,this.charPos)}return t===q?null:t}}class tt{kind=I.HbsPosition;_charPos;constructor(t,e,s=null){this.source=t,this.hbsPos=e,this._charPos=null===s?null:new Z(t,s)}toCharPos(){let t=this._charPos;if(null===t){const e=this.source.charPosFor(this.hbsPos);this._charPos=t=null===e?q:new Z(this.source,e)}return t===q?null:t}toJSON(){return this.hbsPos}wrap(){return new X(this)}toHbsPos(){return this}}class et{constructor(t,e){this.kind=t,this.pos=e}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new X(this)}get offset(){return null}}const st=j((t=>t.when(I.HbsPosition,I.HbsPosition,(({hbsPos:t},{hbsPos:e})=>t.column===e.column&&t.line===e.line)).when(I.CharPosition,I.CharPosition,(({charPos:t},{charPos:e})=>t===e)).when(I.CharPosition,I.HbsPosition,(({offset:t},e)=>t===e.toCharPos()?.offset)).when(I.HbsPosition,I.CharPosition,((t,{offset:e})=>t.toCharPos()?.offset===e)).when(_,_,(()=>!1))));class rt{static from(t,e={}){return new rt(t,e.meta?.moduleName)}constructor(t,e="an unknown module"){this.source=t,this.module=e}check(t){return t>=0&&t<=this.source.length}slice(t,e){return this.source.slice(t,e)}offsetFor(t,e){return X.forHbsPos(this,{line:t,column:e})}spanFor({start:t,end:e}){return J.forHbsLoc(this,{start:{line:t.line,column:t.column},end:{line:e.line,column:e.column}})}hbsPosFor(t){let e=0,s=0;if(t>this.source.length)return null;for(;;){let r=this.source.indexOf("\n",s);if(t<=r||-1===r)return{line:e+1,column:t-s};e+=1,s=r+1}}charPosFor(t){let{line:e,column:s}=t,r=this.source.length,n=0,a=0;for(;a<r;){let t=this.source.indexOf("\n",a);if(-1===t&&(t=this.source.length),n===e-1)return a+s>t?t:a+s;if(-1===t)return 0;n+=1,a=t+1}return r}}class nt{static range(t,e=J.NON_EXISTENT){return new nt(t.map(at)).getRangeOffset(e)}_span;constructor(t=[]){this._span=t}add(t){this._span.push(t)}getRangeOffset(t){if(e(this._span)){let t=r(this._span),e=n(this._span);return t.extend(e)}return t}}function at(t){if(Array.isArray(t)){let e=r(t),s=n(t);return at(e).extend(at(s))}return t instanceof J?t:t.loc}function it(t){return!Array.isArray(t)||0!==t.length}function ot(t,e){return it(t)?at(t):e}var lt=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:z,SYNTHETIC_LOCATION:F,Source:rt,SourceOffset:X,SourceSlice:K,SourceSpan:J,SpanList:nt,UNKNOWN_POSITION:$,hasSpan:it,loc:at,maybeLoc:ot});function ct(t,e){let{module:s,loc:r}=e,{line:n,column:a}=r.start,i=e.asString(),o=i?`\n\n|\n|  ${i.split("\n").join("\n|  ")}\n|\n\n`:"",l=new Error(`${t}: ${o}(error occurred in '${s}' @ line ${n} : column ${a})`);return l.name="SyntaxError",l.location=e,l.code=i,l}const ht={Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"]},ut=function(){function t(t,e,s,r){let n=Error.call(this,t);this.key=r,this.message=t,this.node=e,this.parent=s,n.stack&&(this.stack=n.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function pt(t,e,s){return new ut("Cannot remove a node unless it is part of an array",t,e,s)}function dt(t,e,s){return new ut("Cannot replace a node with multiple nodes unless it is part of an array",t,e,s)}function mt(t,e){return new ut("Replacing and removing in key handlers is not yet supported.",t,null,e)}class ft{node;parent;parentKey;constructor(t,e=null,s=null){this.node=t,this.parent=e,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new bt(this)}}}class bt{path;constructor(t){this.path=t}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}}function gt(t){return"function"==typeof t?t:t.enter}function kt(t){return"function"==typeof t?void 0:t.exit}function wt(t,e){let s,r,n,{node:a,parent:o,parentKey:l}=e,c=function(t,e){if(t.Program&&("Template"===e&&!t.Template||"Block"===e&&!t.Block))return i(`The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${e}') `),t.Program;let s=t[e];return void 0!==s?s:t.All}(t,a.type);if(void 0!==c&&(s=gt(c),r=kt(c)),void 0!==s&&(n=s(a,e)),null!=n){if(JSON.stringify(a)!==JSON.stringify(n))return Array.isArray(n)?(St(t,n,o,l),n):wt(t,new ft(n,o,l))||n;n=void 0}if(void 0===n){let s=ht[a.type];for(let r=0;r<s.length;r++)vt(t,c,e,s[r]);void 0!==r&&(n=r(a,e))}return n}function yt(t,e,s){t[e]=s}function vt(t,e,s,r){let n,a,{node:i}=s,o=function(t,e){return t[e]}(i,r);if(o){if(void 0!==e){let t=function(t,e){let s="function"!=typeof t?t.keys:void 0;if(void 0===s)return;let r=s[e];return void 0!==r?r:s.All}(e,r);void 0!==t&&(n=gt(t),a=kt(t))}if(void 0!==n&&void 0!==n(i,r))throw mt(i,r);if(Array.isArray(o))St(t,o,s,r);else{let e=wt(t,new ft(o,s,r));void 0!==e&&function(t,e,s,r){if(null===r)throw pt(s,t,e);if(Array.isArray(r)){if(1!==r.length)throw 0===r.length?pt(s,t,e):dt(s,t,e);yt(t,e,r[0])}else yt(t,e,r)}(i,r,o,e)}if(void 0!==a&&void 0!==a(i,r))throw mt(i,r)}}function St(t,e,s,r){for(let n=0;n<e.length;n++){let i=a(e[n]),o=wt(t,new ft(i,s,r));void 0!==o&&(n+=xt(e,n,o)-1)}}function xt(t,e,s){return null===s?(t.splice(e,1),0):Array.isArray(s)?(t.splice(e,1,...s),s.length):(t.splice(e,1,s),1)}function Pt(t,e){wt(e,new ft(t))}class Ct{stack=[];constructor(t){this.order=t}visit(t,e){t&&(this.stack.push(t),"post"===this.order?(this.children(t,e),e(t,this)):(e(t,this),this.children(t,e)),this.stack.pop())}children(t,e){switch(t.type){case"Block":case"Template":return void Et(this,t.body,e);case"ElementNode":return void Et(this,t.children,e);case"BlockStatement":return this.visit(t.program,e),void this.visit(t.inverse||null,e);default:return}}}function Et(t,e,s){for(const r of e)t.visit(r,s)}function Nt(t,e){(function(t){switch(t.type){case"Block":case"Template":return t.body;case"ElementNode":return t.children}})(t).push(e)}function Tt(t){return"StringLiteral"===t.type||"BooleanLiteral"===t.type||"NumberLiteral"===t.type||"NullLiteral"===t.type||"UndefinedLiteral"===t.type}let At;function Bt(){return At||(At=new rt("","(synthetic)")),At}function Lt(t,e){return Vt.var({name:t,loc:It(e||null)})}function Ot(e,s){let r=It(s||null);if("string"!=typeof e){if("type"in e)return e;{t(-1===e.head.indexOf("."),"builder.path({ head, tail }) should not be called with a head with dots in it");let{head:n,tail:a}=e;return Vt.path({head:Vt.head({original:n,loc:r.sliceStartChars({chars:n.length})}),tail:a,loc:It(s||null)})}}let{head:n,tail:a}=function(t,e){let[s,...r]=o(t.split(".")),n=Vt.head({original:s,loc:It(e||null)});return Vt.path({head:n,tail:r,loc:It(e||null)})}(e,r);return Vt.path({head:n,tail:a,loc:r})}function Ht(t,e,s){return Vt.literal({type:t,value:e,loc:It(s||null)})}function $t(t=[],e){return Vt.hash({pairs:t,loc:It(e||null)})}function Ft(t){return t.map((t=>"string"==typeof t?Vt.var({name:t,loc:J.synthetic(t)}):t))}function zt(t=[],e=[],s=!1,r){return Vt.blockItself({body:t,params:Ft(e),chained:s,loc:It(r||null)})}function Mt(t=[],e=[],s){return Vt.template({body:t,blockParams:e,loc:It(s||null)})}function It(...t){if(1===t.length){let e=t[0];return e&&"object"==typeof e?J.forHbsLoc(Bt(),e):J.forHbsLoc(Bt(),F)}{let[e,s,r,n,a]=t,i=a?new rt("",a):Bt();return J.forHbsLoc(i,{start:{line:e,column:s},end:{line:r||e,column:n||s}})}}var _t={mustache:function(t,e=[],s=$t([]),r=!1,n,a){return Vt.mustache({path:Ot(t),params:e,hash:s,trusting:r,strip:a,loc:It(n||null)})},block:function(e,s,r,n,a=null,o,l,c,h){let u,p=null;return"Template"===n.type?(i("b.program is deprecated. Use b.blockItself instead."),u=Vt.blockItself({params:Ft(n.blockParams),body:n.body,loc:n.loc})):u=n,"Template"===a?.type?(i("b.program is deprecated. Use b.blockItself instead."),t(0===a.blockParams.length,"{{else}} block cannot have block params"),p=Vt.blockItself({params:[],body:a.body,loc:a.loc})):p=a,Vt.block({path:Ot(e),params:s||[],hash:r||$t([]),defaultBlock:u,elseBlock:p,loc:It(o||null),openStrip:l,inverseStrip:c,closeStrip:h})},comment:function(t,e){return Vt.comment({value:t,loc:It(e||null)})},mustacheComment:function(t,e){return Vt.mustacheComment({value:t,loc:It(e||null)})},element:function(e,s={}){let r,n,{attrs:a,blockParams:i,modifiers:o,comments:l,children:c,openTag:h,closeTag:u,loc:p}=s;"string"==typeof e?e.endsWith("/")?(r=Ot(e.slice(0,-1)),n=!0):r=Ot(e):"type"in e?(t("PathExpression"===e.type,`Invalid tag type ${e.type}`),r=e):"path"in e?(t("PathExpression"===e.path.type,`Invalid tag type ${e.path.type}`),r=e.path,n=e.selfClosing):(r=Ot(e.name),n=e.selfClosing),n&&t(null==u,"Cannot build a self-closing tag with a closeTag source location");let d=i?.map((t=>"string"==typeof t?Lt(t):t)),m=null;return u?m=It(u||null):void 0===u&&(m=n||A(r.original)?null:It(null)),Vt.element({path:r,selfClosing:n||!1,attributes:a||[],params:d||[],modifiers:o||[],comments:l||[],children:c||[],openTag:It(h||null),closeTag:m,loc:It(p||null)})},elementModifier:function(t,e,s,r){return Vt.elementModifier({path:Ot(t),params:e||[],hash:s||$t([]),loc:It(r||null)})},attr:function(t,e,s){return Vt.attr({name:t,value:e,loc:It(s||null)})},text:function(t="",e){return Vt.text({chars:t,loc:It(e||null)})},sexpr:function(t,e=[],s=$t([]),r){return Vt.sexpr({path:Ot(t),params:e,hash:s,loc:It(r||null)})},concat:function(t,s){if(!e(t))throw new Error("b.concat requires at least one part");return Vt.concat({parts:t,loc:It(s||null)})},hash:$t,pair:function(t,e,s){return Vt.pair({key:t,value:e,loc:It(s||null)})},literal:Ht,program:function(t,e,s){return i("b.program is deprecated. Use b.template or b.blockItself instead."),e&&e.length?zt(t,e,!1,s):Mt(t,[],s)},blockItself:zt,template:Mt,loc:It,pos:function(t,e){return Vt.pos({line:t,column:e})},path:Ot,fullPath:function(t,e=[],s){return Vt.path({head:t,tail:e,loc:It(s||null)})},head:function(t,e){return Vt.head({original:t,loc:It(e||null)})},at:function(t,e){return Vt.atName({name:t,loc:It(e||null)})},var:Lt,this:function(t){return Vt.this({loc:It(t||null)})},string:Ut("StringLiteral"),boolean:Ut("BooleanLiteral"),number:Ut("NumberLiteral"),undefined:()=>Ht("UndefinedLiteral",void 0),null:()=>Ht("NullLiteral",null)};function Ut(t){return function(e,s){return Ht(t,e,s)}}const Dt={close:!1,open:!1},Vt=new class{pos({line:t,column:e}){return{line:t,column:e}}blockItself({body:t,params:e,chained:s=!1,loc:r}){return{type:"Block",body:t,params:e,get blockParams(){return this.params.map((t=>t.name))},set blockParams(t){this.params=t.map((t=>Vt.var({name:t,loc:J.synthetic(t)})))},chained:s,loc:r}}template({body:t,blockParams:e,loc:s}){return{type:"Template",body:t,blockParams:e,loc:s}}mustache({path:t,params:e,hash:s,trusting:r,loc:n,strip:a=Dt}){return function({path:t,params:e,hash:s,trusting:r,strip:n,loc:a}){const o={type:"MustacheStatement",path:t,params:e,hash:s,trusting:r,strip:n,loc:a};return Object.defineProperty(o,"escaped",{enumerable:!1,get(){return i("The escaped property on mustache nodes is deprecated, use trusting instead"),!this.trusting},set(t){i("The escaped property on mustache nodes is deprecated, use trusting instead"),this.trusting=!t}}),o}({path:t,params:e,hash:s,trusting:r,strip:a,loc:n})}block({path:t,params:e,hash:s,defaultBlock:r,elseBlock:n=null,loc:a,openStrip:i=Dt,inverseStrip:o=Dt,closeStrip:l=Dt}){return{type:"BlockStatement",path:t,params:e,hash:s,program:r,inverse:n,loc:a,openStrip:i,inverseStrip:o,closeStrip:l}}comment({value:t,loc:e}){return{type:"CommentStatement",value:t,loc:e}}mustacheComment({value:t,loc:e}){return{type:"MustacheCommentStatement",value:t,loc:e}}concat({parts:t,loc:e}){return{type:"ConcatStatement",parts:t,loc:e}}element({path:t,selfClosing:e,attributes:s,modifiers:r,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c}){let h=e;return{type:"ElementNode",path:t,attributes:s,modifiers:r,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c,get tag(){return this.path.original},set tag(t){this.path.original=t},get blockParams(){return this.params.map((t=>t.name))},set blockParams(t){this.params=t.map((t=>Vt.var({name:t,loc:J.synthetic(t)})))},get selfClosing(){return h},set selfClosing(t){h=t,this.closeTag=t?null:J.synthetic(`</${this.tag}>`)}}}elementModifier({path:t,params:e,hash:s,loc:r}){return{type:"ElementModifierStatement",path:t,params:e,hash:s,loc:r}}attr({name:t,value:e,loc:s}){return{type:"AttrNode",name:t,value:e,loc:s}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:s,loc:r}){return{type:"SubExpression",path:t,params:e,hash:s,loc:r}}path({head:t,tail:e,loc:s}){return function({head:t,tail:e,loc:s}){const r={type:"PathExpression",head:t,tail:e,get original(){return[this.head.original,...this.tail].join(".")},set original(t){let[e,...s]=o(t.split("."));this.head=_t.head(e,this.head.loc),this.tail=s},loc:s};return Object.defineProperty(r,"parts",{enumerable:!1,get(){i("The parts property on path nodes is deprecated, use head and tail instead");let t=o(this.original.split("."));return"this"===t[0]?t.shift():t[0].startsWith("@")&&(t[0]=t[0].slice(1)),Object.freeze(t)},set(t){i("The parts property on mustache nodes is deprecated, use head and tail instead");let e=[...t];"this"===e[0]||e[0]?.startsWith("@")||("ThisHead"===this.head.type?e.unshift("this"):"AtHead"===this.head.type&&(e[0]=`@${e[0]}`)),this.original=e.join(".")}}),Object.defineProperty(r,"this",{enumerable:!1,get(){return i("The this property on path nodes is deprecated, use head.type instead"),"ThisHead"===this.head.type}}),Object.defineProperty(r,"data",{enumerable:!1,get(){return i("The data property on path nodes is deprecated, use head.type instead"),"AtHead"===this.head.type}}),r}({head:t,tail:e,loc:s})}head({original:t,loc:e}){return"this"===t?this.this({loc:e}):"@"===t[0]?this.atName({name:t,loc:e}):this.var({name:t,loc:e})}this({loc:t}){return{type:"ThisHead",get original(){return"this"},loc:t}}atName({name:e,loc:s}){let r="";const n={type:"AtHead",get name(){return r},set name(e){t("@"===e[0],"call builders.at() with a string that starts with '@'"),t(-1===e.indexOf("."),"builder.at() should not be called with a name with dots in it"),r=e},get original(){return this.name},set original(t){this.name=t},loc:s};return n.name=e,n}var({name:e,loc:s}){let r="";const n={type:"VarHead",get name(){return r},set name(s){t("this"!==s,"You called builders.var() with 'this'. Call builders.this instead"),t("@"!==s[0],`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),t(-1===s.indexOf("."),"builder.var() should not be called with a name with dots in it"),r=s},get original(){return this.name},set original(t){this.name=t},loc:s};return n.name=e,n}hash({pairs:t,loc:e}){return{type:"Hash",pairs:t,loc:e}}pair({key:t,value:e,loc:s}){return{type:"HashPair",key:t,value:e,loc:s}}literal({type:t,value:e,loc:s}){return function({type:t,value:e,loc:s}){const r={type:t,value:e,loc:s};return Object.defineProperty(r,"original",{enumerable:!1,get(){return i("The original property on literal nodes is deprecated, use value instead"),this.value},set(t){i("The original property on literal nodes is deprecated, use value instead"),this.value=t}}),r}({type:t,value:e,loc:s})}};class jt{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(t,e=new f(b),s="precompile"){this.source=t,this.lines=t.source.split(/\r\n?|\n/u),this.tokenizer=new m(this,e,s)}offset(){let{line:t,column:e}=this.tokenizer;return this.source.offsetFor(t,e)}pos({line:t,column:e}){return this.source.offsetFor(t,e)}finish(t){return l({},t,{loc:t.start.until(this.offset())})}get currentAttr(){return c(this.currentAttribute,"expected attribute")}get currentTag(){let e=this.currentNode;return t(e&&("StartTag"===e.type||"EndTag"===e.type),"expected tag"),e}get currentStartTag(){let e=this.currentNode;return t(e&&"StartTag"===e.type,"expected start tag"),e}get currentEndTag(){let e=this.currentNode;return t(e&&"EndTag"===e.type,"expected end tag"),e}get currentComment(){let e=this.currentNode;return t(e&&"CommentStatement"===e.type,"expected a comment"),e}get currentData(){let e=this.currentNode;return t(e&&"TextNode"===e.type,"expected a text node"),e}acceptNode(t){return this[t.type](t)}currentElement(){return n(o(this.elementStack))}sourceForNode(t,e){let s,r,n,i=t.loc.start.line-1,o=i-1,l=t.loc.start.column,c=[];for(e?(r=e.loc.end.line-1,n=e.loc.end.column):(r=t.loc.end.line-1,n=t.loc.end.column);o<r;)o++,s=a(this.lines[o]),o===i?i===r?c.push(s.slice(l,n)):c.push(s.slice(l)):o===r?c.push(s.slice(0,n)):c.push(s);return c.join("\n")}}const Gt="beforeAttributeName";class Kt extends jt{pendingError=null;parse(t,e){let s=Vt.template({body:[],blockParams:e,loc:this.source.spanFor(t.loc)}),r=this.parseProgram(s,t);return this.pendingError?.eof(r.loc.getEnd()),r}Program(e,s){t(Array.isArray(s),"[BUG] Program in parser unexpectedly called without block params");let r=Vt.blockItself({body:[],params:s,chained:e.chained,loc:this.source.spanFor(e.loc)});return this.parseProgram(r,e)}parseProgram(e,s){if(0===s.body.length)return e;let r;try{this.elementStack.push(e);for(let t of s.body)this.acceptNode(t)}finally{r=this.elementStack.pop()}if(e!==r){if("ElementNode"===r?.type)throw ct(`Unclosed element \`${r.tag}\``,r.loc);t(void 0!==r,"[BUG] empty parser elementStack"),t(!1,`[BUG] mismatched parser elementStack node: ${e.type}`)}return e}BlockStatement(t){if("comment"===this.tokenizer.state)return void this.appendToCommentData(this.sourceForNode(t));if("data"!==this.tokenizer.state&&"beforeData"!==this.tokenizer.state)throw ct("A block may only be used inside an HTML element or another block.",this.source.spanFor(t.loc));const{path:e,params:s,hash:r}=Jt(this,t),n=this.source.spanFor(t.loc);let a=[];if(t.program.blockParams?.length){let e=r.loc.collapse("end");e=t.program.loc?e.withEnd(this.source.spanFor(t.program.loc).getStart()):t.program.body[0]?e.withEnd(this.source.spanFor(t.program.body[0].loc).getStart()):e.withEnd(n.getEnd());const s=e.asString();let i=s.indexOf("|")+1;const o=s.indexOf("|",i);for(const r of t.program.blockParams){let t,n;t=i>=o?-1:s.indexOf(r,i),-1===t||t+r.length>o?(i=o,n=this.source.spanFor(z)):(i=t,n=e.sliceStartChars({skipStart:i,chars:r.length}),i+=r.length),a.push(Vt.var({name:r,loc:n}))}}t.program.loc||(t.program.loc=z),t.inverse&&!t.inverse.loc&&(t.inverse.loc=z);const i=this.Program(t.program,a),o=t.inverse?this.Program(t.inverse,[]):null,l=Vt.block({path:e,params:s,hash:r,defaultBlock:i,elseBlock:o,loc:this.source.spanFor(t.loc),openStrip:t.openStrip,inverseStrip:t.inverseStrip,closeStrip:t.closeStrip});Nt(this.currentElement(),l)}MustacheStatement(t){this.pendingError?.mustache(this.source.spanFor(t.loc));const{tokenizer:e}=this;if("comment"===e.state)return void this.appendToCommentData(this.sourceForNode(t));let s;const{escaped:r,loc:n,strip:a}=t;if("original"in t.path&&"...attributes"===t.path.original)throw ct("Illegal use of ...attributes",this.source.spanFor(t.loc));if(Tt(t.path))s=Vt.mustache({path:this.acceptNode(t.path),params:[],hash:Vt.hash({pairs:[],loc:this.source.spanFor(t.path.loc).collapse("end")}),trusting:!r,loc:this.source.spanFor(n),strip:a});else{const{path:e,params:i,hash:o}=Jt(this,t);s=Vt.mustache({path:e,params:i,hash:o,trusting:!r,loc:this.source.spanFor(n),strip:a})}switch(e.state){case"tagOpen":case"tagName":throw ct("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":Rt(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),Rt(this.currentStartTag,s),e.transitionTo(Gt);break;case"afterAttributeValueQuoted":Rt(this.currentStartTag,s),e.transitionTo(Gt);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),e.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:Nt(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(t){this.finalizeTextPart();const e=this.currentAttr;e.isDynamic=!0,e.parts.push(t)}finalizeTextPart(){const t=this.currentAttr.currentPart;null!==t&&(this.currentAttr.parts.push(t),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(t){!function(t,e){let s=e.loc.start.line,r=e.loc.start.column;const n=function(t,e){if(""===e)return{lines:t.split("\n").length-1,columns:0};const[s]=t.split(e),r=s.split(/\n/u),n=r.length-1;return{lines:n,columns:a(r[n]).length}}(e.original,e.value);s+=n.lines,n.lines?r=n.columns:r+=n.columns,t.line=s,t.column=r}(this.tokenizer,t),this.tokenizer.tokenizePart(t.value),this.tokenizer.flushData()}CommentStatement(t){const{tokenizer:e}=this;if("comment"===e.state)return this.appendToCommentData(this.sourceForNode(t)),null;const{value:s,loc:r}=t,n=Vt.mustacheComment({value:s,loc:this.source.spanFor(r)});switch(e.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(n);break;case"beforeData":case"data":Nt(this.currentElement(),n);break;default:throw ct(`Using a Handlebars comment when in the \`${e.state}\` state is not supported`,this.source.spanFor(t.loc))}return n}PartialStatement(t){throw ct("Handlebars partials are not supported",this.source.spanFor(t.loc))}PartialBlockStatement(t){throw ct("Handlebars partial blocks are not supported",this.source.spanFor(t.loc))}Decorator(t){throw ct("Handlebars decorators are not supported",this.source.spanFor(t.loc))}DecoratorBlock(t){throw ct("Handlebars decorator blocks are not supported",this.source.spanFor(t.loc))}SubExpression(t){const{path:e,params:s,hash:r}=Jt(this,t);return Vt.sexpr({path:e,params:s,hash:r,loc:this.source.spanFor(t.loc)})}PathExpression(t){const{original:e}=t;let s;if(-1!==e.indexOf("/")){if("./"===e.slice(0,2))throw ct('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(t.loc));if("../"===e.slice(0,3))throw ct('Changing context using "../" is not supported in Glimmer',this.source.spanFor(t.loc));if(-1!==e.indexOf("."))throw ct("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(t.loc));s=[t.parts.join("/")]}else{if("."===e)throw ct("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(t.loc));s=t.parts}let r,n=!1;if(/^this(?:\..+)?$/u.test(e)&&(n=!0),n)r=Vt.this({loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+4}})});else if(t.data){const e=s.shift();if(void 0===e)throw ct("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(t.loc));r=Vt.atName({name:`@${e}`,loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+e.length+1}})})}else{const e=s.shift();if(void 0===e)throw ct("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(t.loc));r=Vt.var({name:e,loc:this.source.spanFor({start:t.loc.start,end:{line:t.loc.start.line,column:t.loc.start.column+e.length}})})}return Vt.path({head:r,tail:s,loc:this.source.spanFor(t.loc)})}Hash(t){const e=t.pairs.map((t=>Vt.pair({key:t.key,value:this.acceptNode(t.value),loc:this.source.spanFor(t.loc)})));return Vt.hash({pairs:e,loc:this.source.spanFor(t.loc)})}StringLiteral(t){return Vt.literal({type:"StringLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}BooleanLiteral(t){return Vt.literal({type:"BooleanLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}NumberLiteral(t){return Vt.literal({type:"NumberLiteral",value:t.value,loc:this.source.spanFor(t.loc)})}UndefinedLiteral(t){return Vt.literal({type:"UndefinedLiteral",value:void 0,loc:this.source.spanFor(t.loc)})}NullLiteral(t){return Vt.literal({type:"NullLiteral",value:null,loc:this.source.spanFor(t.loc)})}}function Jt(t,s){let r;switch(s.path.type){case"PathExpression":r=t.PathExpression(s.path);break;case"SubExpression":r=t.SubExpression(s.path);break;case"StringLiteral":case"UndefinedLiteral":case"NullLiteral":case"NumberLiteral":case"BooleanLiteral":{let e;throw e="BooleanLiteral"===s.path.type?s.path.original.toString():"StringLiteral"===s.path.type?`"${s.path.original}"`:"NullLiteral"===s.path.type?"null":"NumberLiteral"===s.path.type?s.path.value.toString():"undefined",ct(`${s.path.type} "${"StringLiteral"===s.path.type?s.path.original:e}" cannot be called as a sub-expression, replace (${e}) with ${e}`,t.source.spanFor(s.path.loc))}}const a=s.params?s.params.map((e=>t.acceptNode(e))):[],i=e(a)?n(a).loc:r.loc;return{path:r,params:a,hash:s.hash?t.Hash(s.hash):Vt.hash({pairs:[],loc:t.source.spanFor(i).collapse("end")})}}function Rt(t,e){const{path:s,params:r,hash:n,loc:a}=e;if(Tt(s)){const r=`{{${function(t){return"UndefinedLiteral"===t.type?"undefined":JSON.stringify(t.value)}(s)}}}`;throw ct(`In <${t.name} ... ${r} ..., ${r} is not a valid modifier`,e.loc)}const i=Vt.elementModifier({path:s,params:r,hash:n,loc:a});t.modifiers.push(i)}function Yt(t){return/[\t\n\f ]/u.test(t)}class Qt extends Kt{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode={type:"CommentStatement",value:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}appendToCommentData(t){this.currentComment.value+=t}finishComment(){Nt(this.currentElement(),Vt.comment(this.finish(this.currentComment)))}beginData(){this.currentNode={type:"TextNode",chars:"",start:this.offset()}}appendToData(t){this.currentData.chars+=t}finishData(){Nt(this.currentElement(),Vt.text(this.finish(this.currentData)))}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",nameStart:null,nameEnd:null,attributes:[],modifiers:[],comments:[],params:[],selfClosing:!1,start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let t=this.finish(this.currentTag);if("StartTag"===t.type){if(this.finishStartTag(),":"===t.name)throw ct("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.start.toJSON(),end:this.offset().toJSON()}));(E.has(t.name)||t.selfClosing)&&this.finishEndTag(!0)}else"EndTag"===t.type&&this.finishEndTag(!1)}finishStartTag(){let{name:e,nameStart:s,nameEnd:r}=this.currentStartTag;t(""!==e,"tag name cannot be empty"),t(null!==s,"nameStart unexpectedly null"),t(null!==r,"nameEnd unexpectedly null");let n=s.until(r),[a,...i]=o(e.split(".")),l=Vt.path({head:Vt.head({original:a,loc:n.sliceStartChars({chars:a.length})}),tail:i,loc:n}),{attributes:c,modifiers:h,comments:u,params:p,selfClosing:d,loc:m}=this.finish(this.currentStartTag),f=Vt.element({path:l,selfClosing:d,attributes:c,modifiers:h,comments:u,params:p,children:[],openTag:m,closeTag:d?null:J.broken(),loc:m});this.elementStack.push(f)}finishEndTag(e){let{start:s}=this.currentTag,r=this.finish(this.currentTag),n=this.elementStack.pop();this.validateEndTag(r,n,e);let a=this.currentElement();e?n.closeTag=null:n.selfClosing?t(null===n.closeTag,"element.closeTag unexpectedly present"):n.closeTag=s.until(this.offset()),n.loc=n.loc.withEnd(this.offset()),Nt(a,Vt.element(n))}markTagAsSelfClosing(){let t=this.currentTag;if("StartTag"!==t.type)throw ct("Invalid end tag: closing tag must not be self-closing",this.source.spanFor({start:t.start.toJSON(),end:this.offset().toJSON()}));t.selfClosing=!0}appendToTagName(e){let s=this.currentTag;if(s.name+=e,"StartTag"===s.type){let e=this.offset();null===s.nameStart&&(t(null===s.nameEnd,"nameStart and nameEnd must both be null"),s.nameStart=e.move(-1)),s.nameEnd=e}}beginAttribute(){let t=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:t,valueSpan:t.collapsed()}}appendToAttributeName(t){this.currentAttr.name+=t,"as"===this.currentAttr.name&&this.parsePossibleBlockParams()}beginAttributeValue(t){this.currentAttr.isQuoted=t,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(t){let e=this.currentAttr.parts,s=e[e.length-1],r=this.currentAttr.currentPart;if(r)r.chars+=t,r.loc=r.loc.withEnd(this.offset());else{let e=this.offset();e="\n"===t?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():e.move(-1),this.currentAttr.currentPart=Vt.text({chars:t,loc:e.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let t=this.currentTag,e=this.offset();if("EndTag"===t.type)throw ct("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:t.start.toJSON(),end:e.toJSON()}));let{name:s,parts:r,start:n,isQuoted:a,isDynamic:i,valueSpan:o}=this.currentAttr;if(s.startsWith("|")&&0===r.length&&!a&&!i)throw ct("Invalid block parameters syntax: block parameters must be preceded by the `as` keyword",n.until(n.move(s.length)));let l=this.assembleAttributeValue(r,a,i,n.until(e));l.loc=o.withEnd(e);let c=Vt.attr({name:s,value:l,loc:n.until(e)});this.currentStartTag.attributes.push(c)}parsePossibleBlockParams(){const e=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;t("attributeName"===this.tokenizer.state,"must be in TokenizerState.attributeName");const s=this.currentStartTag,r=this.currentAttr;let n={state:"PossibleAs"};const a={PossibleAs:e=>{if(t("PossibleAs"===n.state,"bug in block params parser"),Yt(e))n={state:"BeforeStartPipe"},this.tokenizer.transitionTo("afterAttributeName"),this.tokenizer.consume();else{if("|"===e)throw ct('Invalid block parameters syntax: expecting at least one space character between "as" and "|"',r.start.until(this.offset().move(1)));n={state:"Done"}}},BeforeStartPipe:e=>{t("BeforeStartPipe"===n.state,"bug in block params parser"),Yt(e)?this.tokenizer.consume():"|"===e?(n={state:"BeforeBlockParamName"},this.tokenizer.transitionTo("beforeAttributeName"),this.tokenizer.consume()):n={state:"Done"}},BeforeBlockParamName:e=>{if(t("BeforeBlockParamName"===n.state,"bug in block params parser"),Yt(e))this.tokenizer.consume();else if(""===e)n={state:"Done"},this.pendingError={mustache(t){throw ct("Invalid block parameters syntax: mustaches cannot be used inside parameters list",t)},eof(t){throw ct('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',r.start.until(t))}};else if("|"===e){if(0===s.params.length)throw ct("Invalid block parameters syntax: empty parameters list, expecting at least one identifier",r.start.until(this.offset().move(1)));n={state:"AfterEndPipe"},this.tokenizer.consume()}else{if(">"===e||"/"===e)throw ct('Invalid block parameters syntax: incomplete parameters list, expecting "|" but the tag was closed prematurely',r.start.until(this.offset().move(1)));n={state:"BlockParamName",name:e,start:this.offset()},this.tokenizer.consume()}},BlockParamName:a=>{if(t("BlockParamName"===n.state,"bug in block params parser"),""===a)n={state:"Done"},this.pendingError={mustache(t){throw ct("Invalid block parameters syntax: mustaches cannot be used inside parameters list",t)},eof(t){throw ct('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',r.start.until(t))}};else if("|"===a||Yt(a)){let t=n.start.until(this.offset());if("this"===n.name||e.test(n.name))throw ct(`Invalid block parameters syntax: invalid identifier name \`${n.name}\``,t);s.params.push(Vt.var({name:n.name,loc:t})),n="|"===a?{state:"AfterEndPipe"}:{state:"BeforeBlockParamName"},this.tokenizer.consume()}else{if(">"===a||"/"===a)throw ct('Invalid block parameters syntax: expecting "|" but the tag was closed prematurely',r.start.until(this.offset().move(1)));n.name+=a,this.tokenizer.consume()}},AfterEndPipe:e=>{t("AfterEndPipe"===n.state,"bug in block params parser"),Yt(e)?this.tokenizer.consume():""===e?(n={state:"Done"},this.pendingError={mustache(t){throw ct("Invalid block parameters syntax: modifiers cannot follow parameters list",t)},eof(t){throw ct('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',r.start.until(t))}}):">"===e||"/"===e?n={state:"Done"}:(n={state:"Error",message:'Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',start:this.offset()},this.tokenizer.consume())},Error:e=>{if(t("Error"===n.state,"bug in block params parser"),""===e||"/"===e||">"===e||Yt(e))throw ct(n.message,n.start.until(this.offset()));this.tokenizer.consume()},Done:()=>{t(!1,"This should never be called")}};let i;do{i=this.tokenizer.peek(),a[n.state](i)}while("Done"!==n.state&&""!==i);t("Done"===n.state,"bug in block params parser")}reportSyntaxError(t){throw ct(t,this.offset().collapsed())}assembleConcatenatedValue(t){for(const e of t)if("MustacheStatement"!==e.type&&"TextNode"!==e.type)throw ct(`Unsupported node in quoted attribute value: ${e.type}`,e.loc);h(t,"the concatenation parts of an element should not be empty");let e=r(t),s=n(t);return Vt.concat({parts:t,loc:this.source.spanFor(e.loc).extend(this.source.spanFor(s.loc))})}validateEndTag(t,e,s){if(E.has(t.name)&&!s)throw ct(`<${t.name}> elements do not need end tags. You should remove it`,t.loc);if(void 0===e.tag)throw ct(`Closing tag </${t.name}> without an open tag`,t.loc);if(e.tag!==t.name)throw ct(`Closing tag </${t.name}> did not match last open tag <${e.tag}> (on line ${e.loc.startPosition.line})`,t.loc)}assembleAttributeValue(t,s,r,n){if(r){if(s)return this.assembleConcatenatedValue(t);{h(t);const[e,s]=t;if(void 0===s||"TextNode"===s.type&&"/"===s.chars)return e;throw ct("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",n)}}return e(t)?t[0]:Vt.text({chars:"",loc:n})}}const Wt={parse:Xt,builders:_t,print:L,traverse:Pt,Walker:Ct};class qt extends f{constructor(){super({})}parse(){}}function Xt(t,e={}){let s,r,n,a=e.mode||"precompile";"string"==typeof t?(s=new rt(t,e.meta?.moduleName),r="codemod"===a?p(t,e.parseOptions):d(t,e.parseOptions)):t instanceof rt?(s=t,r="codemod"===a?p(t.source,e.parseOptions):d(t.source,e.parseOptions)):(s=new rt("",e.meta?.moduleName),r=t),"codemod"===a&&(n=new qt);let i=J.forCharPositions(s,0,s.source.length);r.loc={source:"(program)",start:i.startPosition,end:i.endPosition};let o=new Qt(s,n,a).parse(r,e.locals??[]);if(e?.plugins?.ast)for(const t of e.plugins.ast)Pt(o,t(l({},e,{syntax:Wt},{plugins:void 0})).visitor);return o}function Zt(t,e,s,r){const n=function(t,e,s){if("PathExpression"===t.type){if("AtHead"===t.head.type||"ThisHead"===t.head.type)return;const s=t.head.name;if(-1===e.indexOf(s))return s}else if("ElementNode"===t.type){const{tag:r}=t,n=r.charAt(0);if(":"===n||"@"===n)return;if(!s.includeHtmlElements&&-1===r.indexOf(".")&&r.toLowerCase()===r)return;if("this."===r.substr(0,5))return;if(r.includes(".")){let[t]=r.split(".");if(e.includes(t))return}if(e.includes(r))return;return r}}(e,s,r);(Array.isArray(n)?n:[n]).forEach((e=>{if(void 0!==e&&"@"!==e[0]){const r=e.split(".")[0];s.includes(r)||t.add(e.split(".")[0])}}))}function te(t,e={includeHtmlElements:!1,includeKeywords:!1}){const s=Xt(t),r=new Set,n=[];Pt(s,{Block:{enter({blockParams:t}){t.forEach((t=>{n.push(t)}))},exit({blockParams:t}){t.forEach((()=>{n.pop()}))}},ElementNode:{enter(t){t.blockParams.forEach((t=>{n.push(t)})),Zt(r,t,n,e)},exit({blockParams:t}){t.forEach((()=>{n.pop()}))}},PathExpression(t){Zt(r,t,n,e)}});let a=[];return r.forEach((t=>a.push(t))),e?.includeKeywords||(a=a.filter((t=>!O(t)))),a}function ee(t){if(void 0!==t){const e=t;return{fields:()=>class{type;constructor(t){this.type=e,l(this,t)}}}}return{fields:()=>class{constructor(t){l(this,t)}}}}class se extends(ee().fields()){static empty(t){return new se({loc:t,positional:re.empty(t),named:ne.empty(t)})}static named(t){return new se({loc:t.loc,positional:re.empty(t.loc.collapse("end")),named:t})}nth(t){return this.positional.nth(t)}get(t){return this.named.get(t)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}}class re extends(ee().fields()){static empty(t){return new re({loc:t,exprs:[]})}get size(){return this.exprs.length}nth(t){return this.exprs[t]||null}isEmpty(){return 0===this.exprs.length}}class ne extends(ee().fields()){static empty(t){return new ne({loc:t,entries:[]})}get size(){return this.entries.length}get(t){let e=this.entries.filter((e=>e.name.chars===t))[0];return e?e.value:null}isEmpty(){return 0===this.entries.length}}class ae{loc;name;value;constructor(t){this.loc=t.name.loc.extend(t.value.loc),this.name=t.name,this.value=t.value}}class ie extends(ee("HtmlAttr").fields()){}class oe extends(ee("SplatAttr").fields()){}class le extends(ee().fields()){toNamedArgument(){return new ae({name:this.name,value:this.value})}}class ce extends(ee("ElementModifier").fields()){}class he extends(ee("GlimmerComment").fields()){}class ue extends(ee("HtmlText").fields()){}class pe extends(ee("HtmlComment").fields()){}class de extends(ee("AppendContent").fields()){get callee(){return"Call"===this.value.type?this.value.callee:this.value}get args(){return"Call"===this.value.type?this.value.args:se.empty(this.value.loc.collapse("end"))}}class me extends(ee("InvokeBlock").fields()){}class fe extends(ee("InvokeComponent").fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return se.named(new ne({loc:nt.range(t,this.callee.loc.collapse("end")),entries:t}))}}class be extends(ee("SimpleElement").fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return se.named(new ne({loc:nt.range(t,this.tag.loc.collapse("end")),entries:t}))}}class ge extends(ee("Literal").fields()){toSlice(){return new K({loc:this.loc,chars:this.value})}}class ke extends(ee("Path").fields()){}class we extends(ee("Keyword").fields()){}class ye extends(ee("Call").fields()){}class ve extends(ee("Interpolate").fields()){}class Se extends(ee().fields()){}class xe extends(ee().fields()){}class Pe extends(ee().fields()){get(t){return this.blocks.filter((e=>e.name.chars===t))[0]||null}}class Ce extends(ee().fields()){get args(){let t=this.componentArgs.map((t=>t.toNamedArgument()));return se.named(new ne({loc:nt.range(t,this.name.loc.collapse("end")),entries:t}))}}class Ee extends(ee("This").fields()){}class Ne extends(ee("Arg").fields()){}class Te extends(ee("Local").fields()){}class Ae extends(ee("Free").fields()){}const Be={resolution:()=>g.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},Le={...Be,isAngleBracket:!0};class Oe{static namespaced(t,e=!1){return new Oe([t],e)}static append(){return new Oe([He.Component,He.Helper])}static trustingAppend(){return this.namespaced(He.Helper)}constructor(t,e=!1){this.namespaces=t,this.isAngleBracket=e}resolution(){if(1!==this.namespaces.length)return g.GetFreeAsComponentOrHelperHead;switch(this.namespaces[0]){case He.Helper:return g.GetFreeAsHelperHead;case He.Modifier:return g.GetFreeAsModifierHead;case He.Component:return g.GetFreeAsComponentHead}}serialize(){return 1===this.namespaces.length?this.namespaces[0]:"ComponentOrHelper"}}let He=function(t){return t.Helper="Helper",t.Modifier="Modifier",t.Component="Component",t}({});const $e=He.Helper,Fe=He.Modifier,ze=He.Component;var Me=Object.freeze({__proto__:null,AppendContent:de,ArgReference:Ne,Args:se,Block:xe,COMPONENT_NAMESPACE:ze,CallExpression:ye,ComponentArg:le,ElementModifier:ce,FreeVarNamespace:He,FreeVarReference:Ae,GlimmerComment:he,HELPER_NAMESPACE:$e,HTML_RESOLUTION:Le,HtmlAttr:ie,HtmlComment:pe,HtmlText:ue,InterpolateExpression:ve,InvokeBlock:me,InvokeComponent:fe,KeywordExpression:we,LiteralExpression:ge,LocalVarReference:Te,LooseModeResolution:Oe,MODIFIER_NAMESPACE:Fe,NamedArgument:ae,NamedArguments:ne,NamedBlock:Ce,NamedBlocks:Pe,PathExpression:ke,PositionalArguments:re,STRICT_RESOLUTION:Be,SimpleElement:be,SplatAttr:oe,Template:Se,ThisReference:Ee,isLiteral:function(t,e){return"Literal"===t.type&&(void 0===e||("null"===e?null===t.value:typeof t.value===e))},isStrictResolution:function(t){return t===Be},loadResolution:function(t){return"Strict"===t?Be:"ComponentOrHelper"===t?Oe.append():Oe.namespaced(t)},node:ee});class Ie{static top(t,e,s){return new _e(t,e,s)}child(t){let e=t.map((t=>this.allocate(t)));return new Ue(this,t,e)}}class _e extends Ie{constructor(t,e,s){super(),this.templateLocals=t,this.keywords=e,this.options=s}symbols=[];upvars=[];size=1;named=u();blocks=u();usedTemplateLocals=[];#t=!1;hasLexical(t){return this.options.lexicalScope(t)}hasKeyword(t){return this.keywords.includes(t)}getKeyword(t){return this.allocateFree(t,Be)}getUsedTemplateLocals(){return this.usedTemplateLocals}setHasDebugger(){this.#t=!0}get hasEval(){return this.#t}has(t){return this.templateLocals.includes(t)}get(t){let e=this.usedTemplateLocals.indexOf(t);return-1!==e||(e=this.usedTemplateLocals.length,this.usedTemplateLocals.push(t)),[e,!0]}getLocalsMap(){return u()}getDebugInfo(){return Object.values(this.getLocalsMap())}allocateFree(t,e){e.resolution()===g.GetFreeAsComponentHead&&e.isAngleBracket&&(t=this.options.customizeComponentName(t));let s=this.upvars.indexOf(t);return-1!==s||(s=this.upvars.length,this.upvars.push(t)),s}allocateNamed(t){let e=this.named[t];return e||(e=this.named[t]=this.allocate(t)),e}allocateBlock(t){"inverse"===t&&(t="else");let e=this.blocks[t];return e||(e=this.blocks[t]=this.allocate(`&${t}`)),e}allocate(t){return this.symbols.push(t),this.size++}}class Ue extends Ie{constructor(t,e,s){super(),this.parent=t,this.symbols=e,this.slots=s}get locals(){return this.symbols}hasLexical(t){return this.parent.hasLexical(t)}getKeyword(t){return this.parent.getKeyword(t)}hasKeyword(t){return this.parent.hasKeyword(t)}has(t){return-1!==this.symbols.indexOf(t)||this.parent.has(t)}get(t){let e=this.#e(t);return e?[e,!1]:this.parent.get(t)}#e(t){let e=this.symbols.indexOf(t);return-1===e?null:a(this.slots[e])}getLocalsMap(){let t=this.parent.getLocalsMap();return this.symbols.forEach((e=>t[e]=this.get(e)[0])),t}getDebugInfo(){return Object.values(this.getLocalsMap())}setHasDebugger(){this.parent.setHasDebugger()}allocateFree(t,e){return this.parent.allocateFree(t,e)}allocateNamed(t){return this.parent.allocateNamed(t)}allocateBlock(t){return this.parent.allocateBlock(t)}allocate(t){return this.parent.allocate(t)}}var De=Object.freeze({__proto__:null});class Ve{template(t,e,s){return new Se({table:t,body:e,loc:s})}block(t,e,s){return new xe({scope:t,body:e,loc:s})}namedBlock(t,e,s){return new Ce({name:t,block:e,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(t,e,s){return new je({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(t,e,s)}slice(t,e){return new K({loc:e,chars:t})}args(t,e,s){return new se({loc:s,positional:t,named:e})}positional(t,e){return new re({loc:e,exprs:t})}namedArgument(t,e){return new ae({name:t,value:e})}named(t,e){return new ne({loc:e,entries:t})}attr({name:t,value:e,trusting:s},r){return new ie({loc:r,name:t,value:e,trusting:s})}splatAttr(t,e){return new oe({symbol:t,loc:e})}arg({name:t,value:e,trusting:s},r){return new le({name:t,value:e,trusting:s,loc:r})}path(t,e,s){return new ke({loc:s,ref:t,tail:e})}keyword(t,e,s){return new we({loc:s,name:t,symbol:e})}self(t){return new Ee({loc:t})}at(e,s,r){return t("@"===e[0],"call builders.at() with a string that starts with '@'"),new Ne({loc:r,name:new K({loc:r,chars:e}),symbol:s})}freeVar({name:e,context:s,symbol:r,loc:n}){return t("this"!==e,"You called builders.freeVar() with 'this'. Call builders.this instead"),t("@"!==e[0],`You called builders.freeVar() with '${e}'. Call builders.at('${e}') instead`),new Ae({name:e,resolution:s,symbol:r,loc:n})}localVar(e,s,r,n){return t("this"!==e,"You called builders.var() with 'this'. Call builders.this instead"),t("@"!==e[0],`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),new Te({loc:n,name:e,isTemplateLocal:r,symbol:s})}sexp(t,e){return new ye({loc:e,callee:t.callee,args:t.args})}interpolate(t,e){return h(t),new ve({loc:e,parts:t})}literal(t,e){return new ge({loc:e,value:t})}append({table:t,trusting:e,value:s},r){return new de({table:t,trusting:e,value:s,loc:r})}modifier({callee:t,args:e},s){return new ce({loc:s,callee:t,args:e})}namedBlocks(t,e){return new Pe({loc:e,blocks:t})}blockStatement({program:t,inverse:e=null,...s},r){let n=t.loc,a=[this.namedBlock(K.synthetic("default"),t,t.loc)];return e&&(n=n.extend(e.loc),a.push(this.namedBlock(K.synthetic("else"),e,e.loc))),new me({loc:r,blocks:this.namedBlocks(a,n),callee:s.callee,args:s.args})}element(t){return new je(t)}}class je{builder;constructor(t){this.base=t,this.builder=new Ve}simple(t,e,s){return new be(l({tag:t,body:e,componentArgs:[],loc:s},this.base))}named(t,e,s){return new Ce(l({name:t,block:e,componentArgs:[],loc:s},this.base))}selfClosingComponent(t,e){return new fe(l({loc:e,callee:t,blocks:new Pe({blocks:[],loc:e.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(t,e,s,r){let n=this.builder.block(s,e,r),a=this.builder.namedBlock(K.synthetic("default"),n,r);return new fe(l({loc:r,callee:t,blocks:this.builder.namedBlocks([a],a.loc)},this.base))}componentWithNamedBlocks(t,e,s){return new fe(l({loc:s,callee:t,blocks:this.builder.namedBlocks(e,nt.range(e))},this.base))}}function Ge(t){return We(t)?Oe.namespaced($e):null}function Ke(t){return We(t)?Oe.namespaced(Fe):null}function Je(t){return We(t)?Oe.namespaced(ze):null}function Re(t){return qe(t)?Oe.namespaced(ze,!0):null}function Ye(t){return We(t)?Oe.namespaced($e):null}function Qe(t){let e=We(t),s=t.trusting;return e?s?Oe.trustingAppend():Oe.append():null}function We(t){return qe(t.path)}function qe(t){return"PathExpression"===t.type&&"VarHead"===t.head.type&&0===t.tail.length}function Xe(t,e={lexicalScope:()=>!1}){let s=Xt(t,e),r={strictMode:!1,...e,locals:s.blockParams,keywords:e.keywords??[]},n=Ie.top(r.locals,r.keywords,{customizeComponentName:e.customizeComponentName??(t=>t),lexicalScope:e.lexicalScope}),a=new Ze(t,r,n),i=new es(a),o=new ns(a.loc(s.loc),s.body.map((t=>i.normalize(t))),a).assertTemplate(n);return[o,n.getUsedTemplateLocals()]}class Ze{builder;constructor(t,e,s){this.source=t,this.options=e,this.table=s,this.builder=new Ve}get strict(){return this.options.strictMode||!1}loc(t){return this.source.spanFor(t)}resolutionFor(t,e){if(this.strict)return{result:Be};if(this.isFreeVar(t)){let s=e(t);return null===s?{result:"error",path:cs(t),head:hs(t)}:{result:s}}return{result:Be}}isLexicalVar(t){return this.table.hasLexical(t)}isKeyword(t){return this.strict&&!this.table.hasLexical(t)&&this.table.hasKeyword(t)}isFreeVar(t){return"PathExpression"===t.type?"VarHead"===t.head.type&&!this.table.has(t.head.name):"PathExpression"===t.path.type&&this.isFreeVar(t.path)}hasBinding(t){return this.table.has(t)||this.table.hasLexical(t)}child(t){return new Ze(this.source,this.options,this.table.child(t))}customizeComponentName(t){return this.options.customizeComponentName?this.options.customizeComponentName(t):t}}class ts{constructor(t){this.block=t}normalize(e,s){switch(e.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(e.value,this.block.loc(e.loc));case"PathExpression":return t(s,"[BUG] resolution is required"),this.path(e,s);case"SubExpression":{os(e.path)&&ls(e.path,e.loc);let t=this.block.resolutionFor(e,Ge);if("error"===t.result)throw ct(`You attempted to invoke a path (\`${t.path}\`) but ${t.head} was not in scope`,e.loc);return this.block.builder.sexp(this.callParts(e,t.result),this.block.loc(e.loc))}}}path(t,e){let s=this.block.loc(t.loc);if("VarHead"===t.head.type&&0===t.tail.length&&this.block.isKeyword(t.head.name))return this.block.builder.keyword(t.head.name,this.block.table.getKeyword(t.head.name),s);let r=[],n=this.block.loc(t.head.loc);for(let e of t.tail)n=n.sliceStartChars({chars:e.length,skipStart:1}),r.push(new K({loc:n,chars:e}));return this.block.builder.path(this.ref(t.head,e),r,s)}callParts(t,e){let{path:s,params:r,hash:n,loc:a}=t,i=this.normalize(s,e),o=r.map((t=>this.normalize(t,Be))),l=nt.range(o,i.loc.collapse("end")),c=this.block.loc(n.loc),h=nt.range([l,c]),u=this.block.builder.positional(r.map((t=>this.normalize(t,Be))),l),p=this.block.builder.named(n.pairs.map((t=>this.namedArgument(t))),this.block.loc(n.loc));switch(i.type){case"Literal":throw ct(`Invalid invocation of a literal value (\`${i.value}\`)`,a);case"Interpolate":throw ct("Invalid invocation of a interpolated string",a)}return{callee:i,args:this.block.builder.args(u,p,h)}}namedArgument(t){let e=this.block.loc(t.loc).sliceStartChars({chars:t.key.length});return this.block.builder.namedArgument(new K({chars:t.key,loc:e}),this.normalize(t.value,Be))}ref(t,e){let{block:s}=this,{builder:r,table:n}=s,a=s.loc(t.loc);switch(t.type){case"ThisHead":return r.self(a);case"AtHead":{let e=n.allocateNamed(t.name);return r.at(t.name,e,a)}case"VarHead":if(s.hasBinding(t.name)){let[e,r]=n.get(t.name);return s.builder.localVar(t.name,e,r,a)}{let r=s.strict?Be:e,n=s.table.allocateFree(t.name,r);return s.builder.freeVar({name:t.name,context:r,symbol:n,loc:a})}}}}class es{constructor(t){this.block=t}normalize(t){switch(t.type){case"BlockStatement":return this.BlockStatement(t);case"ElementNode":return new ss(this.block).ElementNode(t);case"MustacheStatement":return this.MustacheStatement(t);case"MustacheCommentStatement":return this.MustacheCommentStatement(t);case"CommentStatement":{let e=this.block.loc(t.loc);return new pe({loc:e,text:e.slice({skipStart:4,skipEnd:3}).toSlice(t.value)})}case"TextNode":return new ue({loc:this.block.loc(t.loc),chars:t.chars})}}MustacheCommentStatement(t){let e,s=this.block.loc(t.loc);return e="{{!--"===s.asString().slice(0,5)?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new he({loc:s,text:e.toSlice(t.value)})}MustacheStatement(t){let e,{path:s,params:r,hash:n,trusting:a}=t,i=this.block.loc(t.loc);if(os(s))0===r.length&&0===n.pairs.length?e=this.expr.normalize(s):ls(s,i);else{let a=this.block.resolutionFor(t,Qe);if("error"===a.result)throw ct(`You attempted to render a path (\`{{${a.path}}}\`), but ${a.head} was not in scope`,i);let o=this.expr.callParts({path:s,params:r,hash:n,loc:i},a.result);e=o.args.isEmpty()?o.callee:this.block.builder.sexp(o,i)}return this.block.builder.append({table:this.block.table,trusting:a,value:e},i)}BlockStatement(t){let{program:e,inverse:s}=t,r=this.block.loc(t.loc);os(t.path)&&ls(t.path,r);let n=this.block.resolutionFor(t,Je);if("error"===n.result)throw ct(`You attempted to invoke a path (\`{{#${n.path}}}\`) but ${n.head} was not in scope`,r);let a=this.expr.callParts(t,n.result);return this.block.builder.blockStatement(l({symbols:this.block.table,program:this.Block(e),inverse:s?this.Block(s):null},a),r)}Block({body:t,loc:e,blockParams:s}){let r=this.block.child(s),n=new es(r);return new as(this.block.loc(e),t.map((t=>n.normalize(t))),this.block).assertBlock(r.table)}get expr(){return new ts(this.block)}}class ss{constructor(t){this.ctx=t}ElementNode(t){let{tag:e,selfClosing:s,comments:r}=t,n=this.ctx.loc(t.loc),[a,...i]=o(e.split(".")),l=this.classifyTag(a,i,t.loc),c=t.attributes.filter((t=>"@"!==t.name[0])).map((t=>this.attr(t))),h=t.attributes.filter((t=>"@"===t.name[0])).map((t=>this.arg(t))),u=t.modifiers.map((t=>this.modifier(t))),p=this.ctx.child(t.blockParams),d=new es(p),m=t.children.map((t=>d.normalize(t))),f=this.ctx.builder.element({selfClosing:s,attrs:c,componentArgs:h,modifiers:u,comments:r.map((t=>new es(this.ctx).MustacheCommentStatement(t)))}),b=new is(f,n,m,this.ctx),g=this.ctx.loc(t.loc).sliceStartChars({chars:e.length,skipStart:1});if("ElementHead"===l)return":"===e[0]?b.assertNamedBlock(g.slice({skipStart:1}).toSlice(e.slice(1)),p.table):b.assertElement(g.toSlice(e),t.blockParams.length>0);if(t.selfClosing)return f.selfClosingComponent(l,n);{let s=b.assertComponent(e,p.table,t.blockParams.length>0);return f.componentWithNamedBlocks(l,s,n)}}modifier(t){os(t.path)&&ls(t.path,t.loc);let e=this.ctx.resolutionFor(t,Ke);if("error"===e.result)throw ct(`You attempted to invoke a path (\`{{${e.path}}}\`) as a modifier, but ${e.head} was not in scope`,t.loc);let s=this.expr.callParts(t,e.result);return this.ctx.builder.modifier(s,this.ctx.loc(t.loc))}mustacheAttr(t){let{path:e,params:s,hash:r,loc:n}=t;if(os(e)){if(0===s.length&&0===r.pairs.length)return this.expr.normalize(e);ls(e,n)}let a=this.ctx.resolutionFor(t,Ye);if("error"===a.result)throw ct(`You attempted to render a path (\`{{${a.path}}}\`), but ${a.head} was not in scope`,t.loc);let i=this.ctx.builder.sexp(this.expr.callParts(t,a.result),this.ctx.loc(t.loc));return i.args.isEmpty()?i.callee:i}attrPart(t){switch(t.type){case"MustacheStatement":return{expr:this.mustacheAttr(t),trusting:t.trusting};case"TextNode":return{expr:this.ctx.builder.literal(t.chars,this.ctx.loc(t.loc)),trusting:!0}}}attrValue(t){if("ConcatStatement"===t.type){let e=t.parts.map((t=>this.attrPart(t).expr));return{expr:this.ctx.builder.interpolate(e,this.ctx.loc(t.loc)),trusting:!1}}return this.attrPart(t)}attr(e){if(t("@"!==e.name[0],"An attr name must not start with `@`"),"...attributes"===e.name)return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(e.loc));let s=this.ctx.loc(e.loc),r=s.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.attr({name:r,value:n.expr,trusting:n.trusting},s)}checkArgCall(t){let{value:e}=t;if("MustacheStatement"!==e.type)return;if(0!==e.params.length||0!==e.hash.pairs.length)return;let{path:s}=e;if("PathExpression"!==s.type)return;if(s.tail.length>0)return;let r=this.ctx.resolutionFor(s,(()=>null));if("error"===r.result&&"has-block"!==r.path)throw ct(`You attempted to pass a path as argument (\`${t.name}={{${r.path}}}\`) but ${r.head} was not in scope. Try:\n* \`${t.name}={{this.${r.path}}}\` if this is meant to be a property lookup, or\n* \`${t.name}={{(${r.path})}}\` if this is meant to invoke the resolved helper, or\n* \`${t.name}={{helper "${r.path}"}}\` if this is meant to pass the resolved helper by value`,t.loc)}arg(e){t("@"===e.name[0],"An arg name must start with `@`"),this.checkArgCall(e);let s=this.ctx.loc(e.loc),r=s.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.arg({name:r,value:n.expr,trusting:n.trusting},s)}classifyTag(t,e,s){let r=(n=t)[0]===n[0]?.toUpperCase()&&n[0]!==n[0]?.toLowerCase();var n;let a="@"===t[0]||"this"===t||this.ctx.hasBinding(t);if(this.ctx.strict&&!a){if(r)throw ct(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${t}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${t.toLowerCase()}>\``,s);return"ElementHead"}let i=a||r,o=s.sliceStartChars({skipStart:1,chars:t.length}),l=e.reduce(((t,e)=>t+1+e.length),0),c=o.getEnd().move(l),h=o.withEnd(c);if(i){let r=Vt.path({head:Vt.head({original:t,loc:o}),tail:e,loc:h}),n=this.ctx.isLexicalVar(t)?{result:Be}:this.ctx.resolutionFor(r,Re);if("error"===n.result)throw ct(`You attempted to invoke a path (\`<${n.path}>\`) but ${n.head} was not in scope`,s);return new ts(this.ctx).normalize(r,n.result)}if(this.ctx.table.allocateFree(t,Be),e.length>0)throw ct(`You used ${t}.${e.join(".")} as a tag name, but ${t} is not in scope`,s);return"ElementHead"}get expr(){return new ts(this.ctx)}}class rs{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(t,e,s){this.loc=t,this.children=e,this.block=s,this.namedBlocks=e.filter((t=>t instanceof Ce)),this.hasSemanticContent=Boolean(e.filter((t=>{if(t instanceof Ce)return!1;switch(t.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(t.chars);default:return!0}})).length),this.nonBlockChildren=e.filter((t=>!(t instanceof Ce)))}}class ns extends rs{assertTemplate(t){if(e(this.namedBlocks))throw ct("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(t,this.nonBlockChildren,this.block.loc(this.loc))}}class as extends rs{assertBlock(t){if(e(this.namedBlocks))throw ct("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(t,this.nonBlockChildren,this.loc)}}class is extends rs{constructor(t,e,s,r){super(e,s,r),this.el=t}assertNamedBlock(t,s){if(this.el.base.selfClosing)throw ct(`<:${t.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(e(this.namedBlocks))throw ct(`Unexpected named block inside <:${t.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((r=t.chars)[0]!==r[0]?.toLowerCase()||r[0]===r[0]?.toUpperCase())throw ct(`<:${t.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var r;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw ct(`named block <:${t.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let n=nt.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(t,this.block.builder.block(s,this.nonBlockChildren,n),this.loc)}assertElement(t,s){if(s)throw ct(`Unexpected block params in <${t.chars}>: simple elements cannot have block params`,this.loc);if(e(this.namedBlocks)){let e=this.namedBlocks.map((t=>t.name));if(1===e.length)throw ct(`Unexpected named block <:foo> inside <${t.chars}> HTML element`,this.loc);{let s=e.map((t=>`<:${t.chars}>`)).join(", ");throw ct(`Unexpected named blocks inside <${t.chars}> HTML element (${s})`,this.loc)}}return this.el.simple(t,this.nonBlockChildren,this.loc)}assertComponent(t,s,r){if(e(this.namedBlocks)&&this.hasSemanticContent)throw ct(`Unexpected content inside <${t}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(e(this.namedBlocks)){if(r)throw ct(`Unexpected block params list on <${t}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let e=new Set;for(let t of this.namedBlocks){let s=t.name.chars;if(e.has(s))throw ct(`Component had two named blocks with the same name, \`<:${s}>\`. Only one block with a given name may be passed`,this.loc);if("inverse"===s&&e.has("else")||"else"===s&&e.has("inverse"))throw ct("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);e.add(s)}return this.namedBlocks}return[this.block.builder.namedBlock(K.synthetic("default"),this.block.builder.block(s,this.nonBlockChildren,this.loc),this.loc)]}}function os(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return!0;default:return!1}}function ls(t,e){throw ct(`Unexpected literal \`${"StringLiteral"===t.type?JSON.stringify(t.value):String(t.value)}\``,e)}function cs(t){return"PathExpression"!==t.type&&"PathExpression"===t.path.type?cs(t.path):new B({entityEncoding:"raw"}).print(t)}function hs(t){return"PathExpression"===t.type?t.head.original:"PathExpression"===t.path.type?hs(t.path):new B({entityEncoding:"raw"}).print(t)}export{De as AST,De as ASTv1,Me as ASTv2,Ue as BlockSymbolTable,H as KEYWORDS_TYPES,Ct as Path,_e as ProgramSymbolTable,K as SourceSlice,nt as SpanList,Ie as SymbolTable,Ct as Walker,ft as WalkerPath,_t as builders,pt as cannotRemoveNode,dt as cannotReplaceNode,ct as generateSyntaxError,te as getTemplateLocals,N as getVoidTags,it as hasSpan,O as isKeyword,A as isVoidTag,at as loc,ot as maybeLoc,ee as node,Xe as normalize,Xt as preprocess,L as print,C as sortByLoc,lt as src,Pt as traverse,ht as visitorKeys};
//# sourceMappingURL=index.js.map
