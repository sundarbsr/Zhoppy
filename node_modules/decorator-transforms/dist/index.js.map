{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/babel-import-util@3.0.0/node_modules/babel-import-util/src/index.js","../node_modules/.pnpm/@babel+helper-plugin-utils@7.22.5/node_modules/@babel/helper-plugin-utils/lib/index.js","../node_modules/.pnpm/@babel+plugin-syntax-decorators@7.23.3_@babel+core@7.23.3/node_modules/@babel/plugin-syntax-decorators/lib/index.js","../src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImportUtil = void 0;\nclass ImportUtil {\n    constructor(babel, program) {\n        this.babel = babel;\n        this.program = program;\n        this.t = babel.types;\n    }\n    // remove one imported binding. If this is the last thing imported from the\n    // given moduleSpecifier, the whole statement will also be removed.\n    removeImport(moduleSpecifier, exportedName) {\n        for (let topLevelPath of this.program.get('body')) {\n            if (!matchModule(topLevelPath, moduleSpecifier)) {\n                continue;\n            }\n            let importSpecifierPath = topLevelPath\n                .get('specifiers')\n                .find((specifierPath) => matchSpecifier(specifierPath, exportedName));\n            if (importSpecifierPath) {\n                if (topLevelPath.node.specifiers.length === 1) {\n                    topLevelPath.remove();\n                }\n                else {\n                    importSpecifierPath.remove();\n                }\n            }\n        }\n    }\n    // remove all imports from the given moduleSpecifier\n    removeAllImports(moduleSpecifier) {\n        for (let topLevelPath of this.program.get('body')) {\n            if (matchModule(topLevelPath, moduleSpecifier)) {\n                topLevelPath.remove();\n            }\n        }\n    }\n    // Import the given value (if needed) and return an Identifier representing\n    // it.\n    //\n    // This method is trickier to use safely than our higher-level methods\n    // (`insertAfter`, `insertBefore`, `replaceWith`, `mutate`) because after you\n    // insert the identifier into the AST, it's up to you to ensure that babel's\n    // scope system is aware of the new reference. The other methods do that for\n    // you automatically.\n    import(\n    // the spot at which you will insert the Identifier we return to you\n    target, \n    // the path to the module you're importing from\n    moduleSpecifier, \n    // the name you're importing from that module. Use \"default\" for the default\n    // export. Use \"*\" for the namespace.\n    exportedName, \n    // Optional hint for helping us pick a name for the imported binding\n    nameHint) {\n        return this.unreferencedImport(target, moduleSpecifier, exportedName, desiredName(nameHint, exportedName, defaultNameHint(target)));\n    }\n    // Import the given value (if needed) and return an Identifier representing\n    // it.\n    unreferencedImport(\n    // the spot at which you will insert the Identifier we return to you\n    target, \n    // the path to the module you're importing from\n    moduleSpecifier, \n    // the name you're importing from that module. Use \"default\" for the default\n    // export. Use \"*\" for the namespace.\n    exportedName, \n    // the preferred name you want, if we neeed to create a new binding. You\n    // might get something similar instead, to avoid collisions.\n    preferredName) {\n        var _a;\n        let isNamespaceImport = exportedName === '*';\n        let isDefaultImport = exportedName === 'default';\n        let isNamedImport = !isDefaultImport && !isNamespaceImport;\n        let declaration = this.findImportFrom(moduleSpecifier);\n        let hasNamespaceSpecifier = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === 'ImportNamespaceSpecifier');\n        let hasNamedSpecifiers = declaration === null || declaration === void 0 ? void 0 : declaration.node.specifiers.find((s) => s.type === 'ImportSpecifier');\n        /**\n         * the file has a preexisting non-namespace import and a transform tries to add a namespace import, so they don't get combined\n         * the file has a preexisting namespace import and a transform tries to add a non-namespace import, so they don't get combined\n         * the file has a preexisting namespace import and a transform tries to add a namespace import, so they don't get combined\n         */\n        let cannotUseExistingDeclaration = (hasNamedSpecifiers && isNamespaceImport) ||\n            (hasNamespaceSpecifier && isNamedImport) ||\n            (hasNamespaceSpecifier && isNamespaceImport);\n        if (!cannotUseExistingDeclaration && declaration) {\n            let specifier = declaration\n                .get('specifiers')\n                .find((spec) => matchSpecifier(spec, exportedName));\n            if (specifier && ((_a = target.scope.getBinding(specifier.node.local.name)) === null || _a === void 0 ? void 0 : _a.kind) === 'module') {\n                return this.t.identifier(specifier.node.local.name);\n            }\n            else {\n                return this.addSpecifier(target, declaration, exportedName, preferredName);\n            }\n        }\n        else {\n            let declaration = this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));\n            return this.addSpecifier(target, declaration, exportedName, preferredName);\n        }\n    }\n    importForSideEffect(moduleSpecifier) {\n        let declaration = this.findImportFrom(moduleSpecifier);\n        if (!declaration) {\n            this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));\n        }\n    }\n    replaceWith(target, fn) {\n        return this.mutate((i) => {\n            target.replaceWith(fn(i));\n            // the return value of replaceWith is not a reliable way to get the\n            // updated path, at least in the case where the user replaced an\n            // expression with a statement. Instead we will rely on the fact that path\n            // replacement also mutates its argument, so `target` now points at the\n            // newly replaced path.\n            return target;\n        }, defaultNameHint(target));\n    }\n    insertAfter(target, fn) {\n        return this.mutate((i) => target.insertAfter(fn(i))[0], defaultNameHint(target));\n    }\n    insertBefore(target, fn) {\n        return this.mutate((i) => target.insertBefore(fn(i))[0], defaultNameHint(target));\n    }\n    // Low-level method for when you don't want to use our higher-level methods\n    // (replaceWith, insertBefore, insertAfter)\n    mutate(fn, defaultNameHint) {\n        let symbols = new Map();\n        const importer = {\n            import: (moduleSpecifier, exportedName, nameHint) => {\n                let identifier = this.t.identifier('__babel_import_util_placeholder__');\n                symbols.set(identifier, { moduleSpecifier, exportedName, nameHint });\n                return identifier;\n            },\n        };\n        const updateReference = (path) => {\n            if (!path.isIdentifier()) {\n                return;\n            }\n            let hit = symbols.get(path.node);\n            if (hit) {\n                let newIdentifier = this.unreferencedImport(path, hit.moduleSpecifier, hit.exportedName, desiredName(hit.nameHint, hit.exportedName, defaultNameHint));\n                path.replaceWith(newIdentifier);\n                let binding = path.scope.getBinding(newIdentifier.name);\n                if (!binding) {\n                    // we create the binding at the point where we add the import, so this\n                    // would indicate broken behavior\n                    throw new Error(`bug: this is supposed to never happen`);\n                }\n                binding.reference(path);\n            }\n        };\n        let result = fn(importer);\n        updateReference(result);\n        this.babel.traverse(result.node, {\n            ReferencedIdentifier: (path) => {\n                updateReference(path);\n            },\n        }, result.scope, {}, result);\n        return result;\n    }\n    addSpecifier(target, declaration, exportedName, preferredName) {\n        let local = this.t.identifier(unusedNameLike(target, preferredName));\n        let specifier = this.buildSpecifier(exportedName, local);\n        let added;\n        if (specifier.type === 'ImportDefaultSpecifier') {\n            declaration.node.specifiers.unshift(specifier);\n            added = declaration.get(`specifiers.0`);\n        }\n        else {\n            declaration.node.specifiers.push(specifier);\n            added = declaration.get(`specifiers.${declaration.node.specifiers.length - 1}`);\n        }\n        declaration.scope.registerBinding('module', added);\n        return local;\n    }\n    buildSpecifier(exportedName, localName) {\n        switch (exportedName) {\n            case 'default':\n                return this.t.importDefaultSpecifier(localName);\n            case '*':\n                return this.t.importNamespaceSpecifier(localName);\n            default:\n                return this.t.importSpecifier(localName, this.t.identifier(exportedName));\n        }\n    }\n    findImportFrom(moduleSpecifier) {\n        for (let path of this.program.get('body')) {\n            if (path.isImportDeclaration() &&\n                path.node.source.value === moduleSpecifier &&\n                path.node.importKind !== 'type') {\n                return path;\n            }\n        }\n        return undefined;\n    }\n    insertAfterExistingImports(statement) {\n        let lastIndex;\n        for (let [index, node] of this.program.node.body.entries()) {\n            if (node.type === 'ImportDeclaration') {\n                lastIndex = index;\n            }\n        }\n        if (lastIndex == null) {\n            // we are intentionally not using babel's container-aware methods, because\n            // while in theory it's nice that they schedule other plugins to run on\n            // our nodes, in practice those nodes might get mutated or removed by some\n            // other plugin in the intervening time causing failures.\n            this.program.node.body.unshift(statement);\n            return this.program.get('body.0');\n        }\n        else {\n            this.program.node.body.splice(lastIndex + 1, 0, statement);\n            return this.program.get(`body.${lastIndex + 1}`);\n        }\n    }\n}\nexports.ImportUtil = ImportUtil;\nfunction unusedNameLike(path, name) {\n    let candidate = name;\n    let counter = 0;\n    while (path.scope.hasBinding(candidate)) {\n        candidate = `${name}${counter++}`;\n    }\n    return candidate;\n}\nfunction name(node) {\n    if (node.type === 'StringLiteral') {\n        return node.value;\n    }\n    else {\n        return node.name;\n    }\n}\nfunction desiredName(nameHint, exportedName, defaultNameHint) {\n    if (nameHint) {\n        // first we opportunistically do camelization when an illegal character is\n        // followed by a lowercase letter, in an effort to aid readability of the\n        // output.\n        let cleaned = nameHint.replace(/[^a-zA-Z_]([a-z])/g, (_m, letter) => letter.toUpperCase());\n        // then we unliterally strip all remaining illegal characters.\n        cleaned = cleaned.replace(/[^a-zA-Z_]/g, '');\n        return cleaned;\n    }\n    if (exportedName === 'default' || exportedName === '*') {\n        return defaultNameHint !== null && defaultNameHint !== void 0 ? defaultNameHint : 'a';\n    }\n    else {\n        return exportedName;\n    }\n}\nfunction defaultNameHint(target) {\n    if (target === null || target === void 0 ? void 0 : target.isIdentifier()) {\n        return target.node.name;\n    }\n    else if (target) {\n        return target.scope.generateUidIdentifierBasedOnNode(target.node).name;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction matchSpecifier(spec, exportedName) {\n    switch (exportedName) {\n        case 'default':\n            return spec.isImportDefaultSpecifier();\n        case '*':\n            return spec.isImportNamespaceSpecifier();\n        default:\n            return spec.isImportSpecifier() && name(spec.node.imported) === exportedName;\n    }\n}\nfunction matchModule(path, moduleSpecifier) {\n    return path.isImportDeclaration() && path.get('source').node.value === moduleSpecifier;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxNQUFhLFVBQVU7SUFHckIsWUFBb0IsS0FBbUIsRUFBVSxPQUE0QjtRQUF6RCxVQUFLLEdBQUwsS0FBSyxDQUFjO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBcUI7UUFDM0UsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCwyRUFBMkU7SUFDM0UsbUVBQW1FO0lBQ25FLFlBQVksQ0FBQyxlQUF1QixFQUFFLFlBQW9CO1FBQ3hELEtBQUssSUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDakQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsZUFBZSxDQUFDLEVBQUU7Z0JBQy9DLFNBQVM7YUFDVjtZQUVELElBQUksbUJBQW1CLEdBQUcsWUFBWTtpQkFDbkMsR0FBRyxDQUFDLFlBQVksQ0FBQztpQkFDakIsSUFBSSxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDeEUsSUFBSSxtQkFBbUIsRUFBRTtnQkFDdkIsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO29CQUM3QyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7aUJBQ3ZCO3FCQUFNO29CQUNMLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUM5QjthQUNGO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsb0RBQW9EO0lBQ3BELGdCQUFnQixDQUFDLGVBQXVCO1FBQ3RDLEtBQUssSUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDakQsSUFBSSxXQUFXLENBQUMs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SUFBSSxDQUFDO0tBQ3hFO1NBQU07UUFDTCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxJQUFtQixFQUFFLFlBQW9CO0lBQy9ELFFBQVEsWUFBWSxFQUFFO1FBQ3BCLEtBQUssU0FBUztZQUNaLE9BQU8sSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDekMsS0FBSyxHQUFHO1lBQ04sT0FBTyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztRQUMzQztZQUNFLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssWUFBWSxDQUFDO0tBQ2hGO0FBQ0gsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUNsQixJQUFtQixFQUNuQixlQUF1QjtJQUV2QixPQUFPLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxlQUFlLENBQUM7QUFDekYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0LCBOb2RlUGF0aCB9IGZyb20gJ0BiYWJlbC9jb3JlJztcblxuZXhwb3J0IGNsYXNzIEltcG9ydFV0aWwge1xuICBwcml2YXRlIHQ6IHR5cGVvZiBCYWJlbC50eXBlcztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJhYmVsOiB0eXBlb2YgQmFiZWwsIHByaXZhdGUgcHJvZ3JhbTogTm9kZVBhdGg8dC5Qcm9ncmFtPikge1xuICAgIHRoaXMudCA9IGJhYmVsLnR5cGVzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIG9uZSBpbXBvcnRlZCBiaW5kaW5nLiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRoaW5nIGltcG9ydGVkIGZyb20gdGhlXG4gIC8vIGdpdmVuIG1vZHVsZVNwZWNpZmllciwgdGhlIHdob2xlIHN0YXRlbWVudCB3aWxsIGFsc28gYmUgcmVtb3ZlZC5cbiAgcmVtb3ZlSW1wb3J0KG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLCBleHBvcnRlZE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGZvciAobGV0IHRvcExldmVsUGF0aCBvZiB0aGlzLnByb2dyYW0uZ2V0KCdib2R5JykpIHtcbiAgICAgIGlmICghbWF0Y2hNb2R1bGUodG9wTGV2ZWxQYXRoLCBtb2R1bGVTcGVjaWZpZXIpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgaW1wb3J0U3BlY2lmaWVyUGF0aCA9IHRvcExldmVsUGF0aFxuICAgICAgICAuZ2V0KCdzcGVjaWZpZXJzJylcbiAgICAgICAgLmZpbmQoKHNwZWNpZmllclBhdGgpID0+IG1hdGNoU3BlY2lmaWVyKHNwZWNpZmllclBhdGgsIGV4cG9ydGVkTmFtZSkpO1xuICAgICAgaWYgKGltcG9ydFNwZWNpZmllclBhdGgpIHtcbiAgICAgICAgaWYgKHRvcExldmVsUGF0aC5ub2RlLnNwZWNpZmllcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdG9wTGV2ZWxQYXRoLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcG9ydFNwZWNpZmllclBhdGgucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIGltcG9ydHMgZnJvbSB0aGUgZ2l2ZW4gbW9kdWxlU3BlY2lmaWVyXG4gIHJlbW92ZUFsbEltcG9ydHMobW9kdWxlU3BlY2lmaWVyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBmb3IgKGxldCB0b3BMZXZlbFBhdGggb2YgdGhpcy5wcm9ncmFtLmdldCgnYm9keScpKSB7XG4gICAgICBpZiAobWF0Y2hNb2R1bGUodG9wTGV2ZWxQYXRoLCBtb2R1bGVTcGVjaWZpZXIpKSB7XG4gICAgICAgIHRvcExldmVsUGF0aC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJbXBvcnQgdGhlIGdpdmVuIHZhbHVlIChpZiBuZWVkZWQpIGFuZCByZXR1cm4gYW4gSWRlbnRpZmllciByZXByZXNlbnRpbmdcbiAgLy8gaXQuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHRyaWNraWVyIHRvIHVzZSBzYWZlbHkgdGhhbiBvdXIgaGlnaGVyLWxldmVsIG1ldGhvZHNcbiAgLy8gKGBpbnNlcnRBZnRlcmAsIGBpbnNlcnRCZWZvcmVgLCBgcmVwbGFjZVdpdGhgLCBgbXV0YXRlYCkgYmVjYXVzZSBhZnRlciB5b3VcbiAgLy8gaW5zZXJ0IHRoZSBpZGVudGlmaWVyIGludG8gdGhlIEFTVCwgaXQncyB1cCB0byB5b3UgdG8gZW5zdXJlIHRoYXQgYmFiZWwnc1xuICAvLyBzY29wZSBzeXN0ZW0gaXMgYXdhcmUgb2YgdGhlIG5ldyByZWZlcmVuY2UuIFRoZSBvdGhlciBtZXRob2RzIGRvIHRoYXQgZm9yXG4gIC8vIHlvdSBhdXRvbWF0aWNhbGx5LlxuICBpbXBvcnQoXG4gICAgLy8gdGhlIHNwb3QgYXQgd2hpY2ggeW91IHdpbGwgaW5zZXJ0IHRoZSBJZGVudGlmaWVyIHdlIHJldHVybiB0byB5b3VcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG5cbiAgICAvLyB0aGUgcGF0aCB0byB0aGUgbW9kdWxlIHlvdSdyZSBpbXBvcnRpbmcgZnJvbVxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuXG4gICAgLy8gdGhlIG5hbWUgeW91J3JlIGltcG9ydGluZyBmcm9tIHRoYXQgbW9kdWxlLiBVc2UgXCJkZWZhdWx0XCIgZm9yIHRoZSBkZWZhdWx0XG4gICAgLy8gZXhwb3J0LiBVc2UgXCIqXCIgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG5cbiAgICAvLyBPcHRpb25hbCBoaW50IGZvciBoZWxwaW5nIHVzIHBpY2sgYSBuYW1lIGZvciB0aGUgaW1wb3J0ZWQgYmluZGluZ1xuICAgIG5hbWVIaW50Pzogc3RyaW5nXG4gICk6IHQuSWRlbnRpZmllciB7XG4gICAgcmV0dXJuIHRoaXMudW5yZWZlcmVuY2VkSW1wb3J0KFxuICAgICAgdGFyZ2V0LFxuICAgICAgbW9kdWxlU3BlY2lmaWVyLFxuICAgICAgZXhwb3J0ZWROYW1lLFxuICAgICAgZGVzaXJlZE5hbWUobmFtZUhpbnQsIGV4cG9ydGVkTmFtZSwgZGVmYXVsdE5hbWVIaW50KHRhcmdldCkpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEltcG9ydCB0aGUgZ2l2ZW4gdmFsdWUgKGlmIG5lZWRlZCkgYW5kIHJldHVybiBhbiBJZGVudGlmaWVyIHJlcHJlc2VudGluZ1xuICAvLyBpdC5cbiAgcHJpdmF0ZSB1bnJlZmVyZW5jZWRJbXBvcnQoXG4gICAgLy8gdGhlIHNwb3QgYXQgd2hpY2ggeW91IHdpbGwgaW5zZXJ0IHRoZSBJZGVudGlmaWVyIHdlIHJldHVybiB0byB5b3VcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG5cbiAgICAvLyB0aGUgcGF0aCB0byB0aGUgbW9kdWxlIHlvdSdyZSBpbXBvcnRpbmcgZnJvbVxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuXG4gICAgLy8gdGhlIG5hbWUgeW91J3JlIGltcG9ydGluZyBmcm9tIHRoYXQgbW9kdWxlLiBVc2UgXCJkZWZhdWx0XCIgZm9yIHRoZSBkZWZhdWx0XG4gICAgLy8gZXhwb3J0LiBVc2UgXCIqXCIgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG5cbiAgICAvLyB0aGUgcHJlZmVycmVkIG5hbWUgeW91IHdhbnQsIGlmIHdlIG5lZWVkIHRvIGNyZWF0ZSBhIG5ldyBiaW5kaW5nLiBZb3VcbiAgICAvLyBtaWdodCBnZXQgc29tZXRoaW5nIHNpbWlsYXIgaW5zdGVhZCwgdG8gYXZvaWQgY29sbGlzaW9ucy5cbiAgICBwcmVmZXJyZWROYW1lOiBzdHJpbmdcbiAgKTogdC5JZGVudGlmaWVyIHtcbiAgICBsZXQgaXNOYW1lc3BhY2VJbXBvcnQgPSBleHBvcnRlZE5hbWUgPT09ICcqJztcbiAgICBsZXQgaXNEZWZhdWx0SW1wb3J0ID0gZXhwb3J0ZWROYW1lID09PSAnZGVmYXVsdCc7XG4gICAgbGV0IGlzTmFtZWRJbXBvcnQgPSAhaXNEZWZhdWx0SW1wb3J0ICYmICFpc05hbWVzcGFjZUltcG9ydDtcbiAgICBsZXQgZGVjbGFyYXRpb24gPSB0aGlzLmZpbmRJbXBvcnRGcm9tKG1vZHVsZVNwZWNpZmllcik7XG4gICAgbGV0IGhhc05hbWVzcGFjZVNwZWNpZmllciA9IGRlY2xhcmF0aW9uPy5ub2RlLnNwZWNpZmllcnMuZmluZChcbiAgICAgIChzKSA9PiBzLnR5cGUgPT09ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInXG4gICAgKTtcbiAgICBsZXQgaGFzTmFtZWRTcGVjaWZpZXJzID0gZGVjbGFyYXRpb24/Lm5vZGUuc3BlY2lmaWVycy5maW5kKChzKSA9PiBzLnR5cGUgPT09ICdJbXBvcnRTcGVjaWZpZXInKTtcblxuICAgIC8qKlxuICAgICAqIHRoZSBmaWxlIGhhcyBhIHByZWV4aXN0aW5nIG5vbi1uYW1lc3BhY2UgaW1wb3J0IGFuZCBhIHRyYW5zZm9ybSB0cmllcyB0byBhZGQgYSBuYW1lc3BhY2UgaW1wb3J0LCBzbyB0aGV5IGRvbid0IGdldCBjb21iaW5lZFxuICAgICAqIHRoZSBmaWxlIGhhcyBhIHByZWV4aXN0aW5nIG5hbWVzcGFjZSBpbXBvcnQgYW5kIGEgdHJhbnNmb3JtIHRyaWVzIHRvIGFkZCBhIG5vbi1uYW1lc3BhY2UgaW1wb3J0LCBzbyB0aGV5IGRvbid0IGdldCBjb21iaW5lZFxuICAgICAqIHRoZSBmaWxlIGhhcyBhIHByZWV4aXN0aW5nIG5hbWVzcGFjZSBpbXBvcnQgYW5kIGEgdHJhbnNmb3JtIHRyaWVzIHRvIGFkZCBhIG5hbWVzcGFjZSBpbXBvcnQsIHNvIHRoZXkgZG9uJ3QgZ2V0IGNvbWJpbmVkXG4gICAgICovXG4gICAgbGV0IGNhbm5vdFVzZUV4aXN0aW5nRGVjbGFyYXRpb24gPVxuICAgICAgKGhhc05hbWVkU3BlY2lmaWVycyAmJiBpc05hbWVzcGFjZUltcG9ydCkgfHxcbiAgICAgIChoYXNOYW1lc3BhY2VTcGVjaWZpZXIgJiYgaXNOYW1lZEltcG9ydCkgfHxcbiAgICAgIChoYXNOYW1lc3BhY2VTcGVjaWZpZXIgJiYgaXNOYW1lc3BhY2VJbXBvcnQpO1xuXG4gICAgaWYgKCFjYW5ub3RVc2VFeGlzdGluZ0RlY2xhcmF0aW9uICYmIGRlY2xhcmF0aW9uKSB7XG4gICAgICBsZXQgc3BlY2lmaWVyID0gZGVjbGFyYXRpb25cbiAgICAgICAgLmdldCgnc3BlY2lmaWVycycpXG4gICAgICAgIC5maW5kKChzcGVjKSA9PiBtYXRjaFNwZWNpZmllcihzcGVjLCBleHBvcnRlZE5hbWUpKTtcbiAgICAgIGlmIChzcGVjaWZpZXIgJiYgdGFyZ2V0LnNjb3BlLmdldEJpbmRpbmcoc3BlY2lmaWVyLm5vZGUubG9jYWwubmFtZSk/LmtpbmQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnQuaWRlbnRpZmllcihzcGVjaWZpZXIubm9kZS5sb2NhbC5uYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNwZWNpZmllcih0YXJnZXQsIGRlY2xhcmF0aW9uLCBleHBvcnRlZE5hbWUsIHByZWZlcnJlZE5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVjbGFyYXRpb24gPSB0aGlzLmluc2VydEFmdGVyRXhpc3RpbmdJbXBvcnRzKFxuICAgICAgICB0aGlzLnQuaW1wb3J0RGVjbGFyYXRpb24oW10sIHRoaXMudC5zdHJpbmdMaXRlcmFsKG1vZHVsZVNwZWNpZmllcikpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkU3BlY2lmaWVyKHRhcmdldCwgZGVjbGFyYXRpb24sIGV4cG9ydGVkTmFtZSwgcHJlZmVycmVkTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgaW1wb3J0Rm9yU2lkZUVmZmVjdChtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBkZWNsYXJhdGlvbiA9IHRoaXMuZmluZEltcG9ydEZyb20obW9kdWxlU3BlY2lmaWVyKTtcbiAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzLmluc2VydEFmdGVyRXhpc3RpbmdJbXBvcnRzKFxuICAgICAgICB0aGlzLnQuaW1wb3J0RGVjbGFyYXRpb24oW10sIHRoaXMudC5zdHJpbmdMaXRlcmFsKG1vZHVsZVNwZWNpZmllcikpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlcGxhY2VXaXRoPFQgZXh0ZW5kcyB0Lk5vZGUsIFIgZXh0ZW5kcyB0Lk5vZGU+KFxuICAgIHRhcmdldDogTm9kZVBhdGg8VD4sXG4gICAgZm46IChpOiBJbXBvcnRlcikgPT4gUlxuICApOiBOb2RlUGF0aDxSPiB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRlKChpKSA9PiB7XG4gICAgICB0YXJnZXQucmVwbGFjZVdpdGgoZm4oaSkpO1xuICAgICAgLy8gdGhlIHJldHVybiB2YWx1ZSBvZiByZXBsYWNlV2l0aCBpcyBub3QgYSByZWxpYWJsZSB3YXkgdG8gZ2V0IHRoZVxuICAgICAgLy8gdXBkYXRlZCBwYXRoLCBhdCBsZWFzdCBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgdXNlciByZXBsYWNlZCBhblxuICAgICAgLy8gZXhwcmVzc2lvbiB3aXRoIGEgc3RhdGVtZW50LiBJbnN0ZWFkIHdlIHdpbGwgcmVseSBvbiB0aGUgZmFjdCB0aGF0IHBhdGhcbiAgICAgIC8vIHJlcGxhY2VtZW50IGFsc28gbXV0YXRlcyBpdHMgYXJndW1lbnQsIHNvIGB0YXJnZXRgIG5vdyBwb2ludHMgYXQgdGhlXG4gICAgICAvLyBuZXdseSByZXBsYWNlZCBwYXRoLlxuICAgICAgcmV0dXJuIHRhcmdldCBhcyB1bmtub3duIGFzIE5vZGVQYXRoPFI+O1xuICAgIH0sIGRlZmF1bHROYW1lSGludCh0YXJnZXQpKTtcbiAgfVxuXG4gIGluc2VydEFmdGVyPFQgZXh0ZW5kcyB0Lk5vZGUsIFIgZXh0ZW5kcyB0Lk5vZGU+KFxuICAgIHRhcmdldDogTm9kZVBhdGg8VD4sXG4gICAgZm46IChpOiBJbXBvcnRlcikgPT4gUlxuICApOiBOb2RlUGF0aDxSPiB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRlKChpKSA9PiB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZm4oaSkpWzBdIGFzIE5vZGVQYXRoPFI+LCBkZWZhdWx0TmFtZUhpbnQodGFyZ2V0KSk7XG4gIH1cblxuICBpbnNlcnRCZWZvcmU8VCBleHRlbmRzIHQuTm9kZSwgUiBleHRlbmRzIHQuTm9kZT4oXG4gICAgdGFyZ2V0OiBOb2RlUGF0aDxUPixcbiAgICBmbjogKGk6IEltcG9ydGVyKSA9PiBSXG4gICk6IE5vZGVQYXRoPFI+IHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGUoXG4gICAgICAoaSkgPT4gdGFyZ2V0Lmluc2VydEJlZm9yZShmbihpKSlbMF0gYXMgTm9kZVBhdGg8Uj4sXG4gICAgICBkZWZhdWx0TmFtZUhpbnQodGFyZ2V0KVxuICAgICk7XG4gIH1cblxuICAvLyBMb3ctbGV2ZWwgbWV0aG9kIGZvciB3aGVuIHlvdSBkb24ndCB3YW50IHRvIHVzZSBvdXIgaGlnaGVyLWxldmVsIG1ldGhvZHNcbiAgLy8gKHJlcGxhY2VXaXRoLCBpbnNlcnRCZWZvcmUsIGluc2VydEFmdGVyKVxuICBtdXRhdGU8UmVwbGFjZW1lbnQgZXh0ZW5kcyB0Lk5vZGU+KFxuICAgIGZuOiAoaW1wb3J0ZXI6IEltcG9ydGVyKSA9PiBOb2RlUGF0aDxSZXBsYWNlbWVudD4sXG4gICAgZGVmYXVsdE5hbWVIaW50Pzogc3RyaW5nXG4gICk6IE5vZGVQYXRoPFJlcGxhY2VtZW50PiB7XG4gICAgbGV0IHN5bWJvbHM6IE1hcDxcbiAgICAgIHQuSWRlbnRpZmllcixcbiAgICAgIHsgbW9kdWxlU3BlY2lmaWVyOiBzdHJpbmc7IGV4cG9ydGVkTmFtZTogc3RyaW5nOyBuYW1lSGludDogc3RyaW5nIHwgdW5kZWZpbmVkIH1cbiAgICA+ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGltcG9ydGVyOiBJbXBvcnRlciA9IHtcbiAgICAgIGltcG9ydDogKG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLCBleHBvcnRlZE5hbWU6IHN0cmluZywgbmFtZUhpbnQ/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGlkZW50aWZpZXIgPSB0aGlzLnQuaWRlbnRpZmllcignX19iYWJlbF9pbXBvcnRfdXRpbF9wbGFjZWhvbGRlcl9fJyk7XG4gICAgICAgIHN5bWJvbHMuc2V0KGlkZW50aWZpZXIsIHsgbW9kdWxlU3BlY2lmaWVyLCBleHBvcnRlZE5hbWUsIG5hbWVIaW50IH0pO1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZVJlZmVyZW5jZSA9IChwYXRoOiBOb2RlUGF0aCkgPT4ge1xuICAgICAgaWYgKCFwYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoaXQgPSBzeW1ib2xzLmdldChwYXRoLm5vZGUpO1xuICAgICAgaWYgKGhpdCkge1xuICAgICAgICBsZXQgbmV3SWRlbnRpZmllciA9IHRoaXMudW5yZWZlcmVuY2VkSW1wb3J0KFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgaGl0Lm1vZHVsZVNwZWNpZmllcixcbiAgICAgICAgICBoaXQuZXhwb3J0ZWROYW1lLFxuICAgICAgICAgIGRlc2lyZWROYW1lKGhpdC5uYW1lSGludCwgaGl0LmV4cG9ydGVkTmFtZSwgZGVmYXVsdE5hbWVIaW50KVxuICAgICAgICApO1xuICAgICAgICBwYXRoLnJlcGxhY2VXaXRoKG5ld0lkZW50aWZpZXIpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhuZXdJZGVudGlmaWVyLm5hbWUpO1xuICAgICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgICAvLyB3ZSBjcmVhdGUgdGhlIGJpbmRpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHdlIGFkZCB0aGUgaW1wb3J0LCBzbyB0aGlzXG4gICAgICAgICAgLy8gd291bGQgaW5kaWNhdGUgYnJva2VuIGJlaGF2aW9yXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBidWc6IHRoaXMgaXMgc3VwcG9zZWQgdG8gbmV2ZXIgaGFwcGVuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZy5yZWZlcmVuY2UocGF0aCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCByZXN1bHQgPSBmbihpbXBvcnRlcik7XG4gICAgdXBkYXRlUmVmZXJlbmNlKHJlc3VsdCk7XG4gICAgdGhpcy5iYWJlbC50cmF2ZXJzZShcbiAgICAgIHJlc3VsdC5ub2RlLFxuICAgICAge1xuICAgICAgICBSZWZlcmVuY2VkSWRlbnRpZmllcjogKHBhdGgpID0+IHtcbiAgICAgICAgICB1cGRhdGVSZWZlcmVuY2UocGF0aCk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcmVzdWx0LnNjb3BlLFxuICAgICAge30sXG4gICAgICByZXN1bHRcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGFkZFNwZWNpZmllcihcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG4gICAgZGVjbGFyYXRpb246IE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+LFxuICAgIGV4cG9ydGVkTmFtZTogc3RyaW5nLFxuICAgIHByZWZlcnJlZE5hbWU6IHN0cmluZ1xuICApOiB0LklkZW50aWZpZXIge1xuICAgIGxldCBsb2NhbCA9IHRoaXMudC5pZGVudGlmaWVyKHVudXNlZE5hbWVMaWtlKHRhcmdldCwgcHJlZmVycmVkTmFtZSkpO1xuICAgIGxldCBzcGVjaWZpZXIgPSB0aGlzLmJ1aWxkU3BlY2lmaWVyKGV4cG9ydGVkTmFtZSwgbG9jYWwpO1xuICAgIGxldCBhZGRlZDogTm9kZVBhdGg7XG4gICAgaWYgKHNwZWNpZmllci50eXBlID09PSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicpIHtcbiAgICAgIGRlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy51bnNoaWZ0KHNwZWNpZmllcik7XG4gICAgICBhZGRlZCA9IGRlY2xhcmF0aW9uLmdldChgc3BlY2lmaWVycy4wYCkgYXMgTm9kZVBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy5wdXNoKHNwZWNpZmllcik7XG4gICAgICBhZGRlZCA9IGRlY2xhcmF0aW9uLmdldChgc3BlY2lmaWVycy4ke2RlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy5sZW5ndGggLSAxfWApIGFzIE5vZGVQYXRoO1xuICAgIH1cbiAgICBkZWNsYXJhdGlvbi5zY29wZS5yZWdpc3RlckJpbmRpbmcoJ21vZHVsZScsIGFkZGVkKTtcbiAgICByZXR1cm4gbG9jYWw7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkU3BlY2lmaWVyKGV4cG9ydGVkTmFtZTogc3RyaW5nLCBsb2NhbE5hbWU6IHQuSWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAoZXhwb3J0ZWROYW1lKSB7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsTmFtZSk7XG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWxOYW1lKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnQuaW1wb3J0U3BlY2lmaWVyKGxvY2FsTmFtZSwgdGhpcy50LmlkZW50aWZpZXIoZXhwb3J0ZWROYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaW5kSW1wb3J0RnJvbShtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyk6IE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+IHwgdW5kZWZpbmVkIHtcbiAgICBmb3IgKGxldCBwYXRoIG9mIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHknKSkge1xuICAgICAgaWYgKFxuICAgICAgICBwYXRoLmlzSW1wb3J0RGVjbGFyYXRpb24oKSAmJlxuICAgICAgICBwYXRoLm5vZGUuc291cmNlLnZhbHVlID09PSBtb2R1bGVTcGVjaWZpZXIgJiZcbiAgICAgICAgcGF0aC5ub2RlLmltcG9ydEtpbmQgIT09ICd0eXBlJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnNlcnRBZnRlckV4aXN0aW5nSW1wb3J0czxTIGV4dGVuZHMgdC5TdGF0ZW1lbnQ+KHN0YXRlbWVudDogUyk6IE5vZGVQYXRoPFM+IHtcbiAgICBsZXQgbGFzdEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgW2luZGV4LCBub2RlXSBvZiB0aGlzLnByb2dyYW0ubm9kZS5ib2R5LmVudHJpZXMoKSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJykge1xuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCA9PSBudWxsKSB7XG4gICAgICAvLyB3ZSBhcmUgaW50ZW50aW9uYWxseSBub3QgdXNpbmcgYmFiZWwncyBjb250YWluZXItYXdhcmUgbWV0aG9kcywgYmVjYXVzZVxuICAgICAgLy8gd2hpbGUgaW4gdGhlb3J5IGl0J3MgbmljZSB0aGF0IHRoZXkgc2NoZWR1bGUgb3RoZXIgcGx1Z2lucyB0byBydW4gb25cbiAgICAgIC8vIG91ciBub2RlcywgaW4gcHJhY3RpY2UgdGhvc2Ugbm9kZXMgbWlnaHQgZ2V0IG11dGF0ZWQgb3IgcmVtb3ZlZCBieSBzb21lXG4gICAgICAvLyBvdGhlciBwbHVnaW4gaW4gdGhlIGludGVydmVuaW5nIHRpbWUgY2F1c2luZyBmYWlsdXJlcy5cbiAgICAgIHRoaXMucHJvZ3JhbS5ub2RlLmJvZHkudW5zaGlmdChzdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHkuMCcpIGFzIE5vZGVQYXRoPFM+O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2dyYW0ubm9kZS5ib2R5LnNwbGljZShsYXN0SW5kZXggKyAxLCAwLCBzdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbS5nZXQoYGJvZHkuJHtsYXN0SW5kZXggKyAxfWApIGFzIE5vZGVQYXRoPFM+O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bnVzZWROYW1lTGlrZShwYXRoOiBOb2RlUGF0aDx0Lk5vZGU+LCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgY2FuZGlkYXRlID0gbmFtZTtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICB3aGlsZSAocGF0aC5zY29wZS5oYXNCaW5kaW5nKGNhbmRpZGF0ZSkpIHtcbiAgICBjYW5kaWRhdGUgPSBgJHtuYW1lfSR7Y291bnRlcisrfWA7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn1cblxuZnVuY3Rpb24gbmFtZShub2RlOiB0LlN0cmluZ0xpdGVyYWwgfCB0LklkZW50aWZpZXIpOiBzdHJpbmcge1xuICBpZiAobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2lyZWROYW1lKFxuICBuYW1lSGludDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHBvcnRlZE5hbWU6IHN0cmluZyxcbiAgZGVmYXVsdE5hbWVIaW50OiBzdHJpbmcgfCB1bmRlZmluZWRcbikge1xuICBpZiAobmFtZUhpbnQpIHtcbiAgICAvLyBmaXJzdCB3ZSBvcHBvcnR1bmlzdGljYWxseSBkbyBjYW1lbGl6YXRpb24gd2hlbiBhbiBpbGxlZ2FsIGNoYXJhY3RlciBpc1xuICAgIC8vIGZvbGxvd2VkIGJ5IGEgbG93ZXJjYXNlIGxldHRlciwgaW4gYW4gZWZmb3J0IHRvIGFpZCByZWFkYWJpbGl0eSBvZiB0aGVcbiAgICAvLyBvdXRwdXQuXG4gICAgbGV0IGNsZWFuZWQgPSBuYW1lSGludC5yZXBsYWNlKC9bXmEtekEtWl9dKFthLXpdKS9nLCAoX20sIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpO1xuICAgIC8vIHRoZW4gd2UgdW5saXRlcmFsbHkgc3RyaXAgYWxsIHJlbWFpbmluZyBpbGxlZ2FsIGNoYXJhY3RlcnMuXG4gICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvW15hLXpBLVpfXS9nLCAnJyk7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgaWYgKGV4cG9ydGVkTmFtZSA9PT0gJ2RlZmF1bHQnIHx8IGV4cG9ydGVkTmFtZSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROYW1lSGludCA/PyAnYSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cG9ydGVkTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0TmFtZUhpbnQodGFyZ2V0OiBOb2RlUGF0aCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICh0YXJnZXQ/LmlzSWRlbnRpZmllcigpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5ub2RlLm5hbWU7XG4gIH0gZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXJCYXNlZE9uTm9kZSh0YXJnZXQubm9kZSkubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU3BlY2lmaWVyKHNwZWM6IE5vZGVQYXRoPGFueT4sIGV4cG9ydGVkTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHN3aXRjaCAoZXhwb3J0ZWROYW1lKSB7XG4gICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICByZXR1cm4gc3BlYy5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoKTtcbiAgICBjYXNlICcqJzpcbiAgICAgIHJldHVybiBzcGVjLmlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzcGVjLmlzSW1wb3J0U3BlY2lmaWVyKCkgJiYgbmFtZShzcGVjLm5vZGUuaW1wb3J0ZWQpID09PSBleHBvcnRlZE5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hNb2R1bGUoXG4gIHBhdGg6IE5vZGVQYXRoPGFueT4sXG4gIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nXG4pOiBwYXRoIGlzIE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+IHtcbiAgcmV0dXJuIHBhdGguaXNJbXBvcnREZWNsYXJhdGlvbigpICYmIHBhdGguZ2V0KCdzb3VyY2UnKS5ub2RlLnZhbHVlID09PSBtb2R1bGVTcGVjaWZpZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0ZXIge1xuICAvLyBJbXBvcnQgdGhlIGdpdmVuIHZhbHVlIChpZiBuZWVkZWQpIGFuZCByZXR1cm4gYW4gSWRlbnRpZmllciByZXByZXNlbnRpbmdcbiAgLy8gaXQuXG4gIGltcG9ydChcbiAgICAvLyB0aGUgcGF0aCB0byB0aGUgbW9kdWxlIHlvdSdyZSBpbXBvcnRpbmcgZnJvbVxuICAgIG1vZHVsZVNwZWNpZmllcjogc3RyaW5nLFxuXG4gICAgLy8gdGhlIG5hbWUgeW91J3JlIGltcG9ydGluZyBmcm9tIHRoYXQgbW9kdWxlLiBVc2UgXCJkZWZhdWx0XCIgZm9yIHRoZSBkZWZhdWx0XG4gICAgLy8gZXhwb3J0LiBVc2UgXCIqXCIgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgZXhwb3J0ZWROYW1lOiBzdHJpbmcsXG5cbiAgICAvLyBPcHRpb25hbCBoaW50IGZvciBoZWxwaW5nIHVzIHBpY2sgYSBuYW1lIGZvciB0aGUgaW1wb3J0ZWQgYmluZGluZ1xuICAgIG5hbWVIaW50Pzogc3RyaW5nXG4gICk6IHQuSWRlbnRpZmllcjtcbn1cbiJdfQ==","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.declare = declare;\nexports.declarePreset = void 0;\nconst apiPolyfills = {\n  assertVersion: api => range => {\n    throwVersionError(range, api.version);\n  }\n};\n{\n  Object.assign(apiPolyfills, {\n    targets: () => () => {\n      return {};\n    },\n    assumption: () => () => {\n      return undefined;\n    }\n  });\n}\nfunction declare(builder) {\n  return (api, options, dirname) => {\n    var _clonedApi2;\n    let clonedApi;\n    for (const name of Object.keys(apiPolyfills)) {\n      var _clonedApi;\n      if (api[name]) continue;\n      (_clonedApi = clonedApi) != null ? _clonedApi : clonedApi = copyApiObject(api);\n      clonedApi[name] = apiPolyfills[name](clonedApi);\n    }\n    return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);\n  };\n}\nconst declarePreset = declare;\nexports.declarePreset = declarePreset;\nfunction copyApiObject(api) {\n  let proto = null;\n  if (typeof api.version === \"string\" && /^7\\./.test(api.version)) {\n    proto = Object.getPrototypeOf(api);\n    if (proto && (!has(proto, \"version\") || !has(proto, \"transform\") || !has(proto, \"template\") || !has(proto, \"types\"))) {\n      proto = null;\n    }\n  }\n  return Object.assign({}, proto, api);\n}\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction throwVersionError(range, version) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n  const limit = Error.stackTraceLimit;\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n  let err;\n  if (version.slice(0, 2) === \"7.\") {\n    err = new Error(`Requires Babel \"^7.0.0-beta.41\", but was loaded with \"${version}\". ` + `You'll need to update your @babel/core version.`);\n  } else {\n    err = new Error(`Requires Babel \"${range}\", but was loaded with \"${version}\". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` + `to see what is calling Babel.`);\n  }\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version,\n    range\n  });\n}\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  let {\n    version\n  } = options;\n  {\n    const {\n      legacy\n    } = options;\n    if (legacy !== undefined) {\n      if (typeof legacy !== \"boolean\") {\n        throw new Error(\".legacy must be a boolean.\");\n      }\n      if (version !== undefined) {\n        throw new Error(\"You can either use the .legacy or the .version option, not both.\");\n      }\n    }\n    if (version === undefined) {\n      version = legacy ? \"legacy\" : \"2018-09\";\n    } else if (version !== \"2023-05\" && version !== \"2023-01\" && version !== \"2022-03\" && version !== \"2021-12\" && version !== \"2018-09\" && version !== \"legacy\") {\n      throw new Error(\"Unsupported decorators version: \" + version);\n    }\n    var {\n      decoratorsBeforeExport\n    } = options;\n    if (decoratorsBeforeExport === undefined) {\n      if (version === \"2021-12\" || version === \"2022-03\") {\n        decoratorsBeforeExport = false;\n      } else if (version === \"2018-09\") {\n        throw new Error(\"The decorators plugin, when .version is '2018-09' or not specified,\" + \" requires a 'decoratorsBeforeExport' option, whose value must be a boolean.\");\n      }\n    } else {\n      if (version === \"legacy\" || version === \"2022-03\" || version === \"2023-01\") {\n        throw new Error(`'decoratorsBeforeExport' can't be used with ${version} decorators.`);\n      }\n      if (typeof decoratorsBeforeExport !== \"boolean\") {\n        throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n      }\n    }\n  }\n  return {\n    name: \"syntax-decorators\",\n    manipulateOptions({\n      generatorOpts\n    }, parserOpts) {\n      if (version === \"legacy\") {\n        parserOpts.plugins.push(\"decorators-legacy\");\n      } else {\n        if (version === \"2023-01\" || version === \"2023-05\") {\n          parserOpts.plugins.push([\"decorators\", {\n            allowCallParenthesized: false\n          }], \"decoratorAutoAccessors\");\n        } else if (version === \"2022-03\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport: false,\n            allowCallParenthesized: false\n          }], \"decoratorAutoAccessors\");\n        } else if (version === \"2021-12\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport\n          }], \"decoratorAutoAccessors\");\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        } else if (version === \"2018-09\") {\n          parserOpts.plugins.push([\"decorators\", {\n            decoratorsBeforeExport\n          }]);\n          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n","import type * as Babel from '@babel/core';\nimport type { types as t, NodePath } from '@babel/core';\nimport { ImportUtil, type Importer } from 'babel-import-util';\nimport { globalId } from './global-id.ts';\n\n// TS can't find declarations for this package (there aren't any)\n// @ts-ignore\nimport decoratorSyntax from '@babel/plugin-syntax-decorators';\n\ninterface State extends Babel.PluginPass {\n  currentClassBodies: t.ClassBody[];\n  currentObjectExpressions: {\n    node: t.ObjectExpression;\n    decorated: [\n      'field' | 'method',\n      t.Expression, // for the property name\n      t.Expression[], // for the decorators applied to it\n    ][];\n  }[];\n  opts: Options;\n  runtime: (i: Importer, fnName: string) => t.Expression;\n  util: ImportUtil;\n  optsWithDefaults: Required<Options>;\n}\n\nexport interface Options {\n  runtime?: 'globals' | { import: string };\n  runEarly?: boolean;\n}\n\nfunction makeVisitor(babel: typeof Babel): Babel.Visitor<State> {\n  const t = babel.types;\n  return {\n    Program(path: NodePath<t.Program>, state: State) {\n      state.currentClassBodies = [];\n      state.currentObjectExpressions = [];\n      state.optsWithDefaults = {\n        runtime: 'globals',\n        runEarly: false,\n        ...state.opts,\n      };\n      state.util = new ImportUtil(babel, path);\n      state.runtime = (i: Importer, fnName: string) => {\n        const { runtime } = state.optsWithDefaults;\n        if (runtime === 'globals') {\n          return t.memberExpression(\n            t.identifier(globalId),\n            t.identifier(fnName),\n          );\n        } else {\n          return i.import(runtime.import, fnName);\n        }\n      };\n    },\n    ClassBody: {\n      enter(path, state) {\n        state.currentClassBodies.unshift(path.node);\n      },\n      exit(path, state) {\n        if (state.currentClassBodies[0] === path.node) {\n          state.currentClassBodies.shift();\n        }\n      },\n    },\n    ClassExpression(path, state) {\n      let decorators = path.get('decorators') as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        state.util.replaceWith(path, (i) => {\n          let call = t.callExpression(state.runtime(i, 'c'), [\n            path.node,\n            t.arrayExpression(\n              decorators\n                .slice()\n                .reverse()\n                .map((d) => d.node.expression),\n            ),\n          ]);\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n          return call;\n        });\n      }\n    },\n    ClassDeclaration(path, state) {\n      let decorators = path.get('decorators') as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        const buildCall = (i: Importer) => {\n          return t.callExpression(state.runtime(i, 'c'), [\n            t.classExpression(\n              path.node.id,\n              path.node.superClass,\n              path.node.body,\n              [], // decorators removed here\n            ),\n            t.arrayExpression(\n              decorators\n                .slice()\n                .reverse()\n                .map((d) => d.node.expression),\n            ),\n          ]);\n        };\n\n        if (path.parentPath.isExportDefaultDeclaration()) {\n          let id = path.node.id;\n          if (id) {\n            state.util.insertBefore(path.parentPath, (i) =>\n              t.variableDeclaration('const', [\n                t.variableDeclarator(id, buildCall(i)),\n              ]),\n            );\n            path.parentPath.replaceWith(t.exportDefaultDeclaration(id));\n          } else {\n            state.util.replaceWith(path.parentPath, (i) =>\n              t.exportDefaultDeclaration(buildCall(i)),\n            );\n          }\n        } else if (path.parentPath.isExportNamedDeclaration()) {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`,\n            );\n          }\n          state.util.insertBefore(path.parentPath, (i) =>\n            t.variableDeclaration('const', [\n              t.variableDeclarator(id, buildCall(i)),\n            ]),\n          );\n          path.parentPath.replaceWith(\n            t.exportNamedDeclaration(null, [t.exportSpecifier(id, id)]),\n          );\n        } else {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`,\n            );\n          }\n          state.util.replaceWith(path, (i) =>\n            t.variableDeclaration('const', [\n              t.variableDeclarator(id, buildCall(i)),\n            ]),\n          );\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      let decorators = path.get('decorators') as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype: t.Expression;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier('prototype'),\n          );\n        }\n        let args: t.Expression[] = [\n          prototype,\n          valueForFieldKey(t, path.node.key),\n          t.arrayExpression(\n            decorators\n              .slice()\n              .reverse()\n              .map((d) => d.node.expression),\n          ),\n        ];\n        if (path.node.value) {\n          args.push(\n            t.functionExpression(\n              null,\n              [],\n              t.blockStatement([t.returnStatement(path.node.value)]),\n            ),\n          );\n        }\n        state.util.insertBefore(path, (i) =>\n          t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, 'g'), args),\n            ),\n          ]),\n        );\n        state.util.insertBefore(path, (i) =>\n          t.classPrivateProperty(\n            t.privateName(\n              t.identifier(\n                unusedPrivateNameLike(state, propName(path.node.key)),\n              ),\n            ),\n            t.sequenceExpression([\n              t.callExpression(state.runtime(i, 'i'), [\n                t.thisExpression(),\n                valueForFieldKey(t, path.node.key),\n              ]),\n              t.identifier('void 0'),\n            ]),\n          ),\n        );\n        path.remove();\n      }\n    },\n    ClassMethod(path, state) {\n      let decorators = path.get('decorators') as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype: t.Expression;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier('prototype'),\n          );\n        }\n        state.util.insertAfter(path, (i) =>\n          t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, 'n'), [\n                prototype,\n                valueForFieldKey(t, path.node.key),\n                t.arrayExpression(\n                  decorators\n                    .slice()\n                    .reverse()\n                    .map((d) => d.node.expression),\n                ),\n              ]),\n            ),\n          ]),\n        );\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n    ObjectExpression: {\n      enter(path, state) {\n        state.currentObjectExpressions.unshift({\n          node: path.node,\n          decorated: [],\n        });\n      },\n      exit(path, state) {\n        if (state.currentObjectExpressions[0]?.node !== path.node) {\n          return;\n        }\n        let { decorated } = state.currentObjectExpressions.shift()!;\n        if (decorated.length > 0) {\n          state.util.replaceWith(path, (i) =>\n            t.callExpression(state.runtime(i, 'p'), [\n              path.node,\n              t.arrayExpression(\n                decorated.map(([type, prop, decorators]) =>\n                  t.arrayExpression([\n                    t.stringLiteral(type),\n                    prop,\n                    t.arrayExpression(decorators),\n                  ]),\n                ),\n              ),\n            ]),\n          );\n        }\n      },\n    },\n    ObjectProperty(path, state) {\n      let decorators = path.get('decorators') as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression`,\n          );\n        }\n        let prop = path.node.key;\n        if (prop.type === 'PrivateName') {\n          throw new Error(`cannot decorate private field`);\n        }\n        state.currentObjectExpressions[0].decorated.push([\n          'field',\n          valueForFieldKey(t, prop),\n          decorators\n            .slice()\n            .reverse()\n            .map((d) => d.node.expression),\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n\n    ObjectMethod(path, state) {\n      let decorators = path.get('decorators') as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression`,\n          );\n        }\n        let prop = path.node.key;\n        state.currentObjectExpressions[0].decorated.push([\n          'method',\n          valueForFieldKey(t, prop),\n          decorators\n            .slice()\n            .reverse()\n            .map((d) => d.node.expression),\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n  };\n}\n\nexport default function legacyDecoratorCompat(\n  babel: typeof Babel,\n): Babel.PluginObj<State> {\n  let visitor: Babel.Visitor<State> | undefined = makeVisitor(babel);\n  return {\n    inherits: (api: unknown, _options: unknown, dirname: unknown) =>\n      decoratorSyntax(api, { legacy: true }, dirname),\n    pre(this: State, file) {\n      if (this.opts.runEarly) {\n        babel.traverse(file.ast, makeVisitor(babel), file.scope, this);\n        visitor = undefined;\n      }\n    },\n    get visitor() {\n      return visitor ?? {};\n    },\n  };\n}\n\nfunction unusedPrivateNameLike(state: State, name: string): string {\n  let classBody = state.currentClassBodies[0];\n  if (!classBody) {\n    throw new Error(\n      `bug: no current class body around our class field decorator`,\n    );\n  }\n  let usedNames = new Set();\n  for (let element of classBody.body) {\n    if (\n      (element.type === 'ClassPrivateProperty' ||\n        element.type === 'ClassPrivateMethod' ||\n        element.type === 'ClassAccessorProperty') &&\n      element.key.type === 'PrivateName'\n    ) {\n      usedNames.add(element.key.id.name);\n    }\n  }\n  let candidate = name;\n  while (usedNames.has(candidate)) {\n    candidate = candidate + '_';\n  }\n  return candidate;\n}\n\n// derive a best-effort name we can use when creating a private-field\nfunction propName(expr: t.Expression): string {\n  if (expr.type === 'Identifier') {\n    return expr.name;\n  }\n  if (expr.type === 'BigIntLiteral' || expr.type === 'NumericLiteral') {\n    return `_${expr.value}`;\n  }\n  if (expr.type === 'StringLiteral') {\n    return '_' + expr.value.replace(/[^a-zA-Z]/g, '');\n  }\n  return '_';\n}\n\n// turn the field key into a runtime value. Identifiers are special because they\n// need to become string literals, anything else is already usable as a value.\nfunction valueForFieldKey(\n  t: (typeof Babel)['types'],\n  expr: t.Expression,\n): t.Expression {\n  if (expr.type === 'Identifier') {\n    return t.stringLiteral(expr.name);\n  }\n  return expr;\n}\n"],"names":["declaration","defaultNameHint","name","lib","require$$0","ImportUtil","decoratorSyntax"],"mappings":"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","x_google_ignoreList":[0,1,2]}