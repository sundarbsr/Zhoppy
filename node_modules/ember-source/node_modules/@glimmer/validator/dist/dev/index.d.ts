import { Tag, UpdatableTag, ConstantTag, MonomorphicTagId, TagTypeSymbol, TagComputeSymbol, DirtyableTag } from '@glimmer/interfaces';
export { CombinatorTag, ConstantTag, DirtyableTag, Tag, UpdatableTag } from '@glimmer/interfaces';

interface DebugTransaction {
    beginTrackingTransaction?: undefined | ((debuggingContext?: string | false, deprecate?: boolean) => void);
    endTrackingTransaction?: undefined | (() => void);
    runInTrackingTransaction?: undefined | (<T>(fn: () => T, debuggingContext?: string | false) => T);
    resetTrackingTransaction?: undefined | (() => string);
    setTrackingTransactionEnv?: undefined | ((env: {
        debugMessage?(obj?: unknown, keyName?: string): string;
    }) => void);
    assertTagNotConsumed?: undefined | (<T>(tag: Tag, obj?: T, keyName?: keyof T | string | symbol) => void);
    markTagAsConsumed?: undefined | ((_tag: Tag) => void);
    logTrackingStack?: undefined | ((transaction?: Transaction) => string);
}
declare const debug: DebugTransaction;
interface Transaction {
    parent: Transaction | null;
    debugLabel?: string | undefined;
}

type TagMeta = Map<PropertyKey, UpdatableTag>;
declare function dirtyTagFor<T extends object>(obj: T, key: keyof T | string | symbol, meta?: TagMeta): void;
declare function tagMetaFor(obj: object): TagMeta;
declare function tagFor<T extends object>(obj: T, key: keyof T | string | symbol, meta?: TagMeta): UpdatableTag | ConstantTag;

type Getter<T, K extends keyof T> = (self: T) => T[K] | undefined;
type Setter<T, K extends keyof T> = (self: T, value: T[K]) => void;
declare function trackedData<T extends object, K extends keyof T>(key: K, initializer?: (this: T) => T[K]): {
    getter: Getter<T, K>;
    setter: Setter<T, K>;
};

declare function beginTrackFrame(debuggingContext?: string | false): void;
declare function endTrackFrame(): Tag;
declare function beginUntrackFrame(): void;
declare function endUntrackFrame(): void;
declare function resetTracking(): string | void;
declare function isTracking(): boolean;
declare function consumeTag(tag: Tag): void;
declare const CACHE_KEY: unique symbol;
interface Cache<T = unknown> {
    [CACHE_KEY]: T;
}
declare function createCache<T>(fn: () => T, debuggingLabel?: string | false): Cache<T>;
declare function getValue<T>(cache: Cache<T>): T | undefined;
declare function isConst(cache: Cache): boolean;
declare function track(block: () => void, debugLabel?: string | false): Tag;
declare function untrack<T>(callback: () => T): T;

type Revision = number;
declare const CONSTANT: Revision;
declare const INITIAL: Revision;
declare const VOLATILE: Revision;
declare function bump(): void;
declare const COMPUTE: TagComputeSymbol;
/**
 * `value` receives a tag and returns an opaque Revision based on that tag. This
 * snapshot can then later be passed to `validate` with the same tag to
 * determine if the tag has changed at all since the time that `value` was
 * called.
 *
 * @param tag
 */
declare function valueForTag(tag: Tag): Revision;
/**
 * `validate` receives a tag and a snapshot from a previous call to `value` with
 * the same tag, and determines if the tag is still valid compared to the
 * snapshot. If the tag's state has changed at all since then, `validate` will
 * return false, otherwise it will return true. This is used to determine if a
 * calculation related to the tags should be rerun.
 *
 * @param tag
 * @param snapshot
 */
declare function validateTag(tag: Tag, snapshot: Revision): boolean;
declare const TYPE: TagTypeSymbol;
declare let ALLOW_CYCLES: WeakMap<Tag, boolean> | undefined;
declare class MonomorphicTagImpl<T extends MonomorphicTagId = MonomorphicTagId> {
    static combine(this: void, tags: Tag[]): Tag;
    private revision;
    private lastChecked;
    private lastValue;
    private isUpdating;
    subtag: Tag | Tag[] | null;
    private subtagBufferCache;
    [TYPE]: T;
    constructor(type: T);
    [COMPUTE](): Revision;
    static updateTag(this: void, _tag: UpdatableTag, _subtag: Tag): void;
    static dirtyTag(this: void, tag: DirtyableTag | UpdatableTag, disableConsumptionAssertion?: boolean): void;
}
declare const DIRTY_TAG: typeof MonomorphicTagImpl.dirtyTag;
declare const UPDATE_TAG: typeof MonomorphicTagImpl.updateTag;
declare function createTag(): DirtyableTag;
declare function createUpdatableTag(): UpdatableTag;
declare const CONSTANT_TAG: ConstantTag;
declare function isConstTag(tag: Tag): tag is ConstantTag;
declare class VolatileTag implements Tag {
    readonly [TYPE]: 100;
    [COMPUTE](): Revision;
}
declare const VOLATILE_TAG: VolatileTag;
declare class CurrentTag implements Tag {
    readonly [TYPE]: 101;
    [COMPUTE](): Revision;
}
declare const CURRENT_TAG: CurrentTag;
declare const combine: typeof MonomorphicTagImpl.combine;

export { ALLOW_CYCLES, COMPUTE, CONSTANT, CONSTANT_TAG, CURRENT_TAG, type Cache, CurrentTag, INITIAL, type Revision, type TagMeta, VOLATILE, VOLATILE_TAG, VolatileTag, beginTrackFrame, beginUntrackFrame, bump, combine, consumeTag, createCache, createTag, createUpdatableTag, debug, DIRTY_TAG as dirtyTag, dirtyTagFor, endTrackFrame, endUntrackFrame, getValue, isConst, isConstTag, isTracking, resetTracking, tagFor, tagMetaFor, track, trackedData, untrack, UPDATE_TAG as updateTag, validateTag, valueForTag };
