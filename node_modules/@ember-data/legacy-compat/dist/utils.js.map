{"version":3,"file":"utils.js","sources":["../src/utils.ts"],"sourcesContent":["/**\n  Utilities for helping to migrate to stricter\n  and more consistent use of IDs and types.\n\n  @module @ember-data/legacy-compat/utils\n  @main @ember-data/legacy-compat/utils\n  @deprecated\n*/\nimport { dasherize, singularize } from '@ember-data/request-utils/string';\nimport { assert } from '@warp-drive/build-config/macros';\n\ninterface AssertFunc {\n  (desc: string, condition: unknown): asserts condition;\n  (desc: string): never;\n}\n\ntype Reporter = (type: 'formatted-id' | 'formatted-type', actual: unknown, expected: unknown) => void;\ntype Normalizer = (type: string) => string;\n\nlet MismatchReporter: Reporter = function () {};\n\n// TODO: @runspired This pattern prevents AssertFn from being removed in production builds\n// but we should enable that if we can.\nlet _AssertFn: (message: string, condition: unknown) => void = function () {};\nconst AssertFn: AssertFunc = ((message: string, condition: unknown) => {\n  if (!condition) {\n    _AssertFn(message, condition);\n  }\n  assert(message, condition);\n}) as unknown as AssertFunc;\nlet NormalizedType: Normalizer = (str: string) => {\n  return singularize(dasherize(str));\n};\n\n/**\n * Configure a function to be called when an id or type\n * changes during normalization. This is useful for instrumenting\n * to discover places where usage in the app is not consistent.\n *\n * @method configureMismatchReporter\n * @for @ember-data/legacy-compat/utils\n * @param method a function which takes a mismatch-type ('formatted-id' | 'formatted-type'), actual, and expected value\n * @public\n * @static\n */\nexport function configureMismatchReporter(fn: Reporter): void {\n  MismatchReporter = fn;\n}\n\n/**\n * Configure a function to be called when an id or type\n * fails validation. This is useful for instrumenting\n * to discover places where usage in the app is not consistent.\n *\n * @method configureAssertFn\n * @for @ember-data/legacy-compat/utils\n * @param method a function which takes a message and a condition\n * @public\n * @static\n */\nexport function configureAssertFn(fn: (message: string, condition: unknown) => void): void {\n  _AssertFn = fn;\n}\n\n/**\n * Configure a function to be called to normalize\n * a resource type string. Used by both formattedType\n * and isEquivType to ensure consistent normalization\n * during comparison.\n *\n * If validation fails or the type turns out be unnormalized\n * the configured mismatch reporter and assert functions will\n * be called.\n *\n * @method configureTypeNormalization\n * @for @ember-data/legacy-compat/utils\n * @param method a function which takes a string and returns a string\n * @public\n * @static\n */\nexport function configureTypeNormalization(fn: (type: string) => string): void {\n  NormalizedType = fn;\n}\n\nconst NORMALIZED_TYPES = new Map<string, string>();\n\n/**\n * Converts a potentially unnormalized type into the format expected\n * by our EmberData Cache. Currently this is singular-dasherized.\n *\n * you should not rely on this function to give you an exact format\n * for display purposes. Formatting for display should be handled\n * differently if the exact format matters.\n *\n * Asserts invalid types (undefined, null, '') in dev.\n *\n * **Usage**\n *\n * ```js\n * import formattedType from 'soxhub-client/helpers/formatted-type';\n *\n * formattedType('post'); // => 'post'\n * formattedType('posts'); // => 'post'\n * formattedType('Posts'); // => 'post'\n * formattedType('post-comment'); // => 'post-comment'\n * formattedType('post-comments'); // => 'post-comment'\n * formattedType('post_comment'); // => 'post-comment'\n * formattedType('postComment'); // => 'post-comment'\n * formattedType('PostComment'); // => 'post-comment'\n * ```\n *\n * @method formattedType\n * @for @ember-data/legacy-compat/utils\n * @param {string} type the potentially un-normalized type\n * @return {string} the normalized type\n * @public\n * @static\n */\nexport function formattedType<T extends string>(type: T | string): T {\n  AssertFn('formattedType: type must not be null', type !== null);\n  AssertFn('formattedType: type must not be undefined', type !== undefined);\n  AssertFn('formattedType: type must be a string', typeof type === 'string');\n  AssertFn('formattedType: type must not be empty', type.length > 0);\n  let normalized = NORMALIZED_TYPES.get(type);\n\n  if (normalized === undefined) {\n    normalized = NormalizedType(type);\n    NORMALIZED_TYPES.set(type, normalized);\n  }\n\n  if (normalized !== type) {\n    MismatchReporter('formatted-type', type, normalized);\n  }\n\n  return normalized as T;\n}\n\n/**\n * Format an id to the format expected by the EmberData Cache.\n * Currently this means that id should be `string | null`.\n *\n * Asserts invalid IDs (undefined, '', 0, '0') in dev.\n *\n * **Usage**\n *\n * ```js\n * import formattedId from 'client/utils/formatted-id';\n *\n * formattedId('1'); // => '1'\n * formattedId(1); // => '1'\n * formattedId(null); // => null\n *\t```\n *\n * @method formattedId\n * @for @ember-data/legacy-compat/utils\n * @param {string | number | null} id the potentially un-normalized id\n * @return {string | null} the normalized id\n * @public\n * @static\n */\nexport function formattedId(id: string | number): string;\nexport function formattedId(id: null): null;\nexport function formattedId(id: string | number | null): string | null;\nexport function formattedId(id: string | number | null): string | null {\n  AssertFn('formattedId: id must not be undefined', id !== undefined);\n  AssertFn(\n    'formattedId: id must be a number, string or null',\n    typeof id === 'number' || typeof id === 'string' || id === null\n  );\n  AssertFn(\n    'formattedId: id must not be empty',\n    typeof id === 'number' || id === null || (typeof id === 'string' && id.length > 0)\n  );\n  AssertFn('formattedId: id must not be 0', id !== '0' && id !== 0);\n\n  const formatted = id === null ? null : String(id);\n  if (formatted !== id) {\n    MismatchReporter('formatted-id', id, formatted);\n  }\n  return id === null ? null : String(id);\n}\n\nexport function expectId(id: string | number): string;\nexport function expectId(id: null): never;\nexport function expectId(id: string | number | null): string {\n  AssertFn('expectId: id must not be null', id !== null);\n\n  return formattedId(id);\n}\n\n/**\n * Compares two types for strict equality, converting them to\n * the format expected by the EmberData Cache to ensure\n * differences in format are accounted for in the comparison.\n *\n * Asserts when expected or actual are invalid types in dev.\n * Expected may never be null.\n *\n * ```js\n * isEquivType('posts', 'post'); // true\n * isEquivType('post', 'post'); // true\n * isEquivType('posts', 'posts'); // true\n * isEquivType('post-comment', 'postComment'); // true\n * isEquivType('post-comment', 'PostComment'); // true\n * isEquivType('post-comment', 'post_comment'); // true\n * isEquivType('post-comment', 'post-comment'); // true\n * isEquivType('post-comment', 'post'); // false\n * isEquivType('posts', null); // false\n * ```\n *\n * @method isEquivType\n * @for @ember-data/legacy-compat/utils\n * @param {string} expected a potentially unnormalized type to match against\n * @param {string} actual a potentially unnormalized type to match against\n * @return {boolean} true if the types are equivalent\n * @public\n * @static\n */\nexport function isEquivType(expected: string, actual: string): boolean {\n  AssertFn('isEquivType: Expected type must not be null', expected !== null);\n  AssertFn('isEquivType: Expected type must not be undefined', expected !== undefined);\n  AssertFn('isEquivType: Expected type must be a string', typeof expected === 'string');\n  AssertFn('isEquivType: Expected type must not be empty', expected.length > 0);\n\n  AssertFn('isEquivType: Actual type must not be null', actual !== null);\n  AssertFn('isEquivType: Actual type must not be undefined', actual !== undefined);\n  AssertFn('isEquivType: Actual type must be a string', typeof actual === 'string');\n  AssertFn('isEquivType: Actual type must not be empty', actual.length > 0);\n\n  return expected === actual || formattedType(expected) === formattedType(actual);\n}\n\n/**\n * Compares two IDs for strict equality, converting them to\n * the format expected by the EmberData Cache to ensure\n * differences in format are accounted for in the comparison.\n *\n * Asserts when expected or actual are invalid IDs in dev.\n * Expected may never be null.\n *\n * ```js\n * isEquivId('1', 1); // true\n * isEquivId('2', '2'); // true\n * isEquivId(3, '3'); // true\n * isEquivId(4, '3'); // false\n * isEquivId(1, null); // false\n * ```\n *\n * @method isEquivId\n * @for @ember-data/legacy-compat/utils\n * @param {string | number} expected a potentially un-normalized id to match against\n * @param {string | number} actual a potentially un-normalized id to match against\n * @return {boolean} true if the ids are equivalent\n * @public\n * @static\n */\nexport function isEquivId(expected: string | number, actual: string | number | null): boolean {\n  AssertFn('isEquivId: Expected id must not be null', expected !== null);\n  AssertFn('isEquivId: Expected id must not be undefined', expected !== undefined);\n  AssertFn(\n    'isEquivId: Expected id must be a number or string',\n    typeof expected === 'number' || typeof expected === 'string'\n  );\n  AssertFn(\n    'isEquivId: Expected id must not be empty',\n    typeof expected === 'number' || (typeof expected === 'string' && expected.length > 0)\n  );\n  AssertFn('isEquivId: Expected id must not be 0', expected !== '0' && expected !== 0);\n\n  AssertFn('isEquivId: Actual id must not be undefined', actual !== undefined);\n  AssertFn(\n    'isEquivId: Actual id must be a number, string or null',\n    typeof actual === 'number' || typeof actual === 'string' || actual === null\n  );\n  AssertFn(\n    'isEquivId: Actual id must not be empty',\n    actual === null || typeof actual === 'number' || (typeof actual === 'string' && actual.length > 0)\n  );\n  AssertFn('isEquivId: Actual id must not be 0', actual !== '0' && actual !== 0);\n\n  return expected === actual || formattedId(expected) === formattedId(actual);\n}\n"],"names":["MismatchReporter","_AssertFn","AssertFn","message","condition","macroCondition","getGlobalConfig","WarpDrive","env","DEBUG","test","Error","NormalizedType","str","singularize","dasherize","configureMismatchReporter","fn","configureAssertFn","configureTypeNormalization","NORMALIZED_TYPES","Map","formattedType","type","undefined","length","normalized","get","set","formattedId","id","formatted","String","expectId","isEquivType","expected","actual","isEquivId"],"mappings":"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"}