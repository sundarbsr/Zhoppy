declare module '@ember-data/legacy-compat/legacy-network-handler/fetch-manager' {
  import { createDeferred } from '@ember-data/request';
  import type Store from '@ember-data/store';
  import type { Request, RequestStateService } from '@ember-data/store/-private';
  import type { FindRecordOptions } from '@ember-data/store/types';
  import type { StableExistingRecordIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';
  import type { TypeFromInstance } from '@warp-drive/core-types/record';
  import type { ImmutableRequestInfo } from '@warp-drive/core-types/request';
  import type { SingleResourceDocument } from '@warp-drive/core-types/spec/json-api-raw';
  import { Snapshot } from '@ember-data/legacy-compat/legacy-network-handler/snapshot';
  type Deferred<T> = ReturnType<typeof createDeferred<T>>;
  export const SaveOp: "___(unique) Symbol(SaveOp)";
  export type FetchMutationOptions = FindRecordOptions & {
      [SaveOp]: 'createRecord' | 'deleteRecord' | 'updateRecord';
  };
  interface PendingFetchItem {
      identifier: StableExistingRecordIdentifier;
      queryRequest: Request;
      resolver: Deferred<any>;
      options: FindRecordOptions;
      trace?: unknown;
      promise: Promise<StableExistingRecordIdentifier>;
  }
  export class FetchManager {
      isDestroyed: boolean;
      requestCache: RequestStateService;
      _pendingFetch: Map<string, Map<StableExistingRecordIdentifier, PendingFetchItem[]>>;
      _store: Store;
      constructor(store: Store);
      createSnapshot<T>(identifier: StableRecordIdentifier<TypeFromInstance<T>>, options?: FindRecordOptions): Snapshot<T>;
      createSnapshot(identifier: StableRecordIdentifier, options?: FindRecordOptions): Snapshot;
      /**
        This method is called by `record.save`, and gets passed a
        resolver for the promise that `record.save` returns.
    
        It schedules saving to happen at the end of the run loop.
    
        @internal
      */
      scheduleSave(identifier: StableRecordIdentifier, options: FetchMutationOptions): Promise<null | SingleResourceDocument>;
      scheduleFetch(identifier: StableExistingRecordIdentifier, options: FindRecordOptions, request: ImmutableRequestInfo): Promise<StableExistingRecordIdentifier>;
      getPendingFetch(identifier: StableExistingRecordIdentifier, options: FindRecordOptions): Promise<StableExistingRecordIdentifier<string>> | undefined;
      flushAllPendingFetches(): void;
      fetchDataIfNeededForIdentifier(identifier: StableExistingRecordIdentifier, options: FindRecordOptions | undefined, request: ImmutableRequestInfo): Promise<StableExistingRecordIdentifier>;
      destroy(): void;
  }
  export {};
}
//# sourceMappingURL=fetch-manager.d.ts.map