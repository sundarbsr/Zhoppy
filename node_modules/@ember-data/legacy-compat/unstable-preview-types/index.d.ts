/// <reference path="./-private.d.ts" />
/// <reference path="./utils.d.ts" />
/// <reference path="./builders.d.ts" />
/// <reference path="./legacy-network-handler/snapshot.d.ts" />
/// <reference path="./legacy-network-handler/minimum-serializer-interface.d.ts" />
/// <reference path="./legacy-network-handler/legacy-data-utils.d.ts" />
/// <reference path="./legacy-network-handler/legacy-data-fetch.d.ts" />
/// <reference path="./legacy-network-handler/fetch-manager.d.ts" />
/// <reference path="./legacy-network-handler/minimum-adapter-interface.d.ts" />
/// <reference path="./legacy-network-handler/serializer-response.d.ts" />
/// <reference path="./legacy-network-handler/identifier-has-id.d.ts" />
/// <reference path="./legacy-network-handler/legacy-network-handler.d.ts" />
/// <reference path="./legacy-network-handler/snapshot-record-array.d.ts" />
/// <reference path="./builders/query.d.ts" />
/// <reference path="./builders/utils.d.ts" />
/// <reference path="./builders/save-record.d.ts" />
/// <reference path="./builders/find-record.d.ts" />
/// <reference path="./builders/find-all.d.ts" />
declare module '@ember-data/legacy-compat' {
  import type Store from '@ember-data/store';
  import type { ObjectValue } from '@warp-drive/core-types/json/raw';
  import { FetchManager } from '@ember-data/legacy-compat/-private';
  import type { AdapterPayload, MinimumAdapterInterface } from '@ember-data/legacy-compat/legacy-network-handler/minimum-adapter-interface';
  import type { MinimumSerializerInterface, SerializerOptions } from '@ember-data/legacy-compat/legacy-network-handler/minimum-serializer-interface';
  export { LegacyNetworkHandler } from '@ember-data/legacy-compat/legacy-network-handler/legacy-network-handler';
  export type { MinimumAdapterInterface, MinimumSerializerInterface, SerializerOptions, AdapterPayload };
  /**
   * @module @ember-data/store
   * @class Store
   */
  export type LegacyStoreCompat = {
      _fetchManager: FetchManager;
      adapterFor(this: Store, modelName: string): MinimumAdapterInterface;
      adapterFor(this: Store, modelName: string, _allowMissing: true): MinimumAdapterInterface | undefined;
      serializerFor<K extends string>(modelName: K, _allowMissing?: boolean): MinimumSerializerInterface | null;
      normalize(modelName: string, payload: ObjectValue): ObjectValue;
      pushPayload(modelName: string, payload: ObjectValue): void;
      serializeRecord(record: unknown, options?: SerializerOptions): unknown;
      _adapterCache: Record<string, MinimumAdapterInterface & {
          store: Store;
      }>;
      _serializerCache: Record<string, MinimumSerializerInterface & {
          store: Store;
      }>;
  };
  export type CompatStore = Store & LegacyStoreCompat;
  /**
      Returns an instance of the adapter for a given type. For
      example, `adapterFor('person')` will return an instance of
      the adapter located at `app/adapters/person.js`
  
      If no `person` adapter is found, this method will look
      for an `application` adapter (the default adapter for
      your entire application).
  
      @method adapterFor
      @public
      @param {String} modelName
      @return Adapter
    */
  export function adapterFor(this: Store, modelName: string): MinimumAdapterInterface;
  export function adapterFor(this: Store, modelName: string, _allowMissing: true): MinimumAdapterInterface | undefined;
  /**
      Returns an instance of the serializer for a given type. For
      example, `serializerFor('person')` will return an instance of
      `App.PersonSerializer`.
  
      If no `App.PersonSerializer` is found, this method will look
      for an `App.ApplicationSerializer` (the default serializer for
      your entire application).
  
      If a serializer cannot be found on the adapter, it will fall back
      to an instance of `JSONSerializer`.
  
      @method serializerFor
      @public
      @param {String} modelName the record to serialize
      @return {Serializer}
    */
  export function serializerFor(this: Store, modelName: string): MinimumSerializerInterface | null;
  /**
      `normalize` converts a json payload into the normalized form that
      [push](../methods/push?anchor=push) expects.
  
      Example
  
      ```js
      socket.on('message', function(message) {
        let modelName = message.model;
        let data = message.data;
        store.push(store.normalize(modelName, data));
      });
      ```
  
      @method normalize
      @public
      @param {String} modelName The name of the model type for this payload
      @param {Object} payload
      @return {Object} The normalized payload
    */
  export function normalize(this: Store, modelName: string, payload: ObjectValue): import("@warp-drive/core-types/spec/json-api-raw").SingleResourceDocument;
  /**
      Push some raw data into the store.
  
      This method can be used both to push in brand new
      records, as well as to update existing records. You
      can push in more than one type of object at once.
      All objects should be in the format expected by the
      serializer.
  
      ```app/serializers/application.js
      import RESTSerializer from '@ember-data/serializer/rest';
  
      export default class ApplicationSerializer extends RESTSerializer;
      ```
  
      ```js
      let pushData = {
        posts: [
          { id: 1, postTitle: "Great post", commentIds: [2] }
        ],
        comments: [
          { id: 2, commentBody: "Insightful comment" }
        ]
      }
  
      store.pushPayload(pushData);
      ```
  
      By default, the data will be deserialized using a default
      serializer (the application serializer if it exists).
  
      Alternatively, `pushPayload` will accept a model type which
      will determine which serializer will process the payload.
  
      ```app/serializers/application.js
      import RESTSerializer from '@ember-data/serializer/rest';
  
       export default class ApplicationSerializer extends RESTSerializer;
      ```
  
      ```app/serializers/post.js
      import JSONSerializer from '@ember-data/serializer/json';
  
      export default JSONSerializer;
      ```
  
      ```js
      store.pushPayload(pushData); // Will use the application serializer
      store.pushPayload('post', pushData); // Will use the post serializer
      ```
  
      @method pushPayload
      @public
      @param {String} modelName Optionally, a model type used to determine which serializer will be used
      @param {Object} inputPayload
    */
  export function pushPayload(this: Store, modelName: string, inputPayload: ObjectValue): void;
  export function serializeRecord(this: Store, record: unknown, options?: SerializerOptions): unknown;
  export function cleanup(this: Store): void;
}
//# sourceMappingURL=index.d.ts.map