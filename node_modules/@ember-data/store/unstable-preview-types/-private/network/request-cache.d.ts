declare module '@ember-data/store/-private/network/request-cache' {
  import type { StableRecordIdentifier } from '@warp-drive/core-types/identifier';
  import type { FindRecordOptions } from '@ember-data/store/-types/q/store';
  import type { Store } from '@ember-data/store/-private/store-service';
  const Touching: "___(unique) Symbol(Touching)";
  export const RequestPromise: "___(unique) Symbol(RequestPromise)";
  export interface Operation {
      op: string;
      options: FindRecordOptions | undefined;
      recordIdentifier: StableRecordIdentifier;
  }
  export interface FindRecordQuery extends Operation {
      op: 'findRecord';
  }
  export interface SaveRecordMutation extends Operation {
      op: 'saveRecord';
  }
  export interface Request {
      data: Operation[];
      options?: Record<string, unknown>;
  }
  export type RequestStates = 'pending' | 'fulfilled' | 'rejected';
  export interface RequestState {
      state: RequestStates;
      type: 'query' | 'mutation';
      request: Request;
      response?: Response;
  }
  export interface Response {
      data: unknown;
  }
  interface InternalRequest extends RequestState {
      [Touching]: StableRecordIdentifier[];
      [RequestPromise]?: Promise<unknown>;
  }
  export type RequestSubscription = (requestState: RequestState) => void;
  /**
   * The RequestStateService is used to track the state of requests
   * for fetching or updating known resource identifies that are inflight.
   *
   * @class RequestStateService
   * @public
   */
  export class RequestStateService {
      _pending: Map<StableRecordIdentifier, InternalRequest[]>;
      _done: Map<StableRecordIdentifier, InternalRequest[]>;
      _subscriptions: Map<StableRecordIdentifier, RequestSubscription[]>;
      _toFlush: InternalRequest[];
      _store: Store;
      constructor(store: Store);
      _clearEntries(identifier: StableRecordIdentifier): void;
      _enqueue<T>(promise: Promise<T>, queryRequest: Request): Promise<T>;
      _triggerSubscriptions(req: InternalRequest): void;
      _flush(): void;
      _flushRequest(req: InternalRequest): void;
      _dequeue(identifier: StableRecordIdentifier, request: InternalRequest): void;
      _addDone(request: InternalRequest): void;
      /**
       * Subscribe to requests for a given resource identity.
       *
       * The callback will receive the current state of the request.
       *
       * ```ts
       * interface RequestState {
       *   state: 'pending' | 'fulfilled' | 'rejected';
       *   type: 'query' | 'mutation';
       *   request: Request;
       *   response?: { data: unknown };
       * }
       * ```
       *
       * Note: It should be considered dangerous to use this API for more than simple
       * state derivation or debugging. The `request` and `response` properties are poorly
       * spec'd and may change unexpectedly when shifting what Handlers are in use or how
       * requests are issued from the Store.
       *
       * We expect to revisit this API in the near future as we continue to refine the
       * RequestManager ergonomics, as a simpler but more powerful direct integration
       * with the RequestManager for these purposes is likely to be a better long-term
       * design.
       *
       * @method subscribeForRecord
       * @public
       * @param {StableRecordIdentifier} identifier
       * @param {(state: RequestState) => void} callback
       */
      subscribeForRecord(identifier: StableRecordIdentifier, callback: RequestSubscription): void;
      /**
       * Retrieve all active requests for a given resource identity.
       *
       * @method getPendingRequestsForRecord
       * @public
       * @param {StableRecordIdentifier} identifier
       * @return {RequestState[]} an array of request states for any pending requests for the given identifier
       */
      getPendingRequestsForRecord(identifier: StableRecordIdentifier): RequestState[];
      /**
       * Retrieve the last completed request for a given resource identity.
       *
       * @method getLastRequestForRecord
       * @public
       * @param {StableRecordIdentifier} identifier
       * @return {RequestState | null} the state of the most recent request for the given identifier
       */
      getLastRequestForRecord(identifier: StableRecordIdentifier): RequestState | null;
  }
  export {};
}
//# sourceMappingURL=request-cache.d.ts.map