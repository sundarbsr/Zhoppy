declare module '@ember-data/store/-private/cache-handler/handler' {
  /**
   * @module @ember-data/store
   */
  import type { CacheHandler as CacheHandlerType } from '@ember-data/request';
  import type { ImmutableRequestInfo, RequestContext } from '@warp-drive/core-types/request';
  import type { ResourceIdentifierObject } from '@warp-drive/core-types/spec/json-api-raw';
  import type { Store } from '@ember-data/store/-private/store-service';
  export type LooseStoreRequestInfo<T = unknown, RT = unknown> = Omit<ImmutableRequestInfo<T, RT>, 'records' | 'headers'> & {
      records?: ResourceIdentifierObject[];
      headers?: Headers;
  };
  export type StoreRequestInput<T = unknown, RT = unknown> = ImmutableRequestInfo<T, RT> | LooseStoreRequestInfo<T, RT>;
  export interface StoreRequestContext extends RequestContext {
      request: ImmutableRequestInfo & {
          store: Store;
      };
  }
  /**
   * A CacheHandler that adds support for using an EmberData Cache with a RequestManager.
   *
   * This handler will only run when a request has supplied a `store` instance. Requests
   * issued by the store via `store.request()` will automatically have the `store` instance
   * attached to the request.
   *
   * ```ts
   * requestManager.request({
   *   store: store,
   *   url: '/api/posts',
   *   method: 'GET'
   * });
   * ```
   *
   * When this handler elects to handle a request, it will return the raw `StructuredDocument`
   * unless the request has `[EnableHydration]` set to `true`. In this case, the handler will
   * return a `Document` instance that will automatically update the UI when the cache is updated
   * in the future and will hydrate any identifiers in the StructuredDocument into Record instances.
   *
   * When issuing a request via the store, [EnableHydration] is automatically set to `true`. This
   * means that if desired you can issue requests that utilize the cache without needing to also
   * utilize Record instances if desired.
   *
   * Said differently, you could elect to issue all requests via a RequestManager, without ever using
   * the store directly, by setting [EnableHydration] to `true` and providing a store instance. Not
   * necessarily the most useful thing, but the decoupled nature of the RequestManager and incremental-feature
   * approach of EmberData allows for this flexibility.
   *
   * ```ts
   * import { EnableHydration } from '@warp-drive/core-types/request';
   *
   * requestManager.request({
   *   store: store,
   *   url: '/api/posts',
   *   method: 'GET',
   *   [EnableHydration]: true
   * });
   *
   * @typedoc
   */
  export const CacheHandler: CacheHandlerType;
}
//# sourceMappingURL=handler.d.ts.map