declare module '@ember-data/adapter/rest' {
  import type { AdapterPayload } from '@ember-data/legacy-compat';
  import type { Snapshot, SnapshotRecordArray } from '@ember-data/legacy-compat/-private';
  import type Store from '@ember-data/store';
  import type { ModelSchema } from '@ember-data/store/types';
  import type { HTTPMethod } from '@warp-drive/core-types/request';
  import type { MixtBuildURLMixin } from '@ember-data/adapter/-private/build-url-mixin';
  import type { FastBoot } from '@ember-data/adapter/-private/fastboot-interface';
  import AdapterError from '@ember-data/adapter/error';
  import Adapter from '@ember-data/adapter/index';
  type Payload = Error | Record<string, unknown> | unknown[] | string | undefined;
  export type QueryState = {
      include?: unknown;
      since?: unknown;
  };
  export interface FetchRequestInit extends RequestInit {
      url: string;
      method: HTTPMethod;
      type: HTTPMethod;
  }
  export interface JQueryRequestInit extends JQueryAjaxSettings {
      url: string;
      method: HTTPMethod;
      type: HTTPMethod;
  }
  export type RequestData = {
      url: string;
      method: HTTPMethod;
      [key: string]: unknown;
  };
  const RESTAdapter_base: Readonly<typeof Adapter> & (new (owner?: import("@ember/-internals/owner").default) => Adapter) & import("@ember/object/mixin").default;
  /**
   * <blockquote style="margin: 1em; padding: .1em 1em .1em 1em; border-left: solid 1em #E34C32; background: #e0e0e0;">
    <p>
      ⚠️ <strong>This is LEGACY documentation</strong> for a feature that is no longer encouraged to be used.
      If starting a new app or thinking of implementing a new adapter, consider writing a
      <a href="/ember-data/release/classes/%3CInterface%3E%20Handler">Handler</a> instead to be used with the <a href="https://github.com/emberjs/data/tree/main/packages/request#readme">RequestManager</a>
    </p>
    </blockquote>
  
    The REST adapter allows your store to communicate with an HTTP server by
    transmitting JSON via XHR.
  
    This adapter is designed around the idea that the JSON exchanged with
    the server should be conventional. It builds URLs in a manner that follows
    the structure of most common REST-style web services.
  
    ## Success and failure
  
    The REST adapter will consider a success any response with a status code
    of the 2xx family ("Success"), as well as 304 ("Not Modified"). Any other
    status code will be considered a failure.
  
    On success, the request promise will be resolved with the full response
    payload.
  
    Failed responses with status code 422 ("Unprocessable Entity") will be
    considered "invalid". The response will be discarded, except for the
    `errors` key. The request promise will be rejected with a `InvalidError`.
    This error object will encapsulate the saved `errors` value.
  
    Any other status codes will be treated as an "adapter error". The request
    promise will be rejected, similarly to the "invalid" case, but with
    an instance of `AdapterError` instead.
  
    ## JSON Structure
  
    The REST adapter expects the JSON returned from your server to follow
    these conventions.
  
    ### Object Root
  
    The JSON payload should be an object that contains the record inside a
    root property. For example, in response to a `GET` request for
    `/posts/1`, the JSON should look like this:
  
    ```js
    {
      "posts": {
        "id": 1,
        "title": "I'm Running to Reform the W3C",
        "author": "Yehuda Katz"
      }
    }
    ```
  
    Similarly, in response to a `GET` request for `/posts`, the JSON should
    look like this:
  
    ```js
    {
      "posts": [
        {
          "id": 1,
          "title": "I'm Running to Reform the W3C",
          "author": "Yehuda Katz"
        },
        {
          "id": 2,
          "title": "Rails is omakase",
          "author": "D2H"
        }
      ]
    }
    ```
  
    Note that the object root can be pluralized for both a single-object response
    and an array response: the REST adapter is not strict on this. Further, if the
    HTTP server responds to a `GET` request to `/posts/1` (e.g. the response to a
    `findRecord` query) with more than one object in the array, Ember Data will
    only display the object with the matching ID.
  
    ### Conventional Names
  
    Attribute names in your JSON payload should be the camelCased versions of
    the attributes in your Ember.js models.
  
    For example, if you have a `Person` model:
  
    ```app/models/person.js
    import Model, { attr } from '@ember-data/model';
  
    export default Model.extend({
      firstName: attr('string'),
      lastName: attr('string'),
      occupation: attr('string')
    });
    ```
  
    The JSON returned should look like this:
  
    ```js
    {
      "people": {
        "id": 5,
        "firstName": "Zaphod",
        "lastName": "Beeblebrox",
        "occupation": "President"
      }
    }
    ```
  
    #### Relationships
  
    Relationships are usually represented by ids to the record in the
    relationship. The related records can then be sideloaded in the
    response under a key for the type.
  
    ```js
    {
      "posts": {
        "id": 5,
        "title": "I'm Running to Reform the W3C",
        "author": "Yehuda Katz",
        "comments": [1, 2]
      },
      "comments": [{
        "id": 1,
        "author": "User 1",
        "message": "First!",
      }, {
        "id": 2,
        "author": "User 2",
        "message": "Good Luck!",
      }]
    }
    ```
  
    If the records in the relationship are not known when the response
    is serialized it's also possible to represent the relationship as a
    URL using the `links` key in the response. Ember Data will fetch
    this URL to resolve the relationship when it is accessed for the
    first time.
  
    ```js
    {
      "posts": {
        "id": 5,
        "title": "I'm Running to Reform the W3C",
        "author": "Yehuda Katz",
        "links": {
          "comments": "/posts/5/comments"
        }
      }
    }
    ```
  
    ### Errors
  
    If a response is considered a failure, the JSON payload is expected to include
    a top-level key `errors`, detailing any specific issues. For example:
  
    ```js
    {
      "errors": {
        "msg": "Something went wrong"
      }
    }
    ```
  
    This adapter does not make any assumptions as to the format of the `errors`
    object. It will simply be passed along as is, wrapped in an instance
    of `InvalidError` or `AdapterError`. The serializer can interpret it
    afterwards.
  
    ## Customization
  
    ### Endpoint path customization
  
    Endpoint paths can be prefixed with a `namespace` by setting the namespace
    property on the adapter:
  
    ```app/adapters/application.js
    import RESTAdapter from '@ember-data/adapter/rest';
  
    export default class ApplicationAdapter extends RESTAdapter {
      namespace = 'api/1';
    }
    ```
    Requests for the `Person` model would now target `/api/1/people/1`.
  
    ### Host customization
  
    An adapter can target other hosts by setting the `host` property.
  
    ```app/adapters/application.js
    import RESTAdapter from '@ember-data/adapter/rest';
  
    export default class ApplicationAdapter extends RESTAdapter {
      host = 'https://api.example.com';
    }
    ```
  
    ### Headers customization
  
    Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary
    headers can be set as key/value pairs on the `RESTAdapter`'s `headers`
    object and EmberData will send them along with each ajax request.
  
  
    ```app/adapters/application.js
    import RESTAdapter from '@ember-data/adapter/rest';
  
    export default class ApplicationAdapter extends RESTAdapter {
      get headers() {
        return {
          'API_KEY': 'secret key',
          'ANOTHER_HEADER': 'Some header value'
        };
      }
    }
    ```
  
    @class RESTAdapter
    @main @ember-data/adapter/rest
    @public
    @constructor
    @extends Adapter
    @uses BuildURLMixin
  */
  class RESTAdapter extends RESTAdapter_base {
      _fastboot: FastBoot;
      _coalesceFindRequests: boolean;
      host: string | null;
      namespace: string | null;
      /**
        This property allows ajax to still be used instead when `false`.
    
        @property useFetch
        @type {Boolean}
        @default true
        @public
      */
      useFetch: boolean;
      _defaultContentType: string;
      get fastboot(): FastBoot;
      set fastboot(value: FastBoot);
      /**
        By default, the RESTAdapter will send the query params sorted alphabetically to the
        server.
    
        For example:
    
        ```js
        store.query('posts', { sort: 'price', category: 'pets' });
        ```
    
        will generate a requests like this `/posts?category=pets&sort=price`, even if the
        parameters were specified in a different order.
    
        That way the generated URL will be deterministic and that simplifies caching mechanisms
        in the backend.
    
        Setting `sortQueryParams` to a falsey value will respect the original order.
    
        In case you want to sort the query parameters with a different criteria, set
        `sortQueryParams` to your custom sort function.
    
        ```app/adapters/application.js
        import RESTAdapter from '@ember-data/adapter/rest';
    
        export default class ApplicationAdapter extends RESTAdapter {
          sortQueryParams(params) {
            let sortedKeys = Object.keys(params).sort().reverse();
            let len = sortedKeys.length, newParams = {};
    
            for (let i = 0; i < len; i++) {
              newParams[sortedKeys[i]] = params[sortedKeys[i]];
            }
    
            return newParams;
          }
        }
        ```
    
        @method sortQueryParams
        @param {Object} obj
        @return {Object}
        @public
      */
      sortQueryParams(obj: Record<string, unknown>): Record<string, unknown>;
      /**
        By default the RESTAdapter will send each find request coming from a `store.find`
        or from accessing a relationship separately to the server. If your server supports passing
        ids as a query string, you can set coalesceFindRequests to true to coalesce all find requests
        within a single runloop.
    
        For example, if you have an initial payload of:
    
        ```javascript
        {
          post: {
            id: 1,
            comments: [1, 2]
          }
        }
        ```
    
        By default calling `post.comments` will trigger the following requests(assuming the
        comments haven't been loaded before):
    
        ```
        GET /comments/1
        GET /comments/2
        ```
    
        If you set coalesceFindRequests to `true` it will instead trigger the following request:
    
        ```
        GET /comments?ids[]=1&ids[]=2
        ```
    
        Setting coalesceFindRequests to `true` also works for `store.find` requests and `belongsTo`
        relationships accessed within the same runloop. If you set `coalesceFindRequests: true`
    
        ```javascript
        store.findRecord('comment', 1);
        store.findRecord('comment', 2);
        ```
    
        will also send a request to: `GET /comments?ids[]=1&ids[]=2`
    
        Note: Requests coalescing rely on URL building strategy. So if you override `buildURL` in your app
        `groupRecordsForFindMany` more likely should be overridden as well in order for coalescing to work.
    
        @property coalesceFindRequests
        @public
        @type {boolean}
      */
      get coalesceFindRequests(): boolean;
      set coalesceFindRequests(value: boolean);
      /**
        Endpoint paths can be prefixed with a `namespace` by setting the namespace
        property on the adapter:
    
        ```app/adapters/application.js
        import RESTAdapter from '@ember-data/adapter/rest';
    
        export default class ApplicationAdapter extends RESTAdapter {
          namespace = 'api/1';
        }
        ```
    
        Requests for the `Post` model would now target `/api/1/post/`.
    
        @property namespace
        @public
        @type {String}
      */
      /**
        An adapter can target other hosts by setting the `host` property.
    
        ```app/adapters/application.js
        import RESTAdapter from '@ember-data/adapter/rest';
    
        export default class ApplicationAdapter extends RESTAdapter {
          host = 'https://api.example.com';
        }
        ```
    
        Requests for the `Post` model would now target `https://api.example.com/post/`.
    
        @property host
        @public
        @type {String}
      */
      /**
        Some APIs require HTTP headers, e.g. to provide an API
        key. Arbitrary headers can be set as key/value pairs on the
        `RESTAdapter`'s `headers` object and Ember Data will send them
        along with each ajax request. For dynamic headers see [headers
        customization](/ember-data/release/classes/RESTAdapter).
    
        ```app/adapters/application.js
        import RESTAdapter from '@ember-data/adapter/rest';
    
        export default class ApplicationAdapter extends RESTAdapter {
          get headers() {
            return {
              'API_KEY': 'secret key',
              'ANOTHER_HEADER': 'Some header value'
            };
          }
        }
        ```
    
        @property headers
        @public
        @type {Object}
       */
      headers: Record<string, unknown> | undefined;
      /**
        Called by the store in order to fetch the JSON for a given
        type and ID.
    
        The `findRecord` method makes an Ajax request to a URL computed by
        `buildURL`, and returns a promise for the resulting payload.
    
        This method performs an HTTP `GET` request with the id provided as part of the query string.
    
        @since 1.13.0
        @method findRecord
        @public
        @param {Store} store
        @param {Model} type
        @param {String} id
        @param {Snapshot} snapshot
        @return {Promise} promise
      */
      findRecord(store: Store, type: ModelSchema, id: string, snapshot: Snapshot): Promise<AdapterPayload>;
      /**
        Called by the store in order to fetch a JSON array for all
        of the records for a given type.
    
        The `findAll` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a
        promise for the resulting payload.
    
        @method findAll
        @public
        @param {Store} store
        @param {Model} type
        @param {undefined} neverSet a value is never provided to this argument
        @param {SnapshotRecordArray} snapshotRecordArray
        @return {Promise} promise
      */
      findAll(store: Store, type: ModelSchema, sinceToken: null, snapshotRecordArray: SnapshotRecordArray): Promise<AdapterPayload>;
      /**
        Called by the store in order to fetch a JSON array for
        the records that match a particular query.
    
        The `query` method makes an Ajax (HTTP GET) request to a URL
        computed by `buildURL`, and returns a promise for the resulting
        payload.
    
        The `query` argument is a simple JavaScript object that will be passed directly
        to the server as parameters.
    
        @method query
        @public
        @param {Store} store
        @param {Model} type
        @param {Object} query
        @param {Collection} recordArray
        @param {Object} adapterOptions
        @return {Promise} promise
      */
      query(store: Store, type: ModelSchema, query: Record<string, unknown>): Promise<AdapterPayload>;
      /**
        Called by the store in order to fetch a JSON object for
        the record that matches a particular query.
    
        The `queryRecord` method makes an Ajax (HTTP GET) request to a URL
        computed by `buildURL`, and returns a promise for the resulting
        payload.
    
        The `query` argument is a simple JavaScript object that will be passed directly
        to the server as parameters.
    
        @since 1.13.0
        @method queryRecord
        @public
        @param {Store} store
        @param {Model} type
        @param {Object} query
        @param {Object} adapterOptions
        @return {Promise} promise
      */
      queryRecord(store: Store, type: ModelSchema, query: Record<string, unknown>, adapterOptions: Record<string, unknown>): Promise<AdapterPayload>;
      /**
        Called by the store in order to fetch several records together if `coalesceFindRequests` is true
    
        For example, if the original payload looks like:
    
        ```js
        {
          "id": 1,
          "title": "Rails is omakase",
          "comments": [ 1, 2, 3 ]
        }
        ```
    
        The IDs will be passed as a URL-encoded Array of IDs, in this form:
    
        ```
        ids[]=1&ids[]=2&ids[]=3
        ```
    
        Many servers, such as Rails and PHP, will automatically convert this URL-encoded array
        into an Array for you on the server-side. If you want to encode the
        IDs, differently, just override this (one-line) method.
    
        The `findMany` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a
        promise for the resulting payload.
    
        @method findMany
        @public
        @param {Store} store
        @param {Model} type
        @param {Array} ids
        @param {Array} snapshots
        @return {Promise} promise
      */
      findMany(store: Store, type: ModelSchema, ids: string[], snapshots: Snapshot[]): Promise<AdapterPayload>;
      /**
        Called by the store in order to fetch a JSON array for
        the unloaded records in a has-many relationship that were originally
        specified as a URL (inside of `links`).
    
        For example, if your original payload looks like this:
    
        ```js
        {
          "post": {
            "id": 1,
            "title": "Rails is omakase",
            "links": { "comments": "/posts/1/comments" }
          }
        }
        ```
    
        This method will be called with the parent record and `/posts/1/comments`.
    
        The `findHasMany` method will make an Ajax (HTTP GET) request to the originally specified URL.
    
        The format of your `links` value will influence the final request URL via the `urlPrefix` method:
    
        * Links beginning with `//`, `http://`, `https://`, will be used as is, with no further manipulation.
    
        * Links beginning with a single `/` will have the current adapter's `host` value prepended to it.
    
        * Links with no beginning `/` will have a parentURL prepended to it, via the current adapter's `buildURL`.
    
        @method findHasMany
        @public
        @param {Store} store
        @param {Snapshot} snapshot
        @param {String} url
        @param {Object} relationship meta object describing the relationship
        @return {Promise} promise
      */
      findHasMany(store: Store, snapshot: Snapshot, url: string, relationship: Record<string, unknown>): Promise<AdapterPayload>;
      /**
        Called by the store in order to fetch the JSON for the unloaded record in a
        belongs-to relationship that was originally specified as a URL (inside of
        `links`).
    
        For example, if your original payload looks like this:
    
        ```js
        {
          "person": {
            "id": 1,
            "name": "Tom Dale",
            "links": { "group": "/people/1/group" }
          }
        }
        ```
    
        This method will be called with the parent record and `/people/1/group`.
    
        The `findBelongsTo` method will make an Ajax (HTTP GET) request to the originally specified URL.
    
        The format of your `links` value will influence the final request URL via the `urlPrefix` method:
    
        * Links beginning with `//`, `http://`, `https://`, will be used as is, with no further manipulation.
    
        * Links beginning with a single `/` will have the current adapter's `host` value prepended to it.
    
        * Links with no beginning `/` will have a parentURL prepended to it, via the current adapter's `buildURL`.
    
        @method findBelongsTo
        @public
        @param {Store} store
        @param {Snapshot} snapshot
        @param {String} url
        @param {Object} relationship meta object describing the relationship
        @return {Promise} promise
      */
      findBelongsTo(store: Store, snapshot: Snapshot, url: string, relationship: any): Promise<AdapterPayload>;
      /**
        Called by the store when a newly created record is
        saved via the `save` method on a model record instance.
    
        The `createRecord` method serializes the record and makes an Ajax (HTTP POST) request
        to a URL computed by `buildURL`.
    
        See `serialize` for information on how to customize the serialized form
        of a record.
    
        @method createRecord
        @public
        @param {Store} store
        @param {Model} type
        @param {Snapshot} snapshot
        @return {Promise} promise
      */
      createRecord(store: Store, type: ModelSchema, snapshot: Snapshot): Promise<AdapterPayload>;
      /**
        Called by the store when an existing record is saved
        via the `save` method on a model record instance.
    
        The `updateRecord` method serializes the record and makes an Ajax (HTTP PUT) request
        to a URL computed by `buildURL`.
    
        See `serialize` for information on how to customize the serialized form
        of a record.
    
        @method updateRecord
        @public
        @param {Store} store
        @param {Model} schema
        @param {Snapshot} snapshot
        @return {Promise} promise
      */
      updateRecord(store: Store, schema: ModelSchema, snapshot: Snapshot): Promise<AdapterPayload>;
      /**
        Called by the store when a record is deleted.
    
        The `deleteRecord` method  makes an Ajax (HTTP DELETE) request to a URL computed by `buildURL`.
    
        @method deleteRecord
        @public
        @param {Store} store
        @param {Model} type
        @param {Snapshot} snapshot
        @return {Promise} promise
      */
      deleteRecord(store: Store, schema: ModelSchema, snapshot: Snapshot): Promise<AdapterPayload>;
      _stripIDFromURL(store: Store, snapshot: Snapshot): string;
      maxURLLength: number;
      /**
        Organize records into groups, each of which is to be passed to separate
        calls to `findMany`.
    
        This implementation groups together records that have the same base URL but
        differing ids. For example `/comments/1` and `/comments/2` will be grouped together
        because we know findMany can coalesce them together as `/comments?ids[]=1&ids[]=2`
    
        It also supports urls where ids are passed as a query param, such as `/comments?id=1`
        but not those where there is more than 1 query param such as `/comments?id=2&name=David`
        Currently only the query param of `id` is supported. If you need to support others, please
        override this or the `_stripIDFromURL` method.
    
        It does not group records that have differing base urls, such as for example: `/posts/1/comments/2`
        and `/posts/2/comments/3`
    
        @method groupRecordsForFindMany
        @public
        @param {Store} store
        @param {Array} snapshots
        @return {Array}  an array of arrays of records, each of which is to be
                          loaded separately by `findMany`.
      */
      groupRecordsForFindMany(store: Store, snapshots: Snapshot[]): Snapshot[][];
      /**
        Takes an ajax response, and returns the json payload or an error.
    
        By default this hook just returns the json payload passed to it.
        You might want to override it in two cases:
    
        1. Your API might return useful results in the response headers.
        Response headers are passed in as the second argument.
    
        2. Your API might return errors as successful responses with status code
        200 and an Errors text or object. You can return a `InvalidError` or a
        `AdapterError` (or a sub class) from this hook and it will automatically
        reject the promise and put your record into the invalid or error state.
    
        Returning a `InvalidError` from this method will cause the
        record to transition into the `invalid` state and make the
        `errors` object available on the record. When returning an
        `InvalidError` the store will attempt to normalize the error data
        returned from the server using the serializer's `extractErrors`
        method.
    
        @since 1.13.0
        @method handleResponse
        @public
        @param  {Number} status
        @param  {Object} headers
        @param  {Object} payload
        @param  {Object} requestData - the original request information
        @return {Object | AdapterError} response
      */
      handleResponse(status: number, headers: Record<string, string>, payload: Payload, requestData: RequestData): Payload | typeof AdapterError;
      /**
        Default `handleResponse` implementation uses this hook to decide if the
        response is a success.
    
        @since 1.13.0
        @method isSuccess
        @public
        @param  {Number} status
        @param  {Object} headers
        @param  {Object} payload
        @return {Boolean}
      */
      isSuccess(status: number, _headers: Record<string, unknown>, _payload: Payload): boolean;
      /**
        Default `handleResponse` implementation uses this hook to decide if the
        response is an invalid error.
    
        @since 1.13.0
        @method isInvalid
        @public
        @param  {Number} status
        @param  {Object} headers
        @param  {Object} payload
        @return {Boolean}
      */
      isInvalid(status: number, _headers: Record<string, unknown>, _payload: Payload): boolean;
      /**
        Takes a URL, an HTTP method and a hash of data, and makes an
        HTTP request.
    
        When the server responds with a payload, Ember Data will call into `extractSingle`
        or `extractArray` (depending on whether the original query was for one record or
        many records).
    
        By default, `ajax` method has the following behavior:
    
        * It sets the response `dataType` to `"json"`
        * If the HTTP method is not `"GET"`, it sets the `Content-Type` to be
          `application/json; charset=utf-8`
        * If the HTTP method is not `"GET"`, it stringifies the data passed in. The
          data is the serialized record in the case of a save.
        * Registers success and failure handlers.
    
        @method ajax
        @private
        @param {String} url
        @param {String} type The request type GET, POST, PUT, DELETE etc.
        @param {Object} options
        @return {Promise} promise
      */
      ajax(url: string, type: HTTPMethod, options?: JQueryAjaxSettings | RequestInit): Promise<AdapterPayload>;
      /**
        @method _ajaxRequest
        @private
        @param {Object} options jQuery ajax options to be used for the ajax request
      */
      _ajaxRequest(options: JQueryRequestInit): void;
      _fetchRequest(options: FetchRequestInit): Promise<Response>;
      _ajax(options: FetchRequestInit | JQueryRequestInit): void;
      /**
        @method ajaxOptions
        @private
        @param {String} url
        @param {String} type The request type GET, POST, PUT, DELETE etc.
        @param {Object} options
        @return {Object}
      */
      ajaxOptions(url: string, method: HTTPMethod, options: JQueryAjaxSettings | RequestInit): JQueryRequestInit | FetchRequestInit;
      _ajaxURL(url: string): string;
      /**
        @method parseErrorResponse
        @private
        @param {String} responseText
        @return {Object}
      */
      parseErrorResponse(responseText: string): Record<string, unknown> | string;
      /**
        @method normalizeErrorResponse
        @private
        @param  {Number} status
        @param  {Object} headers
        @param  {Object} payload
        @return {Array} errors payload
      */
      normalizeErrorResponse(status: number, _headers: Record<string, unknown>, payload: Payload): Record<string, unknown>[];
      /**
        Generates a detailed ("friendly") error message, with plenty
        of information for debugging (good luck!)
    
        @method generatedDetailedMessage
        @private
        @param  {Number} status
        @param  {Object} headers
        @param  {Object} payload
        @param  {Object} requestData
        @return {String} detailed error message
      */
      generatedDetailedMessage(status: number, headers: Record<string, string>, payload: Payload, requestData: RequestData): string;
      /**
        Used by `findAll` and `findRecord` to build the query's `data` hash
        supplied to the ajax method.
    
        @method buildQuery
        @since 2.5.0
        @public
        @param  {Snapshot} snapshot
        @return {Object}
      */
      buildQuery(snapshot: Snapshot | SnapshotRecordArray): QueryState;
  }
  interface RESTAdapter extends MixtBuildURLMixin {
  }
  /**
   * Helper function that translates the options passed to `jQuery.ajax` into a format that `fetch` expects.
   *
   * @method fetchOptions
   * @for @ember-data/adapter/rest
   * @param {Object} _options
   * @param {Adapter} adapter
   * @private
   * @return {Object}
   */
  export function fetchOptions(options: JQueryRequestInit & Partial<FetchRequestInit>, adapter: RESTAdapter): FetchRequestInit;
  export default RESTAdapter;
}
//# sourceMappingURL=rest.d.ts.map