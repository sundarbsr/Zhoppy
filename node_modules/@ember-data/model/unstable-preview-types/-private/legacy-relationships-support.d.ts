declare module '@ember-data/model/-private/legacy-relationships-support' {
  import type { CollectionEdge, Graph, ResourceEdge, UpgradedMeta } from '@ember-data/graph/-private';
  import type Store from '@ember-data/store';
  import type { LiveArray } from '@ember-data/store/-private';
  import { RelatedCollection as ManyArray } from '@ember-data/store/-private';
  import type { BaseFinderOptions } from '@ember-data/store/types';
  import type { StableRecordIdentifier } from '@warp-drive/core-types';
  import type { Cache } from '@warp-drive/core-types/cache';
  import type { CollectionRelationship } from '@warp-drive/core-types/cache/relationship';
  import type { LocalRelationshipOperation } from '@warp-drive/core-types/graph';
  import type { OpaqueRecordInstance, TypeFromInstanceOrString } from '@warp-drive/core-types/record';
  import type { CollectionResourceRelationship, InnerRelationshipDocument, SingleResourceRelationship } from '@warp-drive/core-types/spec/json-api-raw';
  import type { MinimalLegacyRecord } from '@ember-data/model/-private/model-methods';
  import type { BelongsToProxyCreateArgs } from '@ember-data/model/-private/promise-belongs-to';
  import { PromiseBelongsTo } from '@ember-data/model/-private/promise-belongs-to';
  import type { HasManyProxyCreateArgs } from '@ember-data/model/-private/promise-many-array';
  import { PromiseManyArray } from '@ember-data/model/-private/promise-many-array';
  import BelongsToReference from '@ember-data/model/-private/references/belongs-to';
  import HasManyReference from '@ember-data/model/-private/references/has-many';
  export const LEGACY_SUPPORT: Map<StableRecordIdentifier | MinimalLegacyRecord, LegacySupport>;
  export function lookupLegacySupport(record: MinimalLegacyRecord): LegacySupport;
  export class LegacySupport {
      record: MinimalLegacyRecord;
      store: Store;
      graph: Graph;
      cache: Cache;
      references: Record<string, BelongsToReference | HasManyReference>;
      identifier: StableRecordIdentifier;
      _manyArrayCache: Record<string, ManyArray>;
      _relationshipPromisesCache: Record<string, Promise<ManyArray | OpaqueRecordInstance>>;
      _relationshipProxyCache: Record<string, PromiseManyArray | PromiseBelongsTo | undefined>;
      _pending: Record<string, Promise<StableRecordIdentifier | null> | undefined>;
      isDestroying: boolean;
      isDestroyed: boolean;
      constructor(record: MinimalLegacyRecord);
      _syncArray(array: LiveArray): void;
      mutate(mutation: LocalRelationshipOperation): void;
      _findBelongsTo(key: string, resource: SingleResourceRelationship, relationship: ResourceEdge, options?: BaseFinderOptions): Promise<OpaqueRecordInstance | null>;
      reloadBelongsTo(key: string, options?: BaseFinderOptions): Promise<OpaqueRecordInstance | null>;
      getBelongsTo(key: string, options?: BaseFinderOptions): PromiseBelongsTo | OpaqueRecordInstance | null;
      setDirtyBelongsTo(key: string, value: OpaqueRecordInstance | null): void;
      _getCurrentState<T>(identifier: StableRecordIdentifier, field: string): [StableRecordIdentifier<TypeFromInstanceOrString<T>>[], CollectionRelationship];
      getManyArray<T>(key: string, definition?: UpgradedMeta): ManyArray<T>;
      fetchAsyncHasMany(key: string, relationship: CollectionEdge, manyArray: ManyArray, options?: BaseFinderOptions): Promise<ManyArray>;
      reloadHasMany<T>(key: string, options?: BaseFinderOptions): Promise<ManyArray<T>> | PromiseManyArray<T>;
      getHasMany(key: string, options?: BaseFinderOptions): PromiseManyArray | ManyArray;
      _updatePromiseProxyFor(kind: 'hasMany', key: string, args: HasManyProxyCreateArgs): PromiseManyArray;
      _updatePromiseProxyFor(kind: 'belongsTo', key: string, args: BelongsToProxyCreateArgs): PromiseBelongsTo;
      _updatePromiseProxyFor(kind: 'belongsTo', key: string, args: {
          promise: Promise<OpaqueRecordInstance | null>;
      }): PromiseBelongsTo;
      referenceFor(kind: 'belongsTo', name: string): BelongsToReference;
      referenceFor(kind: 'hasMany', name: string): HasManyReference;
      _findHasManyByJsonApiResource(resource: CollectionResourceRelationship, parentIdentifier: StableRecordIdentifier, relationship: CollectionEdge, options?: BaseFinderOptions): Promise<void | unknown[]> | void;
      _findBelongsToByJsonApiResource(resource: SingleResourceRelationship, parentIdentifier: StableRecordIdentifier, relationship: ResourceEdge, options?: BaseFinderOptions): Promise<StableRecordIdentifier | null>;
      destroy(): void;
  }
  export function areAllInverseRecordsLoaded(store: Store, resource: InnerRelationshipDocument): boolean;
}
//# sourceMappingURL=legacy-relationships-support.d.ts.map