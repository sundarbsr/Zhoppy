declare module '@ember-data/model/-private/model-methods' {
  import type { Snapshot } from '@ember-data/legacy-compat/-private';
  import type Store from '@ember-data/store';
  import type { ChangedAttributesHash } from '@warp-drive/core-types/cache';
  import { RecordStore } from '@warp-drive/core-types/symbols';
  import type { Errors } from '@ember-data/model/-private/errors';
  import type RecordState from '@ember-data/model/-private/record-state';
  import type BelongsToReference from '@ember-data/model/-private/references/belongs-to';
  import type HasManyReference from '@ember-data/model/-private/references/has-many';
  import type { MaybeBelongsToFields, MaybeHasManyFields } from '@ember-data/model/-private/type-utils';
  export interface MinimalLegacyRecord {
      errors: Errors;
      ___recordState: RecordState;
      currentState: RecordState;
      isDestroyed: boolean;
      isDestroying: boolean;
      isReloading: boolean;
      isValid: boolean;
      [RecordStore]: Store;
      deleteRecord(): void;
      unloadRecord(): void;
      save<T extends MinimalLegacyRecord>(this: T, options?: Record<string, unknown>): Promise<this>;
      destroyRecord<T extends MinimalLegacyRecord>(this: T, options?: Record<string, unknown>): Promise<this>;
  }
  export function rollbackAttributes<T extends MinimalLegacyRecord>(this: T): void;
  export function unloadRecord<T extends MinimalLegacyRecord>(this: T): void;
  export function belongsTo<T extends MinimalLegacyRecord, K extends MaybeBelongsToFields<T>>(this: T, prop: K): BelongsToReference<T, K>;
  export function hasMany<T extends MinimalLegacyRecord, K extends MaybeHasManyFields<T>>(this: T, prop: K): HasManyReference<T, K>;
  export function reload<T extends MinimalLegacyRecord>(this: T, options?: Record<string, unknown>): Promise<T>;
  export function changedAttributes<T extends MinimalLegacyRecord>(this: T): ChangedAttributesHash;
  export function serialize<T extends MinimalLegacyRecord>(this: T, options?: Record<string, unknown>): unknown;
  export function deleteRecord<T extends MinimalLegacyRecord>(this: T): void;
  export function save<T extends MinimalLegacyRecord>(this: T, options?: Record<string, unknown>): Promise<T>;
  export function destroyRecord<T extends MinimalLegacyRecord>(this: T, options?: Record<string, unknown>): Promise<T>;
  export function createSnapshot<T extends MinimalLegacyRecord>(this: T): Snapshot<T>;
}
//# sourceMappingURL=model-methods.d.ts.map