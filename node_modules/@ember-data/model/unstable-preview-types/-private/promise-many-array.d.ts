declare module '@ember-data/model/-private/promise-many-array' {
  import type { RelatedCollection as ManyArray } from '@ember-data/store/-private';
  import type { BaseFinderOptions } from '@ember-data/store/types';
  import { LegacyPromiseProxy } from '@ember-data/model/-private/promise-belongs-to';
  export interface HasManyProxyCreateArgs<T = unknown> {
      promise: Promise<ManyArray<T>>;
      content?: ManyArray<T>;
  }
  /**
   @module @ember-data/model
   */
  /**
    This class is returned as the result of accessing an async hasMany relationship
    on an instance of a Model extending from `@ember-data/model`.
  
    A PromiseManyArray is an iterable proxy that allows templates to consume related
    ManyArrays and update once their contents are no longer pending.
  
    In your JS code you should resolve the promise first.
  
    ```js
    const comments = await post.comments;
    ```
  
    @class PromiseManyArray
    @public
  */
  export class PromiseManyArray<T = unknown> {
      promise: Promise<ManyArray<T>> | null;
      isDestroyed: boolean;
      content: ManyArray<T> | null;
      constructor(promise: Promise<ManyArray<T>>, content?: ManyArray<T>);
      /**
       * Retrieve the length of the content
       * @property length
       * @public
       */
      get length(): number;
      /**
       * Iterate the proxied content. Called by the glimmer iterator in #each
       * We do not guarantee that forEach will always be available. This
       * may eventually be made to use Symbol.Iterator once glimmer supports it.
       *
       * @method forEach
       * @param cb
       * @return
       * @private
       */
      forEach(cb: (item: T, index: number, array: T[]) => void): void;
      /**
       * Reload the relationship
       * @method reload
       * @public
       * @param options
       * @return
       */
      reload(options: Omit<BaseFinderOptions, ''>): this;
      /**
       * Whether the loading promise is still pending
       *
       * @property {boolean} isPending
       * @public
       */
      isPending: boolean;
      /**
       * Whether the loading promise rejected
       *
       * @property {boolean} isRejected
       * @public
       */
      isRejected: boolean;
      /**
       * Whether the loading promise succeeded
       *
       * @property {boolean} isFulfilled
       * @public
       */
      isFulfilled: boolean;
      /**
       * Whether the loading promise completed (resolved or rejected)
       *
       * @property {boolean} isSettled
       * @public
       */
      isSettled: boolean;
      /**
       * chain this promise
       *
       * @method then
       * @public
       * @param success
       * @param fail
       * @return Promise
       */
      then(s: Parameters<Promise<ManyArray<T>>['then']>[0], f?: Parameters<Promise<ManyArray<T>>['then']>[1]): Promise<unknown>;
      /**
       * catch errors thrown by this promise
       * @method catch
       * @public
       * @param callback
       * @return Promise
       */
      catch(cb: Parameters<Promise<ManyArray<T>>['catch']>[0]): Promise<unknown>;
      /**
       * run cleanup after this promise completes
       *
       * @method finally
       * @public
       * @param callback
       * @return Promise
       */
      finally(cb: Parameters<Promise<ManyArray<T>>['finally']>[0]): Promise<ManyArray<T>>;
      destroy(): void;
      /**
       * Retrieve the links for this relationship
       * @property links
       * @public
       */
      get links(): import("@warp-drive/core-types/spec/json-api-raw").Links | null | undefined;
      /**
       * Retrieve the meta for this relationship
       * @property meta
       * @public
       */
      get meta(): Record<string, unknown> | null | undefined;
      _update(promise: Promise<ManyArray<T>>, content?: ManyArray<T>): void;
      static create<T>({ promise, content }: HasManyProxyCreateArgs<T>): PromiseManyArray<T>;
      [LegacyPromiseProxy]: true;
  }
}
//# sourceMappingURL=promise-many-array.d.ts.map