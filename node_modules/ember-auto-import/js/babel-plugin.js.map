{"version":3,"file":"babel-plugin.js","sourceRoot":"","sources":["../ts/babel-plugin.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-ignore\nimport syntax from 'babel-plugin-syntax-dynamic-import';\nimport type * as Babel from '@babel/core';\nimport type { types as t, NodePath } from '@babel/core';\nimport Package from './package';\n\nfunction emberAutoImport(babel: typeof Babel) {\n  let t = babel.types;\n  return {\n    inherits: syntax,\n    visitor: {\n      Import(path: NodePath<t.Import>, state: any) {\n        let call = path.parentPath as NodePath<t.CallExpression>;\n        let arg = call.node.arguments[0];\n        if (arg.type === 'StringLiteral') {\n          let cat = Package.categorize(arg.value);\n          if (cat === 'dep') {\n            call.replaceWith(\n              t.callExpression(t.identifier('emberAutoImportDynamic'), [arg])\n            );\n          }\n        } else if (arg.type === 'TemplateLiteral') {\n          const importedPathPrefix = arg.quasis[0].value.cooked!;\n          let cat = Package.categorize(importedPathPrefix, true);\n          if (cat === 'dep') {\n            call.replaceWith(\n              t.callExpression(t.identifier('emberAutoImportDynamic'), [\n                t.stringLiteral(\n                  arg.quasis.map((q) => q.value.cooked).join('${e}')\n                ),\n                ...(arg.expressions as t.Expression[]),\n              ])\n            );\n          } else if (cat === 'local') {\n            const resolvePath = state.file.opts.plugins.find(\n              (p: any) => p.key === 'module-resolver'\n            )?.options?.resolvePath;\n\n            if (!resolvePath) {\n              throw new Error(\n                `You attempted to dynamically import a relative path in ${state.file.opts.filename} but ember-auto-import was unable to locate the module-resolver plugin. Please file an issue https://github.com/embroider-build/ember-auto-import/issues/new`\n              );\n            }\n\n            // const sourcePath = path.node.value;\n            const currentFile = state.file.opts.filename;\n            const modulePath = resolvePath(\n              importedPathPrefix,\n              currentFile,\n              state.opts\n            );\n\n            if (modulePath) {\n              call.replaceWith(\n                t.callExpression(t.identifier('emberAutoImportDynamic'), [\n                  t.stringLiteral(\n                    arg.quasis\n                      .map((q, index) => {\n                        // replace the first quasis (importedPathPrefix) with the resolved modulePath\n                        if (index === 0) {\n                          return modulePath;\n                        }\n                        return q.value.cooked;\n                      })\n                      .join('${e}')\n                  ),\n                  ...(arg.expressions as t.Expression[]),\n                ])\n              );\n            }\n          }\n        }\n      },\n      CallExpression(path: NodePath<t.CallExpression>) {\n        let callee = path.get('callee');\n\n        if (\n          callee.isIdentifier() &&\n          callee.referencesImport('@embroider/macros', 'importSync')\n        ) {\n          let arg = path.node.arguments[0];\n          if (arg.type === 'StringLiteral') {\n            let cat = Package.categorize(arg.value);\n            if (cat === 'url') {\n              throw new Error('You cannot use importSync() with a URL.');\n            }\n            callee.replaceWith(t.identifier('require'));\n          } else if (arg.type === 'TemplateLiteral') {\n            let cat = Package.categorize(arg.quasis[0].value.cooked!, true);\n            if (cat === 'url') {\n              throw new Error('You cannot use importSync() with a URL.');\n            }\n            path.replaceWith(\n              t.callExpression(t.identifier('emberAutoImportSync'), [\n                t.stringLiteral(\n                  arg.quasis.map((q) => q.value.cooked).join('${e}')\n                ),\n                ...(arg.expressions as t.Expression[]),\n              ])\n            );\n          }\n        }\n      },\n    },\n  };\n}\n\nemberAutoImport.baseDir = function () {\n  return __dirname;\n};\n\nexport = emberAutoImport;\n"]}