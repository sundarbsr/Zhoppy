import { macroCondition, isDevelopingApp } from '@embroider/macros';
import { warn } from '@ember/debug';
import Token from './token.js';

// this ensures that if @ember/test-waiters exists in multiple places in the
// build output we will still use a single map of waiters (there really should
// only be one of them, or else `settled` will not work at all)
const WAITERS = function () {
  const HAS_SYMBOL = typeof Symbol !== 'undefined';
  const symbolName = 'TEST_WAITERS';
  const symbol = HAS_SYMBOL ? Symbol.for(symbolName) : symbolName;
  const global = getGlobal();
  let waiters = global[symbol];
  if (waiters === undefined) {
    waiters = global[symbol] = new Map();
  }
  return waiters;
}();
function indexable(input) {
  return input;
}
function getGlobal() {
  if (typeof globalThis !== 'undefined') return indexable(globalThis);
  if (typeof self !== 'undefined') return indexable(self);
  if (typeof window !== 'undefined') return indexable(window);
  throw new Error('unable to locate global object');
}

/**
 * Registers a waiter.
 *
 * @public
 * @param waiter {Waiter} A test waiter instance
 */
function register(waiter) {
  WAITERS.set(waiter.name, waiter);
}

/**
 * Un-registers a waiter.
 *
 * @public
 * @param waiter {Waiter} A test waiter instance
 */
function unregister(waiter) {
  WAITERS.delete(waiter.name);
}

/**
 * Gets an array of all waiters current registered.
 *
 * @public
 * @returns {Waiter[]}
 */
function getWaiters() {
  const result = [];
  WAITERS.forEach(value => {
    result.push(value);
  });
  return result;
}

/**
 * Clears all waiters.
 *
 * @private
 */
function _reset() {
  for (const waiter of getWaiters()) {
    waiter.isRegistered = false;
  }
  WAITERS.clear();
}

/**
 * Gets the current state of all waiters. Any waiters whose
 * `waitUntil` method returns false will be considered `pending`.
 *
 * @returns {PendingWaiterState} An object containing a count of all waiters
 * pending and a `waiters` object containing the name of all pending waiters
 * and their debug info.
 */
function getPendingWaiterState() {
  const result = {
    pending: 0,
    waiters: {}
  };
  WAITERS.forEach(waiter => {
    if (!waiter.waitUntil()) {
      result.pending++;
      const debugInfo = waiter.debugInfo();
      result.waiters[waiter.name] = debugInfo || true;
    }
  });
  return result;
}

/**
 * Determines if there are any pending waiters.
 *
 * @returns {boolean} `true` if there are pending waiters, otherwise `false`.
 */
function hasPendingWaiters() {
  const state = getPendingWaiterState();
  return state.pending > 0;
}

const WAITER_NAME_PATTERN = /^[^:]*:?.*/;
let WAITER_NAMES = macroCondition(isDevelopingApp()) ? new Set() : undefined;
function _resetWaiterNames() {
  WAITER_NAMES = new Set();
}
function getNextToken() {
  return new Token();
}
class TestWaiterImpl {
  name;
  nextToken;
  isRegistered = false;
  items = new Map();
  completedOperationsForTokens = new WeakMap();
  completedOperationsForPrimitives = new Map();
  constructor(name, nextToken) {
    this.name = name;
    // @ts-ignore
    this.nextToken = nextToken || getNextToken;
  }
  beginAsync(token = this.nextToken(), label) {
    this._register();
    if (this.items.has(token)) {
      // SAFETY: force stringification of a potential symbol
      throw new Error(`beginAsync called for ${token} but it is already pending.`);
    }
    const error = new Error();
    this.items.set(token, {
      get stack() {
        return error.stack;
      },
      label
    });
    return token;
  }
  endAsync(token) {
    if (!this.items.has(token) && !this._getCompletedOperations(token).has(token)) {
      throw new Error(`testWaiter.endAsync called with no preceding testWaiter.beginAsync call.
        Test waiter calls should always be paired. This can occur when a test waiter's paired calls are invoked in a non-deterministic order.

        See https://github.com/emberjs/ember-test-waiters#keep-beginasyncendasync-in-same-block-scope for more information.`);
    }
    this.items.delete(token);
    // Mark when a waiter operation has completed so we can distinguish
    // whether endAsync is being called before a prior beginAsync call above.
    this._getCompletedOperations(token).set(token, true);
  }
  waitUntil() {
    return this.items.size === 0;
  }
  debugInfo() {
    const result = [];
    this.items.forEach(value => {
      result.push(value);
    });
    return result;
  }
  reset() {
    this.items.clear();
  }
  _register() {
    if (!this.isRegistered) {
      register(this);
      this.isRegistered = true;
    }
  }
  _getCompletedOperations(token) {
    const type = typeof token;
    const isFunction = type === 'function';
    const isObject = token !== null && type === 'object';
    const isPrimitive = !isFunction && !isObject;
    return isPrimitive ? this.completedOperationsForPrimitives : this.completedOperationsForTokens;
  }
}
class NoopTestWaiter {
  name;
  constructor(name) {
    this.name = name;
  }
  beginAsync() {
    return this;
  }
  endAsync() {}
  waitUntil() {
    return true;
  }
  debugInfo() {
    return [];
  }
  reset() {}
}

/**
 * Builds and returns a test waiter. The type of the
 * returned waiter is dependent on whether the app or
 * addon is in `isDevelopingApp()` mode or not.
 *
 * @public
 *
 * @param name {string} The name of the test waiter
 * @returns {TestWaiter}
 *
 * @example
 *
 * import Component from '@ember/component';
 * import { buildWaiter } from '@ember/test-waiters';
 *
 * if (macroCondition(isDevelopingApp())) {
 *   let waiter = buildWaiter('friend-waiter');
 * }
 *
 * export default class Friendz extends Component {
 *   didInsertElement() {
 *     let token = waiter.beginAsync(this);
 *
 *     someAsyncWork().then(() => {
 *       waiter.endAsync(token);
 *     });
 *   }
 * }
 */
function buildWaiter(name) {
  if (macroCondition(isDevelopingApp())) {
    warn(`The waiter name '${name}' is already in use`, !WAITER_NAMES.has(name), {
      id: '@ember/test-waiters.duplicate-waiter-name'
    });
    WAITER_NAMES.add(name);
  }
  if (macroCondition(!isDevelopingApp())) {
    return new NoopTestWaiter(name);
  } else {
    warn(`You must provide a name that contains a descriptive prefix separated by a colon.

        Example: ember-fictitious-addon:some-file

        You passed: ${name}`, WAITER_NAME_PATTERN.test(name), {
      id: '@ember/test-waiters.invalid-waiter-name'
    });
    return new TestWaiterImpl(name);
  }
}

const PROMISE_WAITER = buildWaiter('@ember/test-waiters:promise-waiter');

/**
 * A convenient utility function to simplify waiting for a promise.
 *
 * @public
 * @param promise {Promise<T> | RSVP.Promise<T>} The promise to track async operations for
 * @param label {string} An optional string to identify the promise
 *
 * @example
 *
 * import Component from '@ember/component';
 * import { waitForPromise } from '@ember/test-waiters';
 *
 * export default class Friendz extends Component {
 *   didInsertElement() {
 *     waitForPromise(new Promise(resolve => {
 *       doSomeWork();
 *       resolve();
 *     }));
 *   }
 * }
 */
function waitForPromise(promise, label) {
  let result = promise;
  if (macroCondition(isDevelopingApp())) {
    PROMISE_WAITER.beginAsync(promise, label);
    result = promise.then(value => {
      PROMISE_WAITER.endAsync(promise);
      return value;
    }, error => {
      PROMISE_WAITER.endAsync(promise);
      throw error;
    });
  }
  return result;
}

/**
 * A convenient utility function to simplify waiting for async. Can be used
 * in both decorator and function form. When applied to an async function, it
 * will cause tests to wait until the returned promise has resolves. When
 * applied to a generator function, it will cause tests to wait until the
 * returned iterator has run to completion, which is useful for wrapping
 * ember-concurrency task functions.
 *
 *
 * @public
 * @param promise {Function} An async function or a generator function
 * @param label {string} An optional string to identify the promise
 *
 * @example
 *
 * import Component from '@ember/component';
 * import { waitFor } from '@ember/test-waiters';
 *
 * export default Component.extend({
 *   doAsyncStuff: waitFor(async function doAsyncStuff() {
 *     await somethingAsync();
 *   }
 * });
 *
 * @example
 *
 * import Component from '@ember/component';
 * import { waitFor } from '@ember/test-waiters';
 *
 * export default class Friendz extends Component {
 *   @waitFor
 *   async doAsyncStuff() {
 *     await somethingAsync();
 *   }
 * }
 *
 */

function waitFor(...args) {
  const isFunction = args.length < 3;
  if (isFunction) {
    const [fn, label] = args;
    return wrapFunction(fn, label);
  } else {
    const [,, descriptor, label] = args;
    if (macroCondition(!isDevelopingApp())) {
      return descriptor;
    }
    const fn = descriptor.value;
    descriptor.value = wrapFunction(fn, label);
    return descriptor;
  }
}
function wrapFunction(fn, label) {
  if (macroCondition(!isDevelopingApp())) {
    return fn;
  }
  return function (...args) {
    const result = fn.call(this, ...args);
    if (isThenable(result)) {
      return waitForPromise(result, label);
    } else if (isGenerator(result)) {
      return waitForGenerator(result, label);
    } else {
      return result;
    }
  };
}
function isThenable(maybePromise) {
  const type = typeof maybePromise;
  return (maybePromise !== null && type === 'object' || type === 'function') && typeof maybePromise.then === 'function';
}
function isGenerator(maybeGenerator) {
  // Because we don't have Symbol.iterator in IE11
  return typeof maybeGenerator.next === 'function' && typeof maybeGenerator.return === 'function' && typeof maybeGenerator.throw === 'function';
}
const GENERATOR_WAITER = buildWaiter('@ember/test-waiters:generator-waiter');
function waitForGenerator(generator, label) {
  GENERATOR_WAITER.beginAsync(generator, label);
  let isWaiting = true;
  function stopWaiting() {
    if (isWaiting) {
      GENERATOR_WAITER.endAsync(generator);
      isWaiting = false;
    }
  }
  return {
    next(...args) {
      let hasErrored = true;
      try {
        const val = generator.next(...args);
        hasErrored = false;
        if (val.done) {
          stopWaiting();
        }
        return val;
      } finally {
        // If generator.next() throws, we need to stop waiting. But if we catch
        // and re-throw exceptions, it could move the location from which the
        // uncaught exception is thrown, interfering with the developer
        // debugging experience if they have break-on-exceptions enabled. So we
        // use a boolean flag and a finally block to emulate a catch block.
        if (hasErrored) {
          stopWaiting();
        }
      }
    },
    return(...args) {
      stopWaiting();
      return generator.return(...args);
    },
    throw(...args) {
      stopWaiting();
      return generator.throw(...args);
    }
  };
}

async function waitForFetch(fetchPromise) {
  const response = await waitForPromise(fetchPromise);
  return new Proxy(response, {
    get(target, prop, receiver) {
      const original = Reflect.get(target, prop, receiver);
      if (typeof prop === 'string' && ['json', 'text', 'arrayBuffer', 'blob', 'formData', 'bytes'].includes(prop)) {
        return (...args) => {
          return waitForPromise(original.call(target, ...args));
        };
      }
      return original;
    }
  });
}

export { _reset, _resetWaiterNames, buildWaiter, getPendingWaiterState, getWaiters, hasPendingWaiters, register, unregister, waitFor, waitForFetch, waitForPromise };
//# sourceMappingURL=index.js.map
