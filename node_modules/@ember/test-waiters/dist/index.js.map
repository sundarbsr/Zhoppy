{"version":3,"file":"index.js","sources":["../src/waiter-manager.ts","../src/build-waiter.ts","../src/wait-for-promise.ts","../src/wait-for.ts","../src/wait-for-fetch.ts"],"sourcesContent":["import type { PendingWaiterState, Waiter, WaiterName } from './types/index.ts';\n\ntype Indexable = Record<any, unknown>;\n\n// this ensures that if @ember/test-waiters exists in multiple places in the\n// build output we will still use a single map of waiters (there really should\n// only be one of them, or else `settled` will not work at all)\nconst WAITERS: Map<WaiterName, Waiter> = (function () {\n  const HAS_SYMBOL = typeof Symbol !== 'undefined';\n\n  const symbolName = 'TEST_WAITERS';\n  const symbol = HAS_SYMBOL ? (Symbol.for(symbolName) as any) : symbolName;\n\n  const global = getGlobal();\n\n  let waiters = global[symbol];\n  if (waiters === undefined) {\n    waiters = global[symbol] = new Map<WaiterName, Waiter>();\n  }\n\n  return waiters as Map<WaiterName, Waiter>;\n})();\n\nfunction indexable<T extends object>(input: T): T & Indexable {\n  return input as T & Indexable;\n}\n\nfunction getGlobal(): Indexable {\n  if (typeof globalThis !== 'undefined') return indexable(globalThis);\n  if (typeof self !== 'undefined') return indexable(self);\n  if (typeof window !== 'undefined') return indexable(window);\n\n  throw new Error('unable to locate global object');\n}\n\n/**\n * Registers a waiter.\n *\n * @public\n * @param waiter {Waiter} A test waiter instance\n */\nexport function register(waiter: Waiter): void {\n  WAITERS.set(waiter.name, waiter);\n}\n\n/**\n * Un-registers a waiter.\n *\n * @public\n * @param waiter {Waiter} A test waiter instance\n */\nexport function unregister(waiter: Waiter): void {\n  WAITERS.delete(waiter.name);\n}\n\n/**\n * Gets an array of all waiters current registered.\n *\n * @public\n * @returns {Waiter[]}\n */\nexport function getWaiters(): Waiter[] {\n  const result: Waiter[] = [];\n\n  WAITERS.forEach((value) => {\n    result.push(value);\n  });\n\n  return result;\n}\n\n/**\n * Clears all waiters.\n *\n * @private\n */\nexport function _reset(): void {\n  for (const waiter of getWaiters()) {\n    (waiter as any).isRegistered = false;\n  }\n\n  WAITERS.clear();\n}\n\n/**\n * Gets the current state of all waiters. Any waiters whose\n * `waitUntil` method returns false will be considered `pending`.\n *\n * @returns {PendingWaiterState} An object containing a count of all waiters\n * pending and a `waiters` object containing the name of all pending waiters\n * and their debug info.\n */\nexport function getPendingWaiterState(): PendingWaiterState {\n  const result: PendingWaiterState = {\n    pending: 0,\n    waiters: {},\n  };\n\n  WAITERS.forEach((waiter) => {\n    if (!waiter.waitUntil()) {\n      result.pending++;\n\n      const debugInfo = waiter.debugInfo();\n      result.waiters[waiter.name] = debugInfo || true;\n    }\n  });\n\n  return result;\n}\n\n/**\n * Determines if there are any pending waiters.\n *\n * @returns {boolean} `true` if there are pending waiters, otherwise `false`.\n */\nexport function hasPendingWaiters(): boolean {\n  const state = getPendingWaiterState();\n\n  return state.pending > 0;\n}\n","import type { Primitive, TestWaiter, TestWaiterDebugInfo, WaiterName } from './types/index.ts';\nimport { macroCondition, isDevelopingApp } from '@embroider/macros';\nimport { warn } from '@ember/debug';\nimport Token from './token.ts';\nimport { register } from './waiter-manager.ts';\n\nconst WAITER_NAME_PATTERN = /^[^:]*:?.*/;\nlet WAITER_NAMES = macroCondition(isDevelopingApp()) ? new Set() : undefined;\n\nexport function _resetWaiterNames() {\n  WAITER_NAMES = new Set();\n}\n\nfunction getNextToken(): Token {\n  return new Token();\n}\n\nclass TestWaiterImpl<T extends object | Primitive = Token> implements TestWaiter<T> {\n  public name: WaiterName;\n  private nextToken: () => T;\n  private isRegistered = false;\n\n  items = new Map<T, TestWaiterDebugInfo>();\n  completedOperationsForTokens = new WeakMap<Token, boolean>();\n  completedOperationsForPrimitives = new Map<Primitive, boolean>();\n\n  constructor(name: WaiterName, nextToken?: () => T) {\n    this.name = name;\n    // @ts-ignore\n    this.nextToken = nextToken || getNextToken;\n  }\n\n  beginAsync(token: T = this.nextToken(), label?: string): T {\n    this._register();\n\n    if (this.items.has(token)) {\n      // SAFETY: force stringification of a potential symbol\n      throw new Error(`beginAsync called for ${token as string} but it is already pending.`);\n    }\n\n    const error = new Error();\n\n    this.items.set(token, {\n      get stack() {\n        return error.stack;\n      },\n      label,\n    });\n\n    return token;\n  }\n\n  endAsync(token: T): void {\n    if (!this.items.has(token) && !this._getCompletedOperations(token).has(token)) {\n      throw new Error(\n        `testWaiter.endAsync called with no preceding testWaiter.beginAsync call.\n        Test waiter calls should always be paired. This can occur when a test waiter's paired calls are invoked in a non-deterministic order.\n\n        See https://github.com/emberjs/ember-test-waiters#keep-beginasyncendasync-in-same-block-scope for more information.`\n      );\n    }\n\n    this.items.delete(token);\n    // Mark when a waiter operation has completed so we can distinguish\n    // whether endAsync is being called before a prior beginAsync call above.\n    this._getCompletedOperations(token).set(token, true);\n  }\n\n  waitUntil(): boolean {\n    return this.items.size === 0;\n  }\n\n  debugInfo(): TestWaiterDebugInfo[] {\n    const result: TestWaiterDebugInfo[] = [];\n\n    this.items.forEach((value) => {\n      result.push(value);\n    });\n\n    return result;\n  }\n\n  reset(): void {\n    this.items.clear();\n  }\n\n  private _register(): void {\n    if (!this.isRegistered) {\n      register(this);\n      this.isRegistered = true;\n    }\n  }\n\n  private _getCompletedOperations(token: T) {\n    const type = typeof token;\n\n    const isFunction = type === 'function';\n    const isObject = token !== null && type === 'object';\n    const isPrimitive = !isFunction && !isObject;\n\n    return isPrimitive ? this.completedOperationsForPrimitives : this.completedOperationsForTokens;\n  }\n}\n\nclass NoopTestWaiter implements TestWaiter {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  beginAsync(): Token {\n    return this;\n  }\n\n  endAsync(): void {}\n\n  waitUntil(): boolean {\n    return true;\n  }\n\n  debugInfo(): TestWaiterDebugInfo[] {\n    return [];\n  }\n\n  reset(): void {}\n}\n\n/**\n * Builds and returns a test waiter. The type of the\n * returned waiter is dependent on whether the app or\n * addon is in `isDevelopingApp()` mode or not.\n *\n * @public\n *\n * @param name {string} The name of the test waiter\n * @returns {TestWaiter}\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { buildWaiter } from '@ember/test-waiters';\n *\n * if (macroCondition(isDevelopingApp())) {\n *   let waiter = buildWaiter('friend-waiter');\n * }\n *\n * export default class Friendz extends Component {\n *   didInsertElement() {\n *     let token = waiter.beginAsync(this);\n *\n *     someAsyncWork().then(() => {\n *       waiter.endAsync(token);\n *     });\n *   }\n * }\n */\nexport default function buildWaiter(name: string): TestWaiter {\n  if (macroCondition(isDevelopingApp())) {\n    warn(`The waiter name '${name}' is already in use`, !WAITER_NAMES!.has(name), {\n      id: '@ember/test-waiters.duplicate-waiter-name',\n    });\n    WAITER_NAMES!.add(name);\n  }\n\n  if (macroCondition(!isDevelopingApp())) {\n    return new NoopTestWaiter(name);\n  } else {\n    warn(\n      `You must provide a name that contains a descriptive prefix separated by a colon.\n\n        Example: ember-fictitious-addon:some-file\n\n        You passed: ${name}`,\n      WAITER_NAME_PATTERN.test(name),\n      { id: '@ember/test-waiters.invalid-waiter-name' }\n    );\n\n    return new TestWaiterImpl(name);\n  }\n}\n","import { macroCondition, isDevelopingApp } from '@embroider/macros';\nimport buildWaiter from './build-waiter.ts';\n\nimport type { PromiseType, Thenable } from './types/index.ts';\n\nconst PROMISE_WAITER = buildWaiter('@ember/test-waiters:promise-waiter');\n\n/**\n * A convenient utility function to simplify waiting for a promise.\n *\n * @public\n * @param promise {Promise<T> | RSVP.Promise<T>} The promise to track async operations for\n * @param label {string} An optional string to identify the promise\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { waitForPromise } from '@ember/test-waiters';\n *\n * export default class Friendz extends Component {\n *   didInsertElement() {\n *     waitForPromise(new Promise(resolve => {\n *       doSomeWork();\n *       resolve();\n *     }));\n *   }\n * }\n */\nexport default function waitForPromise<T, KindOfPromise extends PromiseType<T>>(\n  promise: KindOfPromise,\n  label?: string\n): KindOfPromise {\n  let result = promise;\n\n  if (macroCondition(isDevelopingApp())) {\n    PROMISE_WAITER.beginAsync(promise, label);\n\n    result = (promise as unknown as Thenable<T, KindOfPromise>).then(\n      (value: T) => {\n        PROMISE_WAITER.endAsync(promise);\n        return value;\n      },\n      (error: Error) => {\n        PROMISE_WAITER.endAsync(promise);\n        throw error;\n      }\n    );\n  }\n\n  return result;\n}\n","import { macroCondition, isDevelopingApp } from '@embroider/macros';\nimport waitForPromise from './wait-for-promise.ts';\nimport buildWaiter from './build-waiter.ts';\nimport type { PromiseType } from './types/index.ts';\n\ntype AsyncFunction<A extends Array<any>, PromiseReturn> = (...args: A) => Promise<PromiseReturn>;\ntype AsyncFunctionArguments = [AsyncFunction<any[], any>, string?];\n\ntype CoroutineGenerator<T> = Generator<any, T, any>;\ntype CoroutineFunction<A extends Array<any>, T> = (...args: A) => CoroutineGenerator<T>;\ntype CoroutineFunctionArguments = [CoroutineFunction<any[], any>, string?];\n\ntype DecoratorArguments = [object, string, PropertyDescriptor, string?];\n\n/**\n * A convenient utility function to simplify waiting for async. Can be used\n * in both decorator and function form. When applied to an async function, it\n * will cause tests to wait until the returned promise has resolves. When\n * applied to a generator function, it will cause tests to wait until the\n * returned iterator has run to completion, which is useful for wrapping\n * ember-concurrency task functions.\n *\n *\n * @public\n * @param promise {Function} An async function or a generator function\n * @param label {string} An optional string to identify the promise\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { waitFor } from '@ember/test-waiters';\n *\n * export default Component.extend({\n *   doAsyncStuff: waitFor(async function doAsyncStuff() {\n *     await somethingAsync();\n *   }\n * });\n *\n * @example\n *\n * import Component from '@ember/component';\n * import { waitFor } from '@ember/test-waiters';\n *\n * export default class Friendz extends Component {\n *   @waitFor\n *   async doAsyncStuff() {\n *     await somethingAsync();\n *   }\n * }\n *\n */\nexport default function waitFor<A extends Array<any>, PromiseReturn>(\n  fn: AsyncFunction<A, PromiseReturn>,\n  label?: string\n): AsyncFunction<A, PromiseReturn>;\nexport default function waitFor<A extends Array<any>, T>(\n  fn: CoroutineFunction<A, T>,\n  label?: string\n): CoroutineFunction<A, T>;\nexport default function waitFor(\n  target: object,\n  _key: string,\n  descriptor: PropertyDescriptor,\n  label?: string\n): PropertyDescriptor;\nexport default function waitFor(\n  ...args: AsyncFunctionArguments | CoroutineFunctionArguments | DecoratorArguments\n): PropertyDescriptor | Function | CoroutineFunction<any[], any> {\n  const isFunction = args.length < 3;\n\n  if (isFunction) {\n    const [fn, label] = args as AsyncFunctionArguments | CoroutineFunctionArguments;\n\n    return wrapFunction(fn, label);\n  } else {\n    const [, , descriptor, label] = args as DecoratorArguments;\n\n    if (macroCondition(!isDevelopingApp())) {\n      return descriptor;\n    }\n\n    const fn = descriptor.value;\n\n    descriptor.value = wrapFunction(fn, label);\n\n    return descriptor;\n  }\n}\n\nfunction wrapFunction(fn: Function, label?: string) {\n  if (macroCondition(!isDevelopingApp())) {\n    return fn;\n  }\n\n  return function (this: any, ...args: any[]) {\n    const result = fn.call(this, ...args);\n\n    if (isThenable(result)) {\n      return waitForPromise(result, label);\n    } else if (isGenerator(result)) {\n      return waitForGenerator(result, label);\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction isThenable(\n  maybePromise: any | PromiseType<unknown>\n): maybePromise is PromiseType<unknown> {\n  const type = typeof maybePromise;\n\n  return (\n    ((maybePromise !== null && type === 'object') || type === 'function') &&\n    typeof maybePromise.then === 'function'\n  );\n}\n\nfunction isGenerator(\n  maybeGenerator: any | CoroutineGenerator<unknown>\n): maybeGenerator is CoroutineGenerator<unknown> {\n  // Because we don't have Symbol.iterator in IE11\n  return (\n    typeof maybeGenerator.next === 'function' &&\n    typeof maybeGenerator.return === 'function' &&\n    typeof maybeGenerator.throw === 'function'\n  );\n}\n\nconst GENERATOR_WAITER = buildWaiter('@ember/test-waiters:generator-waiter');\n\nfunction waitForGenerator<T>(\n  generator: CoroutineGenerator<T>,\n  label?: string\n): CoroutineGenerator<T> {\n  GENERATOR_WAITER.beginAsync(generator, label);\n\n  let isWaiting = true;\n  function stopWaiting() {\n    if (isWaiting) {\n      GENERATOR_WAITER.endAsync(generator);\n      isWaiting = false;\n    }\n  }\n\n  return {\n    next(...args) {\n      let hasErrored = true;\n      try {\n        const val = generator.next(...args);\n        hasErrored = false;\n\n        if (val.done) {\n          stopWaiting();\n        }\n        return val;\n      } finally {\n        // If generator.next() throws, we need to stop waiting. But if we catch\n        // and re-throw exceptions, it could move the location from which the\n        // uncaught exception is thrown, interfering with the developer\n        // debugging experience if they have break-on-exceptions enabled. So we\n        // use a boolean flag and a finally block to emulate a catch block.\n        if (hasErrored) {\n          stopWaiting();\n        }\n      }\n    },\n    return(...args) {\n      stopWaiting();\n      return generator.return(...args);\n    },\n    throw(...args) {\n      stopWaiting();\n      return generator.throw(...args);\n    },\n  } as CoroutineGenerator<T>;\n}\n","import { default as waitForPromise } from './wait-for-promise.ts';\n\nexport async function waitForFetch(fetchPromise: ReturnType<typeof fetch>) {\n  const response = await waitForPromise(fetchPromise);\n\n  return new Proxy(response, {\n    get(target, prop, receiver) {\n      const original = Reflect.get(target, prop, receiver);\n\n      if (\n        typeof prop === 'string' &&\n        ['json', 'text', 'arrayBuffer', 'blob', 'formData', 'bytes'].includes(prop)\n      ) {\n        return (...args: unknown[]) => {\n          return waitForPromise(original.call(target, ...args));\n        };\n      }\n\n      return original;\n    },\n  });\n}\n"],"names":["WAITERS","HAS_SYMBOL","Symbol","symbolName","symbol","for","global","getGlobal","waiters","undefined","Map","indexable","input","globalThis","self","window","Error","register","waiter","set","name","unregister","delete","getWaiters","result","forEach","value","push","_reset","isRegistered","clear","getPendingWaiterState","pending","waitUntil","debugInfo","hasPendingWaiters","state","WAITER_NAME_PATTERN","WAITER_NAMES","macroCondition","isDevelopingApp","Set","_resetWaiterNames","getNextToken","Token","TestWaiterImpl","nextToken","items","completedOperationsForTokens","WeakMap","completedOperationsForPrimitives","constructor","beginAsync","token","label","_register","has","error","stack","endAsync","_getCompletedOperations","size","reset","type","isFunction","isObject","isPrimitive","NoopTestWaiter","buildWaiter","warn","id","add","test","PROMISE_WAITER","waitForPromise","promise","then","waitFor","args","length","fn","wrapFunction","descriptor","call","isThenable","isGenerator","waitForGenerator","maybePromise","maybeGenerator","next","return","throw","GENERATOR_WAITER","generator","isWaiting","stopWaiting","hasErrored","val","done","waitForFetch","fetchPromise","response","Proxy","get","target","prop","receiver","original","Reflect","includes"],"mappings":"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"}