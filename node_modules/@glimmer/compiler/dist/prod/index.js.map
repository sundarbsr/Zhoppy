{"version":3,"file":"index.js","sources":["../../../constants/lib/builder-constants.ts","../../../constants/lib/curried.ts","../../../constants/lib/dom.ts","../../../debug-util/lib/present.ts","../../lib/builder/builder-interface.ts","../../lib/builder/builder.ts","../../lib/passes/2-encoding/mir.ts","../../lib/shared/list.ts","../../lib/shared/result.ts","../../lib/passes/1-normalization/visitors/expressions.ts","../../lib/passes/1-normalization/keywords/impl.ts","../../lib/passes/1-normalization/keywords/utils/call-to-append.ts","../../lib/passes/1-normalization/keywords/utils/curry.ts","../../lib/passes/1-normalization/keywords/utils/dynamic-vars.ts","../../lib/passes/1-normalization/keywords/utils/has-block.ts","../../lib/passes/1-normalization/keywords/utils/if-unless.ts","../../lib/passes/1-normalization/keywords/utils/log.ts","../../lib/passes/1-normalization/keywords/append.ts","../../lib/passes/1-normalization/keywords/block.ts","../../lib/passes/1-normalization/keywords/call.ts","../../lib/passes/1-normalization/keywords/modifier.ts","../../lib/utils.ts","../../lib/passes/1-normalization/visitors/element/classified.ts","../../lib/passes/1-normalization/visitors/element/component.ts","../../lib/passes/1-normalization/visitors/element/simple-element.ts","../../lib/passes/1-normalization/visitors/statements.ts","../../lib/passes/1-normalization/context.ts","../../lib/passes/1-normalization/visitors/constants.ts","../../lib/passes/1-normalization/visitors/strict-mode.ts","../../lib/wire-format-debug.ts","../../lib/passes/2-encoding/expressions.ts","../../lib/passes/2-encoding/content.ts","../../lib/compiler.ts","../../lib/passes/1-normalization/index.ts","../../lib/passes/2-encoding/index.ts"],"sourcesContent":["/// Builder ///\n\nexport type BUILDER_LITERAL = 0;\nexport const BUILDER_LITERAL: BUILDER_LITERAL = 0;\n\nexport type BUILDER_COMMENT = 1;\nexport const BUILDER_COMMENT: BUILDER_COMMENT = 1;\n\nexport type BUILDER_APPEND = 2;\nexport const BUILDER_APPEND: BUILDER_APPEND = 2;\n\nexport type BUILDER_MODIFIER = 3;\nexport const BUILDER_MODIFIER: BUILDER_MODIFIER = 3;\n\nexport type BUILDER_DYNAMIC_COMPONENT = 4;\nexport const BUILDER_DYNAMIC_COMPONENT: BUILDER_DYNAMIC_COMPONENT = 4;\n\nexport type BUILDER_GET = 5;\nexport const BUILDER_GET: BUILDER_GET = 5;\n\nexport type BUILDER_CONCAT = 6;\nexport const BUILDER_CONCAT: BUILDER_CONCAT = 6;\n\nexport type BUILDER_HAS_BLOCK = 7;\nexport const BUILDER_HAS_BLOCK: BUILDER_HAS_BLOCK = 7;\n\nexport type BUILDER_HAS_BLOCK_PARAMS = 8;\nexport const BUILDER_HAS_BLOCK_PARAMS: BUILDER_HAS_BLOCK_PARAMS = 8;\n\n/// HeadKind ///\n\nexport type BLOCK_HEAD = 'Block';\nexport const BLOCK_HEAD: BLOCK_HEAD = 'Block';\n\nexport type CALL_HEAD = 'Call';\nexport const CALL_HEAD: CALL_HEAD = 'Call';\n\nexport type ELEMENT_HEAD = 'Element';\nexport const ELEMENT_HEAD: ELEMENT_HEAD = 'Element';\n\nexport type APPEND_PATH_HEAD = 'AppendPath';\nexport const APPEND_PATH_HEAD: APPEND_PATH_HEAD = 'AppendPath';\n\nexport type APPEND_EXPR_HEAD = 'AppendExpr';\nexport const APPEND_EXPR_HEAD: APPEND_EXPR_HEAD = 'AppendExpr';\n\nexport type LITERAL_HEAD = 'Literal';\nexport const LITERAL_HEAD: LITERAL_HEAD = 'Literal';\n\nexport type MODIFIER_HEAD = 'Modifier';\nexport const MODIFIER_HEAD: MODIFIER_HEAD = 'Modifier';\n\nexport type DYNAMIC_COMPONENT_HEAD = 'DynamicComponent';\nexport const DYNAMIC_COMPONENT_HEAD: DYNAMIC_COMPONENT_HEAD = 'DynamicComponent';\n\nexport type COMMENT_HEAD = 'Comment';\nexport const COMMENT_HEAD: COMMENT_HEAD = 'Comment';\n\nexport type SPLAT_HEAD = 'Splat';\nexport const SPLAT_HEAD: SPLAT_HEAD = 'Splat';\n\nexport type KEYWORD_HEAD = 'Keyword';\nexport const KEYWORD_HEAD: KEYWORD_HEAD = 'Keyword';\n\nexport type HeadKind =\n  | BLOCK_HEAD\n  | CALL_HEAD\n  | ELEMENT_HEAD\n  | APPEND_PATH_HEAD\n  | APPEND_EXPR_HEAD\n  | LITERAL_HEAD\n  | MODIFIER_HEAD\n  | DYNAMIC_COMPONENT_HEAD\n  | COMMENT_HEAD\n  | SPLAT_HEAD\n  | KEYWORD_HEAD;\n\n/// VariableKind ///\n\nexport type LOCAL_VAR = 'Local';\nexport const LOCAL_VAR: LOCAL_VAR = 'Local';\n\nexport type FREE_VAR = 'Free';\nexport const FREE_VAR: FREE_VAR = 'Free';\n\nexport type ARG_VAR = 'Arg';\nexport const ARG_VAR: ARG_VAR = 'Arg';\n\nexport type BLOCK_VAR = 'Block';\nexport const BLOCK_VAR: BLOCK_VAR = 'Block';\n\nexport type THIS_VAR = 'This';\nexport const THIS_VAR: THIS_VAR = 'This';\n\nexport type VariableKind = LOCAL_VAR | FREE_VAR | ARG_VAR | BLOCK_VAR | THIS_VAR;\n\n/// ExpressionKind ///\n\nexport type LITERAL_EXPR = 'Literal';\nexport const LITERAL_EXPR: LITERAL_EXPR = 'Literal';\n\nexport type CALL_EXPR = 'Call';\nexport const CALL_EXPR: CALL_EXPR = 'Call';\n\nexport type GET_PATH_EXPR = 'GetPath';\nexport const GET_PATH_EXPR: GET_PATH_EXPR = 'GetPath';\n\nexport type GET_VAR_EXPR = 'GetVar';\nexport const GET_VAR_EXPR: GET_VAR_EXPR = 'GetVar';\n\nexport type CONCAT_EXPR = 'Concat';\nexport const CONCAT_EXPR: CONCAT_EXPR = 'Concat';\n\nexport type HAS_BLOCK_EXPR = 'HasBlock';\nexport const HAS_BLOCK_EXPR: HAS_BLOCK_EXPR = 'HasBlock';\n\nexport type HAS_BLOCK_PARAMS_EXPR = 'HasBlockParams';\nexport const HAS_BLOCK_PARAMS_EXPR: HAS_BLOCK_PARAMS_EXPR = 'HasBlockParams';\n\nexport type ExpressionKind =\n  | LITERAL_EXPR\n  | CALL_EXPR\n  | GET_PATH_EXPR\n  | GET_VAR_EXPR\n  | CONCAT_EXPR\n  | HAS_BLOCK_EXPR\n  | HAS_BLOCK_PARAMS_EXPR;\n","import type { CurriedComponent, CurriedHelper, CurriedModifier } from '@glimmer/interfaces';\n\nexport const CURRIED_COMPONENT = 0 satisfies CurriedComponent;\nexport const CURRIED_HELPER = 1 satisfies CurriedHelper;\nexport const CURRIED_MODIFIER = 2 satisfies CurriedModifier;\n","import type { InsertPosition, Namespace, NodeType } from '@glimmer/interfaces';\n\nexport const RAW_NODE = -1;\nexport const ELEMENT_NODE: NodeType.ELEMENT_NODE = 1;\nexport const TEXT_NODE: NodeType.TEXT_NODE = 3;\nexport const COMMENT_NODE: NodeType.COMMENT_NODE = 8;\nexport const DOCUMENT_NODE: NodeType.DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE: NodeType.DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE: NodeType.DOCUMENT_FRAGMENT_NODE = 11;\n\nexport const NS_HTML = 'http://www.w3.org/1999/xhtml' as Namespace.HTML;\nexport const NS_MATHML = 'http://www.w3.org/1998/Math/MathML' as Namespace.MathML;\nexport const NS_SVG = 'http://www.w3.org/2000/svg' as Namespace.SVG;\nexport const NS_XLINK = 'http://www.w3.org/1999/xlink' as Namespace.XLink;\nexport const NS_XML = 'http://www.w3.org/XML/1998/namespace' as Namespace.XML;\nexport const NS_XMLNS = 'http://www.w3.org/2000/xmlns/' as Namespace.XMLNS;\n\nexport const INSERT_BEFORE_BEGIN = 'beforebegin' as InsertPosition.beforebegin;\nexport const INSERT_AFTER_BEGIN = 'afterbegin' as InsertPosition.afterbegin;\nexport const INSERT_BEFORE_END = 'beforeend' as InsertPosition.beforeend;\nexport const INSERT_AFTER_END = 'afterend' as InsertPosition.afterend;\n","import type { Nullable, Present, PresentArray } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nexport function isPresent<T>(value: T): value is Present<T> {\n  return value !== null && value !== undefined;\n}\n\nexport function assertPresent<T extends string>(value: T): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message: string): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message?: string): asserts value is Present<T> {\n  if (LOCAL_DEBUG && !isPresent(value)) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    throw new Error(`Expected present, got ${typeof value === 'string' ? value : message!}`);\n  }\n}\n\nexport function isPresentArray<T>(list?: readonly T[]): list is PresentArray<T> {\n  return list ? list.length > 0 : false;\n}\n\nexport function ifPresent<T, U, V>(\n  list: T[],\n  ifPresent: (input: PresentArray<T>) => U,\n  otherwise: () => V\n): U | V {\n  if (isPresentArray(list)) {\n    return ifPresent(list);\n  } else {\n    return otherwise();\n  }\n}\n\nexport function arrayToOption<T>(list: T[]): Nullable<PresentArray<T>> {\n  if (isPresentArray(list)) {\n    return list;\n  } else {\n    return null;\n  }\n}\n\nexport function assertPresentArray<T>(\n  list: T[],\n  message = `unexpected empty list`\n): asserts list is PresentArray<T> {\n  if (LOCAL_DEBUG && !isPresentArray(list)) {\n    throw new Error(message);\n  }\n}\n\nexport function asPresentArray<T>(list: T[], message = `unexpected empty list`): PresentArray<T> {\n  assertPresentArray(list, message);\n  return list;\n}\n\nexport function getLast<T>(list: PresentArray<T>): T;\nexport function getLast<T>(list: T[]): T | undefined;\nexport function getLast<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[list.length - 1] as T);\n}\n\nexport function getFirst<T>(list: PresentArray<T>): T;\nexport function getFirst<T>(list: T[]): T | undefined;\nexport function getFirst<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[0] as T);\n}\n\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T>,\n  mapper: (input: T) => U\n): PresentArray<U>;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null {\n  if (list === null) {\n    return null;\n  }\n  let out: U[] = [];\n\n  for (let item of list) {\n    out.push(mapper(item));\n  }\n\n  return out as PresentArray<U>;\n}\n","import type { VariableKind } from '@glimmer/constants';\nimport type { Dict, DictValue, Nullable, PresentArray } from '@glimmer/interfaces';\nimport {\n  APPEND_EXPR_HEAD,\n  APPEND_PATH_HEAD,\n  ARG_VAR,\n  BLOCK_HEAD,\n  BLOCK_VAR,\n  BUILDER_APPEND,\n  BUILDER_COMMENT,\n  BUILDER_CONCAT,\n  BUILDER_DYNAMIC_COMPONENT,\n  BUILDER_GET,\n  BUILDER_HAS_BLOCK,\n  BUILDER_HAS_BLOCK_PARAMS,\n  BUILDER_LITERAL,\n  BUILDER_MODIFIER,\n  CALL_EXPR,\n  CALL_HEAD,\n  COMMENT_HEAD,\n  CONCAT_EXPR,\n  DYNAMIC_COMPONENT_HEAD,\n  ELEMENT_HEAD,\n  FREE_VAR,\n  GET_PATH_EXPR,\n  GET_VAR_EXPR,\n  HAS_BLOCK_EXPR,\n  HAS_BLOCK_PARAMS_EXPR,\n  KEYWORD_HEAD,\n  LITERAL_EXPR,\n  LITERAL_HEAD,\n  LOCAL_VAR,\n  MODIFIER_HEAD,\n  SPLAT_HEAD,\n  THIS_VAR,\n} from '@glimmer/constants';\nimport { expect, isPresentArray } from '@glimmer/debug-util';\nimport { assertNever, dict } from '@glimmer/util';\n\nexport type BuilderParams = BuilderExpression[];\nexport type BuilderHash = Nullable<Dict<BuilderExpression>>;\nexport type BuilderBlockHash = BuilderHash | { as: string | string[] };\nexport type BuilderBlocks = Dict<BuilderBlock>;\nexport type BuilderAttrs = Dict<BuilderAttr>;\n\nexport type NormalizedParams = NormalizedExpression[];\nexport type NormalizedHash = Dict<NormalizedExpression>;\nexport type NormalizedBlock = NormalizedStatement[];\nexport type NormalizedBlocks = Dict<NormalizedBlock>;\nexport type NormalizedAttrs = Dict<NormalizedAttr>;\nexport type NormalizedAttr = SPLAT_HEAD | NormalizedExpression;\n\nexport interface NormalizedElement {\n  name: string;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport interface NormalizedAngleInvocation {\n  head: NormalizedExpression;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport interface Variable {\n  kind: VariableKind;\n  name: string;\n  /**\n   * Differences:\n   *\n   * - strict mode variables always refer to in-scope variables\n   * - loose mode variables use this algorithm:\n   *   1. otherwise, fall back to `this.<name>`\n   */\n  mode: 'loose' | 'strict';\n}\n\nexport interface Path {\n  head: Variable;\n  tail: PresentArray<string>;\n}\n\nexport interface AppendExpr {\n  kind: APPEND_EXPR_HEAD;\n  expr: NormalizedExpression;\n  trusted: boolean;\n}\n\nexport interface AppendPath {\n  kind: APPEND_PATH_HEAD;\n  path: NormalizedPath;\n  trusted: boolean;\n}\n\nexport interface NormalizedKeywordStatement {\n  kind: KEYWORD_HEAD;\n  name: string;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport type NormalizedStatement =\n  | {\n      kind: CALL_HEAD;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      trusted: boolean;\n    }\n  | {\n      kind: BLOCK_HEAD;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      blockParams: Nullable<string[]>;\n      blocks: NormalizedBlocks;\n    }\n  | NormalizedKeywordStatement\n  | {\n      kind: ELEMENT_HEAD;\n      name: string;\n      attrs: NormalizedAttrs;\n      block: NormalizedBlock;\n    }\n  | { kind: COMMENT_HEAD; value: string }\n  | { kind: LITERAL_HEAD; value: string }\n  | AppendPath\n  | AppendExpr\n  | { kind: MODIFIER_HEAD; params: NormalizedParams; hash: Nullable<NormalizedHash> }\n  | {\n      kind: DYNAMIC_COMPONENT_HEAD;\n      expr: NormalizedExpression;\n      hash: Nullable<NormalizedHash>;\n      block: NormalizedBlock;\n    };\n\nexport function normalizeStatement(statement: BuilderStatement): NormalizedStatement {\n  if (Array.isArray(statement)) {\n    if (statementIsExpression(statement)) {\n      return normalizeAppendExpression(statement);\n    } else if (isSugaryArrayStatement(statement)) {\n      return normalizeSugaryArrayStatement(statement);\n    } else {\n      return normalizeVerboseStatement(statement);\n    }\n  } else if (typeof statement === 'string') {\n    return normalizeAppendHead(normalizeDottedPath(statement), false);\n  } else {\n    assertNever(statement);\n  }\n}\n\nexport function normalizeAppendHead(\n  head: NormalizedHead,\n  trusted: boolean\n): AppendExpr | AppendPath {\n  if (head.type === GET_PATH_EXPR) {\n    return {\n      kind: APPEND_PATH_HEAD,\n      path: head,\n      trusted,\n    };\n  } else {\n    return {\n      kind: APPEND_EXPR_HEAD,\n      expr: head,\n      trusted,\n    };\n  }\n}\n\nfunction isSugaryArrayStatement(statement: BuilderStatement): statement is SugaryArrayStatement {\n  if (Array.isArray(statement) && typeof statement[0] === 'string') {\n    switch (statement[0][0]) {\n      case '(':\n      case '#':\n      case '<':\n      case '!':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\nexport type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;\n\nexport function normalizeSugaryArrayStatement(\n  statement: SugaryArrayStatement\n): NormalizedStatement {\n  const name = statement[0];\n\n  switch (name[0]) {\n    case '(': {\n      let params: Nullable<NormalizedParams> = null;\n      let hash: Nullable<NormalizedHash> = null;\n\n      if (statement.length === 3) {\n        params = normalizeParams(statement[1] as Params);\n        hash = normalizeHash(statement[2] as Hash);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          params = normalizeParams(statement[1] as Params);\n        } else {\n          hash = normalizeHash(statement[1] as Hash);\n        }\n      }\n\n      return {\n        kind: CALL_HEAD,\n        head: normalizeCallHead(name),\n        params,\n        hash,\n        trusted: false,\n      };\n    }\n\n    case '#': {\n      const {\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      } = normalizeBuilderBlockStatement(statement as BuilderBlockStatement);\n\n      return {\n        kind: BLOCK_HEAD,\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '!': {\n      const name = statement[0].slice(1);\n      const { params, hash, blocks, blockParams } = normalizeBuilderBlockStatement(\n        statement as BuilderBlockStatement\n      );\n\n      return {\n        kind: KEYWORD_HEAD,\n        name,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '<': {\n      let attrs: NormalizedAttrs = dict();\n      let block: NormalizedBlock = [];\n\n      if (statement.length === 3) {\n        attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        block = normalizeBlock(statement[2] as BuilderBlock);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          block = normalizeBlock(statement[1] as BuilderBlock);\n        } else {\n          attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        }\n      }\n\n      return {\n        kind: ELEMENT_HEAD,\n        name: expect(extractElement(name), `BUG: expected ${name} to look like a tag name`),\n        attrs,\n        block,\n      };\n    }\n\n    default:\n      throw new Error(`Unreachable ${JSON.stringify(statement)} in normalizeSugaryArrayStatement`);\n  }\n}\n\nfunction normalizeVerboseStatement(statement: VerboseStatement): NormalizedStatement {\n  switch (statement[0]) {\n    case BUILDER_LITERAL: {\n      return {\n        kind: LITERAL_HEAD,\n        value: statement[1],\n      };\n    }\n\n    case BUILDER_APPEND: {\n      return normalizeAppendExpression(statement[1], statement[2]);\n    }\n\n    case BUILDER_MODIFIER: {\n      return {\n        kind: MODIFIER_HEAD,\n        params: normalizeParams(statement[1]),\n        hash: normalizeHash(statement[2]),\n      };\n    }\n\n    case BUILDER_DYNAMIC_COMPONENT: {\n      return {\n        kind: DYNAMIC_COMPONENT_HEAD,\n        expr: normalizeExpression(statement[1]),\n        hash: normalizeHash(statement[2]),\n        block: normalizeBlock(statement[3]),\n      };\n    }\n\n    case BUILDER_COMMENT: {\n      return {\n        kind: COMMENT_HEAD,\n        value: statement[1],\n      };\n    }\n  }\n}\n\nfunction extractBlockHead(name: string): NormalizedHead {\n  const result = /^(#|!)(.*)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing # in block head`);\n  }\n\n  return normalizeDottedPath(result[2] as string);\n}\n\nfunction normalizeCallHead(name: string): NormalizedHead {\n  const result = /^\\((.*)\\)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing () in call head`);\n  }\n\n  return normalizeDottedPath(result[1] as string);\n}\n\nfunction normalizePath(head: string, tail: string[] = []): NormalizedHead {\n  const pathHead = normalizePathHead(head);\n\n  if (isPresentArray(tail)) {\n    return {\n      type: GET_PATH_EXPR,\n      path: {\n        head: pathHead,\n        tail,\n      },\n    };\n  } else {\n    return {\n      type: GET_VAR_EXPR,\n      variable: pathHead,\n    };\n  }\n}\n\nfunction normalizeDottedPath(whole: string): NormalizedHead {\n  const { kind, name: rest } = normalizePathHead(whole);\n\n  const [name, ...tail] = rest.split('.') as [string, ...string[]];\n\n  const variable: Variable = { kind, name, mode: 'loose' };\n\n  if (isPresentArray(tail)) {\n    return { type: GET_PATH_EXPR, path: { head: variable, tail } };\n  } else {\n    return { type: GET_VAR_EXPR, variable };\n  }\n}\n\nexport function normalizePathHead(whole: string): Variable {\n  let kind: VariableKind;\n  let name: string;\n\n  if (/^this(?:\\.|$)/u.test(whole)) {\n    return {\n      kind: THIS_VAR,\n      name: whole,\n      mode: 'loose',\n    };\n  }\n\n  switch (whole[0]) {\n    case '^':\n      kind = FREE_VAR;\n      name = whole.slice(1);\n      break;\n\n    case '@':\n      kind = ARG_VAR;\n      name = whole.slice(1);\n      break;\n\n    case '&':\n      kind = BLOCK_VAR;\n      name = whole.slice(1);\n      break;\n\n    default:\n      kind = LOCAL_VAR;\n      name = whole;\n  }\n\n  return { kind, name, mode: 'loose' };\n}\n\nexport type BuilderBlockStatement =\n  | [string, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams | BuilderBlockHash, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams, BuilderBlockHash, BuilderBlock | BuilderBlocks];\n\nexport interface NormalizedBuilderBlockStatement {\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport function normalizeBuilderBlockStatement(\n  statement: BuilderBlockStatement\n): NormalizedBuilderBlockStatement {\n  const head = statement[0];\n  let blocks: NormalizedBlocks = dict();\n  let params: Nullable<NormalizedParams> = null;\n  let hash: Nullable<NormalizedHash> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  if (statement.length === 2) {\n    blocks = normalizeBlocks(statement[1]);\n  } else if (statement.length === 3) {\n    if (Array.isArray(statement[1])) {\n      params = normalizeParams(statement[1]);\n    } else {\n      ({ hash, blockParams } = normalizeBlockHash(statement[1]));\n    }\n\n    blocks = normalizeBlocks(statement[2]);\n  } else {\n    params = normalizeParams(statement[1]);\n    ({ hash, blockParams } = normalizeBlockHash(statement[2]));\n    blocks = normalizeBlocks(statement[3]);\n  }\n\n  return {\n    head: extractBlockHead(head),\n    params,\n    hash,\n    blockParams,\n    blocks,\n  };\n}\n\nfunction normalizeBlockHash(hash: BuilderBlockHash): {\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n} {\n  if (hash === null) {\n    return { hash: null, blockParams: null };\n  }\n\n  let out: Nullable<Dict<NormalizedExpression>> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  entries(hash, (key, value) => {\n    if (key === 'as') {\n      blockParams = Array.isArray(value) ? (value as string[]) : [value as string];\n    } else {\n      out = out || dict();\n      out[key] = normalizeExpression(value as BuilderExpression);\n    }\n  });\n\n  return { hash: out, blockParams };\n}\n\ntype Entry<T> = {\n  [K in keyof T]: [K, T[K]];\n}[keyof T];\n\nexport function entries<D extends Dict>(dict: D, callback: (...entry: Entry<D>) => void): void {\n  Object.keys(dict).forEach((key) => {\n    const value = dict[key];\n    callback(key, value as D[keyof D]);\n  });\n}\n\nfunction normalizeBlocks(value: BuilderBlock | BuilderBlocks): NormalizedBlocks {\n  if (Array.isArray(value)) {\n    return { default: normalizeBlock(value) };\n  } else {\n    return mapObject(value, normalizeBlock);\n  }\n}\n\nfunction normalizeBlock(block: BuilderBlock): NormalizedBlock {\n  return block.map((s) => normalizeStatement(s));\n}\n\nfunction normalizeAttrs(attrs: BuilderAttrs): NormalizedAttrs {\n  return mapObject(attrs, (a) => normalizeAttr(a).expr);\n}\n\nfunction normalizeAttr(attr: BuilderAttr): { expr: NormalizedAttr; trusted: boolean } {\n  if (attr === 'splat') {\n    return { expr: SPLAT_HEAD, trusted: false };\n  } else {\n    const expr = normalizeExpression(attr);\n    return { expr, trusted: false };\n  }\n}\n\nfunction mapObject<T extends Dict, Out>(\n  object: T,\n  mapper: (value: DictValue<T>, key: keyof T) => Out\n): { [P in keyof T]: Out } {\n  const out = dict() as { [P in keyof T]?: Out };\n\n  Object.keys(object).forEach(<K extends keyof T>(k: K) => {\n    out[k] = mapper(object[k] as DictValue<T>, k);\n  });\n\n  return out as { [P in keyof T]: Out };\n}\n\nexport type BuilderElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport type BuilderComment = [BUILDER_COMMENT, string];\n\nexport type InvocationElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport function isElement(input: [string, ...unknown[]]): input is BuilderElement {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function extractElement(input: string): Nullable<string> {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input);\n\n  return match?.[1] ?? null;\n}\n\nexport function isAngleInvocation(input: [string, ...unknown[]]): input is InvocationElement {\n  // TODO Paths\n  const match = /^<(@[\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function isBlock(input: [string, ...unknown[]]): input is BuilderBlockStatement {\n  // TODO Paths\n  const match = /^#[\\s\\S]?([\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport type VerboseStatement =\n  | [BUILDER_LITERAL, string]\n  | [BUILDER_COMMENT, string]\n  | [BUILDER_APPEND, BuilderExpression, true]\n  | [BUILDER_APPEND, BuilderExpression]\n  | [BUILDER_MODIFIER, Params, Hash]\n  | [BUILDER_DYNAMIC_COMPONENT, BuilderExpression, Hash, BuilderBlock];\n\nexport type BuilderStatement =\n  | VerboseStatement\n  | SugaryArrayStatement\n  | TupleBuilderExpression\n  | string;\n\n/**\n * The special value 'splat' is used to indicate that the attribute is a splat\n */\nexport type BuilderAttr = BuilderExpression;\n\nexport type TupleBuilderExpression =\n  | [BUILDER_LITERAL, string | boolean | null | undefined]\n  | [BUILDER_GET, string]\n  | [BUILDER_GET, string, string[]]\n  | [BUILDER_CONCAT, ...BuilderExpression[]]\n  | [BUILDER_HAS_BLOCK, string]\n  | [BUILDER_HAS_BLOCK_PARAMS, string]\n  | BuilderCallExpression;\n\ntype Params = BuilderParams;\ntype Hash = Dict<BuilderExpression>;\n\nexport interface NormalizedCallExpression {\n  type: CALL_EXPR;\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n}\n\nexport interface NormalizedPath {\n  type: GET_PATH_EXPR;\n  path: Path;\n}\n\nexport interface NormalizedVar {\n  type: GET_VAR_EXPR;\n  variable: Variable;\n}\n\nexport type NormalizedHead = NormalizedPath | NormalizedVar;\n\nexport interface NormalizedConcat {\n  type: CONCAT_EXPR;\n  params: [NormalizedExpression, ...NormalizedExpression[]];\n}\n\nexport type NormalizedExpression =\n  | {\n      type: LITERAL_EXPR;\n      value: null | undefined | boolean | string | number;\n    }\n  | NormalizedCallExpression\n  | NormalizedPath\n  | NormalizedVar\n  | NormalizedConcat\n  | {\n      type: HAS_BLOCK_EXPR;\n      name: string;\n    }\n  | {\n      type: HAS_BLOCK_PARAMS_EXPR;\n      name: string;\n    };\n\nexport function normalizeAppendExpression(\n  expression: BuilderExpression,\n  forceTrusted = false\n): AppendExpr | AppendPath {\n  if (expression === null || expression === undefined) {\n    return {\n      expr: {\n        type: LITERAL_EXPR,\n        value: expression,\n      },\n      kind: APPEND_EXPR_HEAD,\n      trusted: false,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case BUILDER_LITERAL:\n        return {\n          expr: { type: LITERAL_EXPR, value: expression[1] },\n          kind: APPEND_EXPR_HEAD,\n          trusted: false,\n        };\n\n      case BUILDER_GET: {\n        return normalizeAppendHead(normalizePath(expression[1], expression[2]), forceTrusted);\n      }\n      case BUILDER_CONCAT: {\n        const expr: NormalizedConcat = {\n          type: CONCAT_EXPR,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return {\n          expr,\n          kind: APPEND_EXPR_HEAD,\n          trusted: forceTrusted,\n        };\n      }\n\n      case BUILDER_HAS_BLOCK:\n        return {\n          expr: {\n            type: HAS_BLOCK_EXPR,\n            name: expression[1],\n          },\n          kind: APPEND_EXPR_HEAD,\n          trusted: forceTrusted,\n        };\n\n      case BUILDER_HAS_BLOCK_PARAMS:\n        return {\n          expr: {\n            type: HAS_BLOCK_PARAMS_EXPR,\n            name: expression[1],\n          },\n          kind: APPEND_EXPR_HEAD,\n          trusted: forceTrusted,\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return {\n            expr: normalizeCallExpression(expression),\n            kind: APPEND_EXPR_HEAD,\n            trusted: forceTrusted,\n          };\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeAppendHead(normalizeDottedPath(expression), forceTrusted);\n      }\n      case 'boolean':\n      case 'number':\n        return {\n          expr: { type: LITERAL_EXPR, value: expression },\n          kind: APPEND_EXPR_HEAD,\n          trusted: true,\n        };\n\n      default:\n        assertNever(expression);\n    }\n  } else {\n    assertNever(expression);\n  }\n}\n\nexport function normalizeExpression(expression: BuilderExpression): NormalizedExpression {\n  if (expression === null || expression === undefined) {\n    return {\n      type: LITERAL_EXPR,\n      value: expression,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case BUILDER_LITERAL:\n        return { type: LITERAL_EXPR, value: expression[1] };\n\n      case BUILDER_GET: {\n        return normalizePath(expression[1], expression[2]);\n      }\n      case BUILDER_CONCAT: {\n        const expr: NormalizedConcat = {\n          type: CONCAT_EXPR,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return expr;\n      }\n\n      case BUILDER_HAS_BLOCK:\n        return {\n          type: HAS_BLOCK_EXPR,\n          name: expression[1],\n        };\n\n      case BUILDER_HAS_BLOCK_PARAMS:\n        return {\n          type: HAS_BLOCK_PARAMS_EXPR,\n          name: expression[1],\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return normalizeCallExpression(expression);\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeDottedPath(expression);\n      }\n      case 'boolean':\n      case 'number':\n        return { type: LITERAL_EXPR, value: expression };\n\n      default:\n        assertNever(expression);\n    }\n  } else {\n    assertNever(expression);\n  }\n}\n\n// | [GET, string]\n// | [GET, string, string[]]\n// | [CONCAT, Params]\n// | [HAS_BLOCK, string]\n// | [HAS_BLOCK_PARAMS, string]\n\nexport type BuilderExpression =\n  | TupleBuilderExpression\n  | BuilderCallExpression\n  | null\n  | undefined\n  | boolean\n  | string\n  | number;\n\nexport function isBuilderExpression(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is TupleBuilderExpression | BuilderCallExpression {\n  return Array.isArray(expr);\n}\n\nexport function isLiteral(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is [BUILDER_LITERAL, string | boolean | undefined] {\n  return Array.isArray(expr) && expr[0] === 'literal';\n}\n\nexport function statementIsExpression(\n  statement: BuilderStatement\n): statement is TupleBuilderExpression {\n  if (!Array.isArray(statement)) {\n    return false;\n  }\n\n  const name = statement[0];\n\n  if (typeof name === 'number') {\n    switch (name) {\n      case BUILDER_LITERAL:\n      case BUILDER_GET:\n      case BUILDER_CONCAT:\n      case BUILDER_HAS_BLOCK:\n      case BUILDER_HAS_BLOCK_PARAMS:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  if (name[0] === '(') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isBuilderCallExpression(\n  value: TupleBuilderExpression | BuilderCallExpression\n): value is BuilderCallExpression {\n  return typeof value[0] === 'string' && value[0][0] === '(';\n}\n\nexport type MiniBuilderBlock = BuilderStatement[];\n\nexport type BuilderBlock = MiniBuilderBlock;\n\nexport type BuilderCallExpression = [string] | [string, Params | Hash] | [string, Params, Hash];\n\nexport function normalizeParams(input: Params): NormalizedParams {\n  return input.map(normalizeExpression);\n}\n\nexport function normalizeHash(input: Nullable<Hash>): Nullable<NormalizedHash> {\n  if (input === null) return null;\n  return mapObject(input, normalizeExpression);\n}\n\nexport function normalizeCallExpression(expr: BuilderCallExpression): NormalizedCallExpression {\n  switch (expr.length) {\n    case 1:\n      return {\n        type: CALL_EXPR,\n        head: normalizeCallHead(expr[0]),\n        params: null,\n        hash: null,\n      };\n    case 2: {\n      if (Array.isArray(expr[1])) {\n        return {\n          type: CALL_EXPR,\n          head: normalizeCallHead(expr[0]),\n          params: normalizeParams(expr[1]),\n          hash: null,\n        };\n      } else {\n        return {\n          type: CALL_EXPR,\n          head: normalizeCallHead(expr[0]),\n          params: null,\n          hash: normalizeHash(expr[1]),\n        };\n      }\n    }\n\n    case 3:\n      return {\n        type: CALL_EXPR,\n        head: normalizeCallHead(expr[0]),\n        params: normalizeParams(expr[1]),\n        hash: normalizeHash(expr[2]),\n      };\n  }\n}\n","import type { VariableKind } from '@glimmer/constants';\nimport type {\n  AttrNamespace,\n  Dict,\n  Expressions,\n  GetContextualFreeOpcode,\n  Nullable,\n  PresentArray,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport {\n  APPEND_EXPR_HEAD,\n  APPEND_PATH_HEAD,\n  ARG_VAR,\n  BLOCK_HEAD,\n  BLOCK_VAR,\n  BUILDER_COMMENT,\n  BUILDER_LITERAL,\n  CALL_EXPR,\n  CALL_HEAD,\n  COMMENT_HEAD,\n  CONCAT_EXPR,\n  DYNAMIC_COMPONENT_HEAD,\n  ELEMENT_HEAD,\n  FREE_VAR,\n  GET_PATH_EXPR,\n  GET_VAR_EXPR,\n  HAS_BLOCK_EXPR,\n  HAS_BLOCK_PARAMS_EXPR,\n  KEYWORD_HEAD,\n  LITERAL_EXPR,\n  LITERAL_HEAD,\n  LOCAL_VAR,\n  MODIFIER_HEAD,\n  NS_XLINK,\n  NS_XML,\n  NS_XMLNS,\n  SPLAT_HEAD,\n  THIS_VAR,\n} from '@glimmer/constants';\nimport { exhausted, expect, isPresentArray, localAssert } from '@glimmer/debug-util';\nimport { assertNever, dict, values } from '@glimmer/util';\nimport { SexpOpcodes as Op, VariableResolutionContext } from '@glimmer/wire-format';\n\nimport type {\n  BuilderComment,\n  BuilderStatement,\n  NormalizedAngleInvocation,\n  NormalizedAttrs,\n  NormalizedBlock,\n  NormalizedBlocks,\n  NormalizedElement,\n  NormalizedExpression,\n  NormalizedHash,\n  NormalizedHead,\n  NormalizedKeywordStatement,\n  NormalizedParams,\n  NormalizedPath,\n  NormalizedStatement,\n  Variable,\n} from './builder-interface';\n\nimport { normalizeStatement } from './builder-interface';\n\ninterface Symbols {\n  top: ProgramSymbols;\n  freeVar(name: string): number;\n  arg(name: string): number;\n  block(name: string): number;\n  local(name: string): number;\n  this(): number;\n\n  hasLocal(name: string): boolean;\n\n  child(params: string[]): LocalSymbols;\n}\n\nexport class ProgramSymbols implements Symbols {\n  _freeVariables: string[] = [];\n  _symbols: string[] = ['this'];\n\n  top = this;\n\n  toSymbols(): string[] {\n    return this._symbols.slice(1);\n  }\n\n  toUpvars(): string[] {\n    return this._freeVariables;\n  }\n\n  freeVar(name: string): number {\n    return addString(this._freeVariables, name);\n  }\n\n  block(name: string): number {\n    return this.symbol(name);\n  }\n\n  arg(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  local(name: string): never {\n    throw new Error(\n      `No local ${name} was found. Maybe you meant ^${name} for upvar, or !${name} for keyword?`\n    );\n  }\n\n  this(): number {\n    return 0;\n  }\n\n  hasLocal(_name: string): false {\n    return false;\n  }\n\n  // any symbol\n  symbol(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nclass LocalSymbols implements Symbols {\n  private locals: Dict<number> = dict();\n\n  constructor(\n    private parent: Symbols,\n    locals: string[]\n  ) {\n    for (let local of locals) {\n      this.locals[local] = parent.top.symbol(local);\n    }\n  }\n\n  get paramSymbols(): number[] {\n    return values(this.locals);\n  }\n\n  get top(): ProgramSymbols {\n    return this.parent.top;\n  }\n\n  freeVar(name: string): number {\n    return this.parent.freeVar(name);\n  }\n\n  arg(name: string): number {\n    return this.parent.arg(name);\n  }\n\n  block(name: string): number {\n    return this.parent.block(name);\n  }\n\n  local(name: string): number {\n    if (name in this.locals) {\n      return this.locals[name] as number;\n    } else {\n      return this.parent.local(name);\n    }\n  }\n\n  this(): number {\n    return this.parent.this();\n  }\n\n  hasLocal(name: string): boolean {\n    if (name in this.locals) {\n      return true;\n    } else {\n      return this.parent.hasLocal(name);\n    }\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nfunction addString(array: string[], item: string): number {\n  let index = array.indexOf(item);\n\n  if (index === -1) {\n    index = array.length;\n    array.push(item);\n    return index;\n  } else {\n    return index;\n  }\n}\n\nexport interface BuilderGetFree {\n  type: 'GetFree';\n  head: string;\n  tail: string[];\n}\n\nfunction unimpl(message: string): Error {\n  return new Error(`unimplemented ${message}`);\n}\n\nexport function buildStatements(\n  statements: BuilderStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(normalizeStatement(s), symbols)));\n\n  return out;\n}\n\nexport function buildNormalizedStatements(\n  statements: NormalizedStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(s, symbols)));\n\n  return out;\n}\n\nexport function buildStatement(\n  normalized: NormalizedStatement,\n  symbols: Symbols = new ProgramSymbols()\n): WireFormat.Statement[] {\n  switch (normalized.kind) {\n    case APPEND_PATH_HEAD: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildGetPath(normalized.path, symbols),\n        ],\n      ];\n    }\n\n    case APPEND_EXPR_HEAD: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildExpression(\n            normalized.expr,\n            normalized.trusted ? 'TrustedAppend' : 'Append',\n            symbols\n          ),\n        ],\n      ];\n    }\n\n    case CALL_HEAD: {\n      let { head: path, params, hash, trusted } = normalized;\n      let builtParams: Nullable<WireFormat.Core.Params> = params\n        ? buildParams(params, symbols)\n        : null;\n      let builtHash: WireFormat.Core.Hash = hash ? buildHash(hash, symbols) : null;\n      let builtExpr: WireFormat.Expression = buildCallHead(\n        path,\n        trusted\n          ? VariableResolutionContext.ResolveAsHelperHead\n          : VariableResolutionContext.ResolveAsComponentOrHelperHead,\n        symbols\n      );\n\n      return [\n        [trusted ? Op.TrustingAppend : Op.Append, [Op.Call, builtExpr, builtParams, builtHash]],\n      ];\n    }\n\n    case LITERAL_HEAD: {\n      return [[Op.Append, normalized.value]];\n    }\n\n    case COMMENT_HEAD: {\n      return [[Op.Comment, normalized.value]];\n    }\n\n    case BLOCK_HEAD: {\n      let blocks = buildBlocks(normalized.blocks, normalized.blockParams, symbols);\n      let hash = buildHash(normalized.hash, symbols);\n      let params = buildParams(normalized.params, symbols);\n      let path = buildCallHead(\n        normalized.head,\n        VariableResolutionContext.ResolveAsComponentHead,\n        symbols\n      );\n\n      return [[Op.Block, path, params, hash, blocks]];\n    }\n\n    case KEYWORD_HEAD: {\n      return [buildKeyword(normalized, symbols)];\n    }\n\n    case ELEMENT_HEAD:\n      return buildElement(normalized, symbols);\n\n    case MODIFIER_HEAD:\n      throw unimpl('modifier');\n\n    case DYNAMIC_COMPONENT_HEAD:\n      throw unimpl('dynamic component');\n\n    default:\n      assertNever(normalized);\n  }\n}\n\nexport function s(\n  arr: TemplateStringsArray,\n  ...interpolated: unknown[]\n): [BUILDER_LITERAL, string] {\n  let result = arr.reduce(\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [BUILDER_LITERAL, result];\n}\n\nexport function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment {\n  let result = arr.reduce(\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [BUILDER_COMMENT, result];\n}\n\nexport function unicode(charCode: string): string {\n  return String.fromCharCode(parseInt(charCode, 16));\n}\n\nexport const NEWLINE = '\\n';\n\nfunction buildKeyword(\n  normalized: NormalizedKeywordStatement,\n  symbols: Symbols\n): WireFormat.Statement {\n  let { name } = normalized;\n  let params = buildParams(normalized.params, symbols);\n  let childSymbols = symbols.child(normalized.blockParams || []);\n\n  let block = buildBlock(\n    normalized.blocks['default'] as NormalizedBlock,\n    childSymbols,\n    childSymbols.paramSymbols\n  );\n  let inverse = normalized.blocks['else']\n    ? buildBlock(normalized.blocks['else'], symbols, [])\n    : null;\n\n  switch (name) {\n    case 'let':\n      return [Op.Let, expect(params, 'let requires params'), block];\n    case 'if':\n      return [Op.If, expect(params, 'if requires params')[0], block, inverse];\n    case 'each': {\n      let keyExpr = normalized.hash ? normalized.hash['key'] : null;\n      let key = keyExpr ? buildExpression(keyExpr, 'Strict', symbols) : null;\n      return [Op.Each, expect(params, 'if requires params')[0], key, block, inverse];\n    }\n\n    default:\n      throw new Error('unimplemented keyword');\n  }\n}\n\nfunction buildElement(\n  { name, attrs, block }: NormalizedElement,\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [\n    hasSplat(attrs) ? [Op.OpenElementWithSplat, name] : [Op.OpenElement, name],\n  ];\n  if (attrs) {\n    let { params, args } = buildElementParams(attrs, symbols);\n    out.push(...params);\n    localAssert(args === null, `Can't pass args to a simple element`);\n  }\n  out.push([Op.FlushElement]);\n\n  if (Array.isArray(block)) {\n    block.forEach((s) => out.push(...buildStatement(s, symbols)));\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    localAssert(block === null, `The only remaining type of 'block' is 'null'`);\n  }\n\n  out.push([Op.CloseElement]);\n\n  return out;\n}\n\nfunction hasSplat(attrs: Nullable<NormalizedAttrs>): boolean {\n  if (attrs === null) return false;\n\n  return Object.keys(attrs).some((a) => attrs[a] === SPLAT_HEAD);\n}\n\nexport function buildAngleInvocation(\n  { attrs, block, head }: NormalizedAngleInvocation,\n  symbols: Symbols\n): WireFormat.Statements.Component {\n  let paramList: WireFormat.ElementParameter[] = [];\n  let args: WireFormat.Core.Hash = null;\n  let blockList: WireFormat.Statement[] = [];\n\n  if (attrs) {\n    let built = buildElementParams(attrs, symbols);\n    paramList = built.params;\n    args = built.args;\n  }\n\n  if (block) blockList = buildNormalizedStatements(block, symbols);\n\n  return [\n    Op.Component,\n    buildExpression(head, VariableResolutionContext.ResolveAsComponentHead, symbols),\n    isPresentArray(paramList) ? paramList : null,\n    args,\n    [['default'], [[blockList, []]]],\n  ];\n}\n\nexport function buildElementParams(\n  attrs: NormalizedAttrs,\n  symbols: Symbols\n): { params: WireFormat.ElementParameter[]; args: WireFormat.Core.Hash } {\n  let params: WireFormat.ElementParameter[] = [];\n  let keys: string[] = [];\n  let values: WireFormat.Expression[] = [];\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (value === SPLAT_HEAD) {\n      params.push([Op.AttrSplat, symbols.block('&attrs')]);\n    } else if (key[0] === '@') {\n      keys.push(key);\n      values.push(buildExpression(value, 'Strict', symbols));\n    } else {\n      params.push(\n        ...buildAttributeValue(\n          key,\n          value,\n          // TODO: extract namespace from key\n          extractNamespace(key),\n          symbols\n        )\n      );\n    }\n  }\n\n  return { params, args: isPresentArray(keys) && isPresentArray(values) ? [keys, values] : null };\n}\n\nexport function extractNamespace(name: string): Nullable<AttrNamespace> {\n  if (name === 'xmlns') {\n    return NS_XMLNS;\n  }\n\n  let match = /^([^:]*):([^:]*)$/u.exec(name);\n\n  if (match === null) {\n    return null;\n  }\n\n  let namespace = match[1];\n\n  switch (namespace) {\n    case 'xlink':\n      return NS_XLINK;\n    case 'xml':\n      return NS_XML;\n    case 'xmlns':\n      return NS_XMLNS;\n  }\n\n  return null;\n}\n\nexport function buildAttributeValue(\n  name: string,\n  value: NormalizedExpression,\n  namespace: Nullable<AttrNamespace>,\n  symbols: Symbols\n): WireFormat.Attribute[] {\n  switch (value.type) {\n    case LITERAL_EXPR: {\n      let val = value.value;\n\n      if (val === false) {\n        return [];\n      } else if (val === true) {\n        return [[Op.StaticAttr, name, '', namespace ?? undefined]];\n      } else if (typeof val === 'string') {\n        return [[Op.StaticAttr, name, val, namespace ?? undefined]];\n      } else {\n        throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(val)}`);\n      }\n    }\n\n    default:\n      return [\n        [\n          Op.DynamicAttr,\n          name,\n          buildExpression(value, 'AttrValue', symbols),\n          namespace ?? undefined,\n        ],\n      ];\n  }\n}\n\ntype ExprResolution =\n  | VariableResolutionContext\n  | 'Append'\n  | 'TrustedAppend'\n  | 'AttrValue'\n  | 'SubExpression'\n  | 'Strict';\n\nfunction varContext(context: ExprResolution, bare: boolean): VarResolution {\n  switch (context) {\n    case 'Append':\n      return bare ? 'AppendBare' : 'AppendInvoke';\n    case 'TrustedAppend':\n      return bare ? 'TrustedAppendBare' : 'TrustedAppendInvoke';\n    case 'AttrValue':\n      return bare ? 'AttrValueBare' : 'AttrValueInvoke';\n    default:\n      return context;\n  }\n}\n\nexport function buildExpression(\n  expr: NormalizedExpression,\n  context: ExprResolution,\n  symbols: Symbols\n): WireFormat.Expression {\n  switch (expr.type) {\n    case GET_PATH_EXPR: {\n      return buildGetPath(expr, symbols);\n    }\n\n    case GET_VAR_EXPR: {\n      return buildVar(expr.variable, varContext(context, true), symbols);\n    }\n\n    case CONCAT_EXPR: {\n      return [Op.Concat, buildConcat(expr.params, symbols)];\n    }\n\n    case CALL_EXPR: {\n      let builtParams = buildParams(expr.params, symbols);\n      let builtHash = buildHash(expr.hash, symbols);\n      let builtExpr = buildCallHead(\n        expr.head,\n        context === 'Strict' ? 'SubExpression' : varContext(context, false),\n        symbols\n      );\n\n      return [Op.Call, builtExpr, builtParams, builtHash];\n    }\n\n    case HAS_BLOCK_EXPR: {\n      return [\n        Op.HasBlock,\n        buildVar(\n          { kind: BLOCK_VAR, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case HAS_BLOCK_PARAMS_EXPR: {\n      return [\n        Op.HasBlockParams,\n        buildVar(\n          { kind: BLOCK_VAR, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case LITERAL_EXPR: {\n      if (expr.value === undefined) {\n        return [Op.Undefined];\n      } else {\n        return expr.value;\n      }\n    }\n\n    default:\n      assertNever(expr);\n  }\n}\n\nexport function buildCallHead(\n  callHead: NormalizedHead,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar | Expressions.GetPath {\n  if (callHead.type === GET_VAR_EXPR) {\n    return buildVar(callHead.variable, context, symbols);\n  } else {\n    return buildGetPath(callHead, symbols);\n  }\n}\n\nexport function buildGetPath(head: NormalizedPath, symbols: Symbols): Expressions.GetPath {\n  return buildVar(head.path.head, VariableResolutionContext.Strict, symbols, head.path.tail);\n}\n\ntype VarResolution =\n  | VariableResolutionContext\n  | 'AppendBare'\n  | 'AppendInvoke'\n  | 'TrustedAppendBare'\n  | 'TrustedAppendInvoke'\n  | 'AttrValueBare'\n  | 'AttrValueInvoke'\n  | 'SubExpression'\n  | 'Strict';\n\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path: PresentArray<string>\n): Expressions.GetPath;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path?: PresentArray<string>\n): Expressions.GetPath | Expressions.GetVar {\n  let op: Expressions.GetPath[0] | Expressions.GetVar[0] = Op.GetSymbol;\n  let sym: number;\n  switch (head.kind) {\n    case FREE_VAR:\n      if (context === 'Strict') {\n        op = Op.GetStrictKeyword;\n      } else if (context === 'AppendBare') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'AppendInvoke') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'TrustedAppendBare') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'TrustedAppendInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueBare') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'SubExpression') {\n        op = Op.GetFreeAsHelperHead;\n      } else {\n        op = expressionContextOp(context);\n      }\n      sym = symbols.freeVar(head.name);\n      break;\n    default:\n      op = Op.GetSymbol;\n      sym = getSymbolForVar(head.kind, symbols, head.name);\n  }\n\n  if (path === undefined || path.length === 0) {\n    return [op, sym];\n  } else {\n    localAssert(op !== Op.GetStrictKeyword, '[BUG] keyword with a path');\n    return [op, sym, path];\n  }\n}\n\nfunction getSymbolForVar(kind: Exclude<VariableKind, FREE_VAR>, symbols: Symbols, name: string) {\n  switch (kind) {\n    case ARG_VAR:\n      return symbols.arg(name);\n    case BLOCK_VAR:\n      return symbols.block(name);\n    case LOCAL_VAR:\n      return symbols.local(name);\n    case THIS_VAR:\n      return symbols.this();\n    default:\n      return exhausted(kind);\n  }\n}\n\nexport function expressionContextOp(context: VariableResolutionContext): GetContextualFreeOpcode {\n  switch (context) {\n    case VariableResolutionContext.Strict:\n      return Op.GetStrictKeyword;\n    case VariableResolutionContext.ResolveAsComponentOrHelperHead:\n      return Op.GetFreeAsComponentOrHelperHead;\n    case VariableResolutionContext.ResolveAsHelperHead:\n      return Op.GetFreeAsHelperHead;\n    case VariableResolutionContext.ResolveAsModifierHead:\n      return Op.GetFreeAsModifierHead;\n    case VariableResolutionContext.ResolveAsComponentHead:\n      return Op.GetFreeAsComponentHead;\n    default:\n      return exhausted(context);\n  }\n}\n\nexport function buildParams(\n  exprs: Nullable<NormalizedParams>,\n  symbols: Symbols\n): Nullable<WireFormat.Core.Params> {\n  if (exprs === null || !isPresentArray(exprs)) return null;\n\n  return exprs.map((e) => buildExpression(e, 'Strict', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildConcat(\n  exprs: [NormalizedExpression, ...NormalizedExpression[]],\n  symbols: Symbols\n): WireFormat.Core.ConcatParams {\n  return exprs.map((e) => buildExpression(e, 'AttrValue', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildHash(exprs: Nullable<NormalizedHash>, symbols: Symbols): WireFormat.Core.Hash {\n  if (exprs === null) return null;\n\n  let out: [string[], WireFormat.Expression[]] = [[], []];\n\n  for (const [key, value] of Object.entries(exprs)) {\n    out[0].push(key);\n    out[1].push(buildExpression(value, 'Strict', symbols));\n  }\n\n  return out as WireFormat.Core.Hash;\n}\n\nexport function buildBlocks(\n  blocks: NormalizedBlocks,\n  blockParams: Nullable<string[]>,\n  parent: Symbols\n): WireFormat.Core.Blocks {\n  let keys: string[] = [];\n  let values: WireFormat.SerializedInlineBlock[] = [];\n\n  for (const [name, block] of Object.entries(blocks)) {\n    keys.push(name);\n\n    if (name === 'default') {\n      let symbols = parent.child(blockParams || []);\n\n      values.push(buildBlock(block, symbols, symbols.paramSymbols));\n    } else {\n      values.push(buildBlock(block, parent, []));\n    }\n  }\n\n  return [keys, values];\n}\n\nfunction buildBlock(\n  block: NormalizedBlock,\n  symbols: Symbols,\n  locals: number[] = []\n): WireFormat.SerializedInlineBlock {\n  return [buildNormalizedStatements(block, symbols), locals];\n}\n","import type { CurriedType, PresentArray } from '@glimmer/interfaces';\nimport type {\n  ASTv2,\n  BlockSymbolTable,\n  ProgramSymbolTable,\n  SourceSlice,\n  SymbolTable,\n} from '@glimmer/syntax';\nimport { node } from '@glimmer/syntax';\n\nimport type { AnyOptionalList, OptionalList, PresentList } from '../../shared/list';\n\nexport class Template extends node('Template').fields<{\n  scope: ProgramSymbolTable;\n  body: Statement[];\n}>() {}\n\nexport class InElement extends node('InElement').fields<{\n  guid: string;\n  insertBefore: ExpressionNode | Missing;\n  destination: ExpressionNode;\n  block: NamedBlock;\n}>() {}\n\nexport class Not extends node('Not').fields<{ value: ExpressionNode }>() {}\n\nexport class If extends node('If').fields<{\n  condition: ExpressionNode;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class IfInline extends node('IfInline').fields<{\n  condition: ExpressionNode;\n  truthy: ExpressionNode;\n  falsy: ExpressionNode | null;\n}>() {}\n\nexport class Each extends node('Each').fields<{\n  value: ExpressionNode;\n  key: ExpressionNode | null;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class Let extends node('Let').fields<{\n  positional: Positional;\n  block: NamedBlock;\n}>() {}\n\nexport class WithDynamicVars extends node('WithDynamicVars').fields<{\n  named: NamedArguments;\n  block: NamedBlock;\n}>() {}\n\nexport class GetDynamicVar extends node('GetDynamicVar').fields<{\n  name: ExpressionNode;\n}>() {}\n\nexport class Log extends node('Log').fields<{\n  positional: Positional;\n}>() {}\n\nexport class InvokeComponent extends node('InvokeComponent').fields<{\n  definition: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks | null;\n}>() {}\n\nexport class NamedBlocks extends node('NamedBlocks').fields<{\n  blocks: OptionalList<NamedBlock>;\n}>() {}\n\nexport class NamedBlock extends node('NamedBlock').fields<{\n  scope: BlockSymbolTable;\n  name: SourceSlice;\n  body: Statement[];\n}>() {}\nexport class AppendTrustedHTML extends node('AppendTrustedHTML').fields<{\n  html: ExpressionNode;\n}>() {}\nexport class AppendTextNode extends node('AppendTextNode').fields<{ text: ExpressionNode }>() {}\nexport class AppendComment extends node('AppendComment').fields<{ value: SourceSlice }>() {}\n\nexport class Component extends node('Component').fields<{\n  tag: ExpressionNode;\n  params: ElementParameters;\n  args: NamedArguments;\n  blocks: NamedBlocks;\n}>() {}\n\nexport interface AttrKind {\n  // triple-curly\n  trusting: boolean;\n  // this attribute is on an element with component features:\n  //   - <CapCase ...>\n  //   - modifiers\n  //   - <dynamic.tag ...>\n  component: boolean;\n}\n\nexport class StaticAttr extends node('StaticAttr').fields<{\n  kind: { component: boolean };\n  name: SourceSlice;\n  value: SourceSlice;\n  namespace?: string | undefined;\n}>() {}\n\nexport class DynamicAttr extends node('DynamicAttr').fields<{\n  kind: AttrKind;\n  name: SourceSlice;\n  value: ExpressionNode;\n  namespace?: string | undefined;\n}>() {}\n\nexport class SimpleElement extends node('SimpleElement').fields<{\n  tag: SourceSlice;\n  params: ElementParameters;\n  body: Statement[];\n  dynamicFeatures: boolean;\n}>() {}\n\nexport class ElementParameters extends node('ElementParameters').fields<{\n  body: AnyOptionalList<ElementParameter>;\n}>() {}\n\nexport class Yield extends node('Yield').fields<{\n  target: SourceSlice;\n  to: number;\n  positional: Positional;\n}>() {}\nexport class Debugger extends node('Debugger').fields<{ scope: SymbolTable }>() {}\n\nexport class CallExpression extends node('CallExpression').fields<{\n  callee: ExpressionNode;\n  args: Args;\n}>() {}\n\nexport class Modifier extends node('Modifier').fields<{ callee: ExpressionNode; args: Args }>() {}\nexport class InvokeBlock extends node('InvokeBlock').fields<{\n  head: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks;\n}>() {}\nexport class SplatAttr extends node('SplatAttr').fields<{ symbol: number }>() {}\nexport class PathExpression extends node('PathExpression').fields<{\n  head: ExpressionNode;\n  tail: Tail;\n}>() {}\n\nexport class Missing extends node('Missing').fields() {}\nexport class InterpolateExpression extends node('InterpolateExpression').fields<{\n  parts: PresentList<ExpressionNode>;\n}>() {}\nexport class HasBlock extends node('HasBlock').fields<{ target: SourceSlice; symbol: number }>() {}\nexport class HasBlockParams extends node('HasBlockParams').fields<{\n  target: SourceSlice;\n  symbol: number;\n}>() {}\nexport class Curry extends node('Curry').fields<{\n  definition: ExpressionNode;\n  curriedType: CurriedType;\n  args: Args;\n}>() {}\nexport class Positional extends node('Positional').fields<{\n  list: OptionalList<ExpressionNode>;\n}>() {}\nexport class NamedArguments extends node('NamedArguments').fields<{\n  entries: OptionalList<NamedArgument>;\n}>() {}\nexport class NamedArgument extends node('NamedArgument').fields<{\n  key: SourceSlice;\n  value: ExpressionNode;\n}>() {}\nexport class Args extends node('Args').fields<{\n  positional: Positional;\n  named: NamedArguments;\n}>() {}\nexport class Tail extends node('Tail').fields<{ members: PresentArray<SourceSlice> }>() {}\n\nexport type ExpressionNode =\n  | ASTv2.LiteralExpression\n  | ASTv2.KeywordExpression\n  | ASTv2.VariableReference\n  | Missing\n  | PathExpression\n  | InterpolateExpression\n  | CallExpression\n  | Not\n  | IfInline\n  | HasBlock\n  | HasBlockParams\n  | Curry\n  | GetDynamicVar\n  | Log;\n\nexport type ElementParameter = StaticAttr | DynamicAttr | Modifier | SplatAttr;\n\nexport type Internal =\n  | Args\n  | Positional\n  | NamedArguments\n  | NamedArgument\n  | Tail\n  | NamedBlock\n  | NamedBlocks\n  | ElementParameters;\nexport type ExprLike = ExpressionNode | Internal;\nexport type Statement =\n  | InElement\n  | Debugger\n  | Yield\n  | AppendTrustedHTML\n  | AppendTextNode\n  | Component\n  | SimpleElement\n  | InvokeBlock\n  | AppendComment\n  | If\n  | Each\n  | Let\n  | WithDynamicVars\n  | InvokeComponent;\n","import type { Nullable, PresentArray } from '@glimmer/interfaces';\nimport { isPresentArray, mapPresentArray } from '@glimmer/debug-util';\n\nexport interface OptionalList<T> {\n  map<U>(callback: (input: T) => U): MapList<T, U, AnyOptionalList<T>>;\n  filter<S extends T>(\n    predicate: (value: T, index: number, array: T[]) => value is S\n  ): AnyOptionalList<S>;\n  toArray(): T[];\n  toPresentArray(): Nullable<PresentArray<T>>;\n  into<U, V>(options: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V;\n}\n\nexport class PresentList<T> implements OptionalList<T> {\n  constructor(readonly list: PresentArray<T>) {}\n\n  toArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  map<U>(callback: (input: T) => U): MapList<T, U, PresentList<T>> {\n    let result = mapPresentArray(this.list, callback);\n    return new PresentList(result) as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(predicate: (value: T) => value is S): AnyOptionalList<S> {\n    let out: S[] = [];\n\n    for (let item of this.list) {\n      if (predicate(item)) {\n        out.push(item);\n      }\n    }\n\n    return OptionalList(out);\n  }\n\n  toPresentArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  into<U, V>({ ifPresent }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifPresent(this);\n  }\n}\n\nexport class EmptyList<T> implements OptionalList<T> {\n  readonly list: T[] = [];\n\n  map<U>(_callback: (input: T) => U): MapList<T, U, EmptyList<T>> {\n    return new EmptyList() as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(_predicate: (value: T) => value is S): AnyOptionalList<S> {\n    return new EmptyList();\n  }\n\n  toArray(): T[] {\n    return this.list;\n  }\n\n  toPresentArray(): Nullable<PresentArray<T>> {\n    return null;\n  }\n\n  into<U, V>({ ifEmpty }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifEmpty();\n  }\n}\n\n// export type OptionalList<T> = PresentList<T> | EmptyList<T>;\n\nexport function OptionalList<T>(value: readonly T[]): AnyOptionalList<T> {\n  if (isPresentArray(value)) {\n    return new PresentList(value);\n  } else {\n    return new EmptyList<T>();\n  }\n}\n\nexport type AnyOptionalList<T> = (PresentList<T> | EmptyList<T>) & OptionalList<T>;\n\nexport type MapList<T, U, L extends OptionalList<T>> =\n  L extends PresentList<T> ? PresentList<U> : L extends EmptyList<T> ? EmptyList<U> : never;\n","import type { GlimmerSyntaxError } from '@glimmer/syntax';\n\nimport type { AnyOptionalList } from './list';\n\nimport { OptionalList } from './list';\n\nabstract class ResultImpl<T> {\n  static all<T extends Result<unknown>[]>(...results: T): MapAll<T> {\n    let out: unknown[] = [];\n\n    for (let result of results) {\n      if (result.isErr) {\n        return result.cast();\n      } else {\n        out.push(result.value);\n      }\n    }\n\n    return Ok(out as MapAllOk<T>);\n  }\n\n  abstract mapOk<U>(callback: (value: T) => U): Result<U>;\n  abstract readonly isOk: boolean;\n  abstract readonly isErr: boolean;\n}\n\nexport const Result = ResultImpl;\n\nclass OkImpl<T> extends ResultImpl<T> {\n  readonly isOk = true;\n  readonly isErr = false;\n\n  constructor(readonly value: T) {\n    super();\n  }\n\n  expect(_message?: string): T {\n    return this.value;\n  }\n\n  ifOk(callback: (value: T) => void): this {\n    callback(this.value);\n    return this;\n  }\n\n  andThen<U>(callback: (value: T) => Result<U>): Result<U> {\n    return callback(this.value);\n  }\n\n  mapOk<U>(callback: (value: T) => U): Result<U> {\n    return Ok(callback(this.value));\n  }\n\n  ifErr(_callback: (value: GlimmerSyntaxError) => void): this {\n    return this;\n  }\n\n  mapErr(_callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return this;\n  }\n}\n\nclass ErrImpl<T> extends ResultImpl<T> {\n  readonly isOk = false;\n  readonly isErr = true;\n\n  constructor(readonly reason: GlimmerSyntaxError) {\n    super();\n  }\n\n  expect(message?: string): T {\n    throw new Error(message || 'expected an Ok, got Err');\n  }\n\n  andThen<U>(_callback: (value: T) => Result<U>): Result<U> {\n    return this.cast<U>();\n  }\n\n  mapOk<U>(_callback: (value: T) => U): Result<U> {\n    return this.cast<U>();\n  }\n\n  ifOk(_callback: (value: T) => void): this {\n    return this;\n  }\n\n  mapErr(callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return Err(callback(this.reason));\n  }\n\n  ifErr(callback: (value: GlimmerSyntaxError) => void): this {\n    callback(this.reason);\n    return this;\n  }\n\n  cast<U>(): Result<U> {\n    return this as unknown as Result<U>;\n  }\n}\n\nexport function isResult<T>(input: MaybeResult<T>): input is Result<T> {\n  return input instanceof ResultImpl;\n}\n\nexport function intoResult<T>(input: MaybeResult<T>): Result<T> {\n  if (isResult(input)) {\n    return input;\n  } else {\n    return Ok(input);\n  }\n}\n\nexport type Result<T> = OkImpl<T> | ErrImpl<T>;\n\ntype MapAllOk<T extends Result<unknown>[]> = {\n  [P in keyof T]: T[P] extends Result<infer Inner> ? Inner : never;\n};\n\ntype MapAll<T extends Result<unknown>[]> = Result<MapAllOk<T>>;\n\nexport function Ok<T>(value: T): Result<T> {\n  return new OkImpl(value);\n}\n\nexport type Ok<T> = OkImpl<T>;\n\nexport function Err<T>(reason: GlimmerSyntaxError): Result<T> {\n  return new ErrImpl(reason);\n}\n\nexport type Err<T> = ErrImpl<T>;\n\nexport type MaybeResult<T> = T | Result<T>;\n\nexport class MapIntoResultArray<T> {\n  constructor(private items: T[]) {}\n\n  map<U>(mapper: (item: T) => Result<U>): Result<U[]> {\n    let out = new ResultArray<U>();\n\n    for (let item of this.items) {\n      out.add(mapper(item));\n    }\n\n    return out.toArray();\n  }\n}\n\nexport class ResultArray<T> {\n  constructor(private items: Result<T>[] = []) {}\n\n  add(item: Result<T>): void {\n    this.items.push(item);\n  }\n\n  toArray(): Result<T[]> {\n    let err = this.items.filter((item): item is ErrImpl<T> => item instanceof ErrImpl)[0];\n\n    if (err !== undefined) {\n      return err.cast<T[]>();\n    } else {\n      return Ok((this.items as OkImpl<T>[]).map((item) => item.value));\n    }\n  }\n\n  toOptionalList(): Result<AnyOptionalList<T>> {\n    return this.toArray().mapOk((arr) => OptionalList(arr));\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { getLast, isPresentArray } from '@glimmer/debug-util';\nimport { ASTv2, KEYWORDS_TYPES } from '@glimmer/syntax';\n\nimport type { AnyOptionalList, PresentList } from '../../../shared/list';\nimport type { NormalizationState } from '../context';\n\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { CALL_KEYWORDS } from '../keywords';\n\nexport class NormalizeExpressions {\n  visit(node: ASTv2.ExpressionNode, state: NormalizationState): Result<mir.ExpressionNode> {\n    switch (node.type) {\n      case 'Literal':\n        return Ok(this.Literal(node));\n      case 'Keyword':\n        return Ok(this.Keyword(node));\n      case 'Interpolate':\n        return this.Interpolate(node, state);\n      case 'Path':\n        return this.PathExpression(node);\n      case 'Call': {\n        let translated = CALL_KEYWORDS.translate(node, state);\n\n        if (translated !== null) {\n          return translated;\n        }\n\n        return this.CallExpression(node, state);\n      }\n    }\n  }\n\n  visitList(\n    nodes: PresentArray<ASTv2.ExpressionNode>,\n    state: NormalizationState\n  ): Result<PresentList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>> {\n    return new ResultArray(nodes.map((e) => VISIT_EXPRS.visit(e, state))).toOptionalList();\n  }\n\n  /**\n   * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.\n   *\n   * TODO since keywords don't support tails anyway, distinguish PathExpression from\n   * VariableReference in ASTv2.\n   */\n  PathExpression(path: ASTv2.PathExpression): Result<mir.ExpressionNode> {\n    let ref = this.VariableReference(path.ref);\n    let { tail } = path;\n\n    if (isPresentArray(tail)) {\n      let tailLoc = tail[0].loc.extend(getLast(tail).loc);\n      return Ok(\n        new mir.PathExpression({\n          loc: path.loc,\n          head: ref,\n          tail: new mir.Tail({ loc: tailLoc, members: tail }),\n        })\n      );\n    } else {\n      return Ok(ref);\n    }\n  }\n\n  VariableReference(ref: ASTv2.VariableReference): ASTv2.VariableReference {\n    return ref;\n  }\n\n  Literal(literal: ASTv2.LiteralExpression): ASTv2.LiteralExpression {\n    return literal;\n  }\n\n  Keyword(keyword: ASTv2.KeywordExpression): ASTv2.KeywordExpression {\n    return keyword;\n  }\n\n  Interpolate(\n    expr: ASTv2.InterpolateExpression,\n    state: NormalizationState\n  ): Result<mir.InterpolateExpression> {\n    let parts = expr.parts.map(convertPathToCallIfKeyword) as PresentArray<ASTv2.ExpressionNode>;\n\n    return VISIT_EXPRS.visitList(parts, state).mapOk(\n      (parts) => new mir.InterpolateExpression({ loc: expr.loc, parts: parts })\n    );\n  }\n\n  CallExpression(\n    expr: ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<mir.ExpressionNode> {\n    if (expr.callee.type === 'Call') {\n      throw new Error(`unimplemented: subexpression at the head of a subexpression`);\n    } else {\n      return Result.all(\n        VISIT_EXPRS.visit(expr.callee, state),\n        VISIT_EXPRS.Args(expr.args, state)\n      ).mapOk(\n        ([callee, args]) =>\n          new mir.CallExpression({\n            loc: expr.loc,\n            callee,\n            args,\n          })\n      );\n    }\n  }\n\n  Args({ positional, named, loc }: ASTv2.Args, state: NormalizationState): Result<mir.Args> {\n    return Result.all(this.Positional(positional, state), this.NamedArguments(named, state)).mapOk(\n      ([positional, named]) =>\n        new mir.Args({\n          loc,\n          positional,\n          named,\n        })\n    );\n  }\n\n  Positional(\n    positional: ASTv2.PositionalArguments,\n    state: NormalizationState\n  ): Result<mir.Positional> {\n    return VISIT_EXPRS.visitList(positional.exprs, state).mapOk(\n      (list) =>\n        new mir.Positional({\n          loc: positional.loc,\n          list,\n        })\n    );\n  }\n\n  NamedArguments(\n    named: ASTv2.NamedArguments,\n    state: NormalizationState\n  ): Result<mir.NamedArguments> {\n    let pairs = named.entries.map((arg) => {\n      let value = convertPathToCallIfKeyword(arg.value);\n\n      return VISIT_EXPRS.visit(value, state).mapOk(\n        (value) =>\n          new mir.NamedArgument({\n            loc: arg.loc,\n            key: arg.name,\n            value,\n          })\n      );\n    });\n\n    return new ResultArray(pairs)\n      .toOptionalList()\n      .mapOk((pairs) => new mir.NamedArguments({ loc: named.loc, entries: pairs }));\n  }\n}\n\nexport function convertPathToCallIfKeyword(path: ASTv2.ExpressionNode): ASTv2.ExpressionNode {\n  if (path.type === 'Path' && path.ref.type === 'Free' && path.ref.name in KEYWORDS_TYPES) {\n    return new ASTv2.CallExpression({\n      callee: path,\n      args: ASTv2.Args.empty(path.loc),\n      loc: path.loc,\n    });\n  }\n\n  return path;\n}\n\nexport const VISIT_EXPRS = new NormalizeExpressions();\n","import type { ASTv2, KeywordType } from '@glimmer/syntax';\nimport { exhausted } from '@glimmer/debug-util';\nimport { generateSyntaxError, isKeyword, KEYWORDS_TYPES } from '@glimmer/syntax';\n\nimport type { Result } from '../../../shared/result';\nimport type { NormalizationState } from '../context';\n\nimport { Err } from '../../../shared/result';\n\nexport interface KeywordDelegate<Match extends KeywordMatch, V, Out> {\n  assert: (options: Match, state: NormalizationState) => Result<V>;\n  translate: (options: { node: Match; state: NormalizationState }, param: V) => Result<Out>;\n}\n\nexport interface Keyword<K extends KeywordType = KeywordType, Out = unknown> {\n  translate(node: KeywordCandidates[K], state: NormalizationState): Result<Out> | null;\n}\n\nexport interface BlockKeyword<Out = unknown> {\n  translate(node: ASTv2.InvokeBlock, state: NormalizationState): Result<Out> | null;\n}\n\nclass KeywordImpl<\n  K extends KeywordType,\n  S extends string = string,\n  Param = unknown,\n  Out = unknown,\n> {\n  protected types: Set<KeywordCandidates[K]['type']>;\n\n  constructor(\n    protected keyword: S,\n    type: KeywordType,\n    private delegate: KeywordDelegate<KeywordMatches[K], Param, Out>\n  ) {\n    let nodes = new Set<KeywordNode['type']>();\n    for (let nodeType of KEYWORD_NODES[type]) {\n      nodes.add(nodeType);\n    }\n\n    this.types = nodes;\n  }\n\n  protected match(node: KeywordCandidates[K]): node is KeywordMatches[K] {\n    if (!this.types.has(node.type)) {\n      return false;\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path !== null && path.type === 'Path' && path.ref.type === 'Free') {\n      return path.ref.name === this.keyword;\n    } else {\n      return false;\n    }\n  }\n\n  translate(node: KeywordMatches[K], state: NormalizationState): Result<Out> | null {\n    if (this.match(node)) {\n      let path = getCalleeExpression(node);\n\n      if (path !== null && path.type === 'Path' && path.tail.length > 0) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${\n              this.keyword\n            }\\` keyword was used incorrectly. It was used as \\`${path.loc.asString()}\\`, but it cannot be used with additional path segments. \\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n\n      let param = this.delegate.assert(node, state);\n      return param.andThen((param) => this.delegate.translate({ node, state }, param));\n    } else {\n      return null;\n    }\n  }\n}\n\nexport const KEYWORD_NODES = {\n  Call: ['Call'],\n  Block: ['InvokeBlock'],\n  Append: ['AppendContent'],\n  Modifier: ['ElementModifier'],\n} as const;\n\nexport interface KeywordCandidates {\n  Call: ASTv2.ExpressionNode;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordCandidate = KeywordCandidates[keyof KeywordCandidates];\n\nexport interface KeywordMatches {\n  Call: ASTv2.CallExpression;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordMatch = KeywordMatches[keyof KeywordMatches];\n\n/**\n * A \"generic\" keyword is something like `has-block`, which makes sense in the context\n * of sub-expression or append\n */\nexport type GenericKeywordNode = ASTv2.AppendContent | ASTv2.CallExpression;\n\nexport type KeywordNode =\n  | GenericKeywordNode\n  | ASTv2.CallExpression\n  | ASTv2.InvokeBlock\n  | ASTv2.ElementModifier;\n\nexport type PossibleKeyword = KeywordNode;\ntype OutFor<K extends Keyword | BlockKeyword> =\n  K extends BlockKeyword<infer Out> ? Out : K extends Keyword<KeywordType, infer Out> ? Out : never;\n\nfunction getCalleeExpression(\n  node: KeywordNode | ASTv2.ExpressionNode\n): ASTv2.ExpressionNode | null {\n  switch (node.type) {\n    // This covers the inside of attributes and expressions, as well as the callee\n    // of call nodes\n    case 'Path':\n      return node;\n    case 'AppendContent':\n      return getCalleeExpression(node.value);\n    case 'Call':\n    case 'InvokeBlock':\n    case 'ElementModifier':\n      return node.callee;\n    default:\n      return null;\n  }\n}\n\nexport class Keywords<K extends KeywordType, KeywordList extends Keyword<K> = never>\n  implements Keyword<K, OutFor<KeywordList>>\n{\n  _keywords: Keyword[] = [];\n  _type: K;\n\n  constructor(type: K) {\n    this._type = type;\n  }\n\n  kw<V, S extends string = string, Out = unknown>(\n    name: S,\n    delegate: KeywordDelegate<KeywordMatches[K], V, Out>\n  ): this {\n    this._keywords.push(new KeywordImpl(name, this._type, delegate));\n\n    return this;\n  }\n\n  translate(\n    node: KeywordCandidates[K],\n    state: NormalizationState\n  ): Result<OutFor<KeywordList>> | null {\n    for (let keyword of this._keywords) {\n      let result = keyword.translate(node, state);\n      if (result !== null) {\n        return result as Result<OutFor<KeywordList>>;\n      }\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path && path.type === 'Path' && path.ref.type === 'Free' && isKeyword(path.ref.name)) {\n      let { name } = path.ref as { name: keyof typeof KEYWORDS_TYPES };\n\n      let usedType = this._type;\n      let validTypes: readonly KeywordType[] = KEYWORDS_TYPES[name];\n\n      if (!validTypes.includes(usedType)) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${name}\\` keyword was used incorrectly. It was used as ${\n              typesToReadableName[usedType]\n            }, but its valid usages are:\\n\\n${generateTypesMessage(\n              name,\n              validTypes\n            )}\\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    return null;\n  }\n}\n\nconst typesToReadableName = {\n  Append: 'an append statement',\n  Block: 'a block statement',\n  Call: 'a call expression',\n  Modifier: 'a modifier',\n};\n\nfunction generateTypesMessage(name: string, types: readonly KeywordType[]): string {\n  return types\n    .map((type) => {\n      switch (type) {\n        case 'Append':\n          return `- As an append statement, as in: {{${name}}}`;\n        case 'Block':\n          return `- As a block statement, as in: {{#${name}}}{{/${name}}}`;\n        case 'Call':\n          return `- As an expression, as in: (${name})`;\n        case 'Modifier':\n          return `- As a modifier, as in: <div {{${name}}}></div>`;\n        default:\n          return exhausted(type);\n      }\n    })\n    .join('\\n\\n');\n}\n\n/**\n * This function builds keyword definitions for a particular type of AST node (`KeywordType`).\n *\n * You can build keyword definitions for:\n *\n * - `Expr`: A `SubExpression` or `PathExpression`\n * - `Block`: A `BlockStatement`\n *   - A `BlockStatement` is a keyword candidate if its head is a\n *     `PathExpression`\n * - `Append`: An `AppendStatement`\n *\n * A node is a keyword candidate if:\n *\n * - A `PathExpression` is a keyword candidate if it has no tail, and its\n *   head expression is a `LocalVarHead` or `FreeVarHead` whose name is\n *   the keyword's name.\n * - A `SubExpression`, `AppendStatement`, or `BlockStatement` is a keyword\n *   candidate if its head is a keyword candidate.\n *\n * The keyword infrastructure guarantees that:\n *\n * - If a node is not a keyword candidate, it is never passed to any keyword's\n *   `assert` method.\n * - If a node is not the `KeywordType` for a particular keyword, it will not\n *   be passed to the keyword's `assert` method.\n *\n * `Expr` keywords are used in expression positions and should return HIR\n * expressions. `Block` and `Append` keywords are used in statement\n * positions and should return HIR statements.\n *\n * A keyword definition has two parts:\n *\n * - `match`, which determines whether an AST node matches the keyword, and can\n *   optionally return some information extracted from the AST node.\n * - `translate`, which takes a matching AST node as well as the extracted\n *   information and returns an appropriate HIR instruction.\n *\n * # Example\n *\n * This keyword:\n *\n * - turns `(hello)` into `\"hello\"`\n *   - as long as `hello` is not in scope\n * - makes it an error to pass any arguments (such as `(hello world)`)\n *\n * ```ts\n * keywords('SubExpr').kw('hello', {\n *   assert(node: ExprKeywordNode): Result<void> | false {\n *     // we don't want to transform `hello` as a `PathExpression`\n *     if (node.type !== 'SubExpression') {\n *       return false;\n *     }\n *\n *     // node.head would be `LocalVarHead` if `hello` was in scope\n *     if (node.head.type !== 'FreeVarHead') {\n *       return false;\n *     }\n *\n *     if (node.params.length || node.hash) {\n *       return Err(generateSyntaxError(`(hello) does not take any arguments`), node.loc);\n *     } else {\n *       return Ok();\n *     }\n *   },\n *\n *   translate(node: ASTv2.SubExpression): hir.Expression {\n *     return ASTv2.builders.literal(\"hello\", node.loc)\n *   }\n * })\n * ```\n *\n * The keyword infrastructure checks to make sure that the node is the right\n * type before calling `assert`, so you only need to consider `SubExpression`\n * and `PathExpression` here. It also checks to make sure that the node passed\n * to `assert` has the keyword name in the right place.\n *\n * Note the important difference between returning `false` from `assert`,\n * which just means that the node didn't match, and returning `Err`, which\n * means that the node matched, but there was a keyword-specific syntax\n * error.\n */\nexport function keywords<K extends KeywordType>(type: K): Keywords<K> {\n  return new Keywords(type);\n}\n","import type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport * as mir from '../../../2-encoding/mir';\n\nexport function toAppend<T>({\n  assert,\n  translate,\n}: KeywordDelegate<GenericKeywordNode, T, mir.ExpressionNode>): KeywordDelegate<\n  GenericKeywordNode,\n  T,\n  mir.AppendTextNode\n> {\n  return {\n    assert,\n    translate(\n      { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n      value: T\n    ): Result<mir.AppendTextNode> {\n      let result = translate({ node, state }, value);\n\n      return result.mapOk((text) => new mir.AppendTextNode({ text, loc: node.loc }));\n    },\n  };\n}\n","import type { CurriedType } from '@glimmer/interfaces';\nimport { CURRIED_COMPONENT, CURRIED_HELPER, CURRIED_MODIFIER } from '@glimmer/constants';\nimport { ASTv2, generateSyntaxError } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nconst CurriedTypeToReadableType = {\n  [CURRIED_COMPONENT]: 'component',\n  [CURRIED_HELPER]: 'helper',\n  [CURRIED_MODIFIER]: 'modifier',\n} as const;\n\nexport function assertCurryKeyword(curriedType: CurriedType) {\n  return (\n    node: ASTv2.AppendContent | ASTv2.InvokeBlock | ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<{\n    definition: ASTv2.ExpressionNode;\n    args: ASTv2.Args;\n  }> => {\n    let readableType = CurriedTypeToReadableType[curriedType];\n    let stringsAllowed = curriedType === CURRIED_COMPONENT;\n\n    let { args } = node;\n\n    let definition = args.nth(0);\n\n    if (definition === null) {\n      return Err(\n        generateSyntaxError(\n          `(${readableType}) requires a ${readableType} definition or identifier as its first positional parameter, did not receive any parameters.`,\n          args.loc\n        )\n      );\n    }\n\n    if (definition.type === 'Literal') {\n      if (stringsAllowed && state.isStrict) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values in strict mode templates`,\n            node.loc\n          )\n        );\n      } else if (!stringsAllowed) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values, you must pass a ${readableType} definition directly`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    args = new ASTv2.Args({\n      positional: new ASTv2.PositionalArguments({\n        exprs: args.positional.exprs.slice(1),\n        loc: args.positional.loc,\n      }),\n      named: args.named,\n      loc: args.loc,\n    });\n\n    return Ok({ definition, args });\n  };\n}\n\nfunction translateCurryKeyword(curriedType: CurriedType) {\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.CallExpression | ASTv2.AppendContent; state: NormalizationState },\n    { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n  ): Result<mir.Curry> => {\n    let definitionResult = VISIT_EXPRS.visit(definition, state);\n    let argsResult = VISIT_EXPRS.Args(args, state);\n\n    return Result.all(definitionResult, argsResult).mapOk(\n      ([definition, args]) =>\n        new mir.Curry({\n          loc: node.loc,\n          curriedType,\n          definition,\n          args,\n        })\n    );\n  };\n}\n\nexport function curryKeyword(\n  curriedType: CurriedType\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  { definition: ASTv2.ExpressionNode; args: ASTv2.Args },\n  mir.Curry\n> {\n  return {\n    assert: assertCurryKeyword(curriedType),\n    translate: translateCurryKeyword(curriedType),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertGetDynamicVarKeyword(node: GenericKeywordNode): Result<ASTv2.ExpressionNode> {\n  let call = node.type === 'AppendContent' ? node.value : node;\n\n  let named = call.type === 'Call' ? call.args.named : null;\n  let positionals = call.type === 'Call' ? call.args.positional : null;\n\n  if (named && !named.isEmpty()) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) does not take any named arguments`, node.loc)\n    );\n  }\n\n  let varName = positionals?.nth(0);\n\n  if (!varName) {\n    return Err(generateSyntaxError(`(-get-dynamic-vars) requires a var name to get`, node.loc));\n  }\n\n  if (positionals && positionals.size > 1) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) only receives one positional arg`, node.loc)\n    );\n  }\n\n  return Ok(varName);\n}\n\nfunction translateGetDynamicVarKeyword(\n  { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n  name: ASTv2.ExpressionNode\n): Result<mir.GetDynamicVar> {\n  return VISIT_EXPRS.visit(name, state).mapOk(\n    (name) => new mir.GetDynamicVar({ name, loc: node.loc })\n  );\n}\n\nexport const getDynamicVarKeyword: KeywordDelegate<\n  GenericKeywordNode,\n  ASTv2.ExpressionNode,\n  mir.GetDynamicVar\n> = {\n  assert: assertGetDynamicVarKeyword,\n  translate: translateGetDynamicVarKeyword,\n};\n","import { ASTv2, generateSyntaxError, SourceSlice } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\n\nfunction assertHasBlockKeyword(type: string) {\n  return (node: GenericKeywordNode): Result<SourceSlice> => {\n    let call = node.type === 'AppendContent' ? node.value : node;\n\n    let named = call.type === 'Call' ? call.args.named : null;\n    let positionals = call.type === 'Call' ? call.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(generateSyntaxError(`(${type}) does not take any named arguments`, call.loc));\n    }\n\n    if (!positionals || positionals.isEmpty()) {\n      return Ok(SourceSlice.synthetic('default'));\n    } else if (positionals.exprs.length === 1) {\n      let positional = positionals.exprs[0] as ASTv2.ExpressionNode;\n      if (ASTv2.isLiteral(positional, 'string')) {\n        return Ok(positional.toSlice());\n      } else {\n        return Err(\n          generateSyntaxError(\n            `(${type}) can only receive a string literal as its first argument`,\n            call.loc\n          )\n        );\n      }\n    } else {\n      return Err(\n        generateSyntaxError(`(${type}) only takes a single positional argument`, call.loc)\n      );\n    }\n  };\n}\n\nfunction translateHasBlockKeyword(type: string) {\n  return (\n    {\n      node,\n      state: { scope },\n    }: { node: ASTv2.CallExpression | ASTv2.AppendContent; state: NormalizationState },\n    target: SourceSlice\n  ): Result<mir.HasBlock | mir.HasBlockParams> => {\n    let block =\n      type === 'has-block'\n        ? new mir.HasBlock({ loc: node.loc, target, symbol: scope.allocateBlock(target.chars) })\n        : new mir.HasBlockParams({\n            loc: node.loc,\n            target,\n            symbol: scope.allocateBlock(target.chars),\n          });\n\n    return Ok(block);\n  };\n}\n\nexport function hasBlockKeyword(\n  type: string\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  SourceSlice,\n  mir.HasBlock | mir.HasBlockParams\n> {\n  return {\n    assert: assertHasBlockKeyword(type),\n    translate: translateHasBlockKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertIfUnlessInlineKeyword(type: string) {\n  return (\n    originalNode: ASTv2.AppendContent | ASTv2.ExpressionNode\n  ): Result<{\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  }> => {\n    let inverted = type === 'unless';\n\n    let node = originalNode.type === 'AppendContent' ? originalNode.value : originalNode;\n    let named = node.type === 'Call' ? node.args.named : null;\n    let positional = node.type === 'Call' ? node.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(\n        generateSyntaxError(\n          `(${type}) cannot receive named parameters, received ${named.entries\n            .map((e) => e.name.chars)\n            .join(', ')}`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let condition = positional?.nth(0);\n\n    if (!positional || !condition) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Did not receive any parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let truthy = positional.nth(1);\n    let falsy = positional.nth(2);\n\n    if (truthy === null) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Received only one parameter, the condition`,\n          originalNode.loc\n        )\n      );\n    }\n\n    if (positional.size > 3) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${type}), 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }, and 3. the value to return if the condition is ${\n            inverted ? 'true' : 'false'\n          }. Received ${positional.size} parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    return Ok({ condition, truthy, falsy });\n  };\n}\n\nfunction translateIfUnlessInlineKeyword(type: string) {\n  let inverted = type === 'unless';\n\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.AppendContent | ASTv2.ExpressionNode; state: NormalizationState },\n    {\n      condition,\n      truthy,\n      falsy,\n    }: {\n      condition: ASTv2.ExpressionNode;\n      truthy: ASTv2.ExpressionNode;\n      falsy: ASTv2.ExpressionNode | null;\n    }\n  ): Result<mir.IfInline> => {\n    let conditionResult = VISIT_EXPRS.visit(condition, state);\n    let truthyResult = VISIT_EXPRS.visit(truthy, state);\n    let falsyResult = falsy ? VISIT_EXPRS.visit(falsy, state) : Ok(null);\n\n    return Result.all(conditionResult, truthyResult, falsyResult).mapOk(\n      ([condition, truthy, falsy]) => {\n        if (inverted) {\n          condition = new mir.Not({ value: condition, loc: node.loc });\n        }\n\n        return new mir.IfInline({\n          loc: node.loc,\n          condition,\n          truthy,\n          falsy,\n        });\n      }\n    );\n  };\n}\n\nexport function ifUnlessInlineKeyword(type: string): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  {\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  },\n  mir.IfInline\n> {\n  return {\n    assert: assertIfUnlessInlineKeyword(type),\n    translate: translateIfUnlessInlineKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertLogKeyword(node: GenericKeywordNode): Result<ASTv2.PositionalArguments> {\n  let {\n    args: { named, positional },\n  } = node;\n\n  if (named.isEmpty()) {\n    return Ok(positional);\n  } else {\n    return Err(generateSyntaxError(`(log) does not take any named arguments`, node.loc));\n  }\n}\n\nfunction translateLogKeyword(\n  { node, state }: { node: ASTv2.CallExpression | ASTv2.AppendContent; state: NormalizationState },\n  positional: ASTv2.PositionalArguments\n): Result<mir.Log> {\n  return VISIT_EXPRS.Positional(positional, state).mapOk(\n    (positional) => new mir.Log({ positional, loc: node.loc })\n  );\n}\n\nexport const logKeyword: KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  ASTv2.PositionalArguments,\n  mir.Log\n> = {\n  assert: assertLogKeyword,\n  translate: translateLogKeyword,\n};\n","import { CURRIED_COMPONENT, CURRIED_HELPER } from '@glimmer/constants';\nimport { ASTv2, generateSyntaxError, src } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { keywords } from './impl';\nimport { toAppend } from './utils/call-to-append';\nimport { assertCurryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const APPEND_KEYWORDS = keywords('Append')\n  .kw('has-block', toAppend(hasBlockKeyword('has-block')))\n  .kw('has-block-params', toAppend(hasBlockKeyword('has-block-params')))\n  .kw('-get-dynamic-var', toAppend(getDynamicVarKeyword))\n  .kw('log', toAppend(logKeyword))\n  .kw('if', toAppend(ifUnlessInlineKeyword('if')))\n  .kw('unless', toAppend(ifUnlessInlineKeyword('unless')))\n  .kw('yield', {\n    assert(node: ASTv2.AppendContent): Result<{\n      target: src.SourceSlice;\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (args.named.isEmpty()) {\n        return Ok({\n          target: src.SourceSpan.synthetic('default').toSlice(),\n          positional: args.positional,\n        });\n      } else {\n        let target = args.named.get('to');\n\n        if (args.named.size > 1 || target === null) {\n          return Err(\n            generateSyntaxError(`yield only takes a single named argument: 'to'`, args.named.loc)\n          );\n        }\n\n        if (ASTv2.isLiteral(target, 'string')) {\n          return Ok({ target: target.toSlice(), positional: args.positional });\n        } else {\n          return Err(\n            generateSyntaxError(`you can only yield to a literal string value`, target.loc)\n          );\n        }\n      }\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      {\n        target,\n        positional,\n      }: {\n        target: src.SourceSlice;\n        positional: ASTv2.PositionalArguments;\n      }\n    ): Result<mir.Statement> {\n      return VISIT_EXPRS.Positional(positional, state).mapOk(\n        (positional) =>\n          new mir.Yield({\n            loc: node.loc,\n            target,\n            to: state.scope.allocateBlock(target.chars),\n            positional,\n          })\n      );\n    },\n  })\n  .kw('debugger', {\n    assert(node: ASTv2.AppendContent): Result<void> {\n      let { args } = node;\n      let { positional } = args;\n\n      if (args.isEmpty()) {\n        return Ok(undefined);\n      } else {\n        if (positional.isEmpty()) {\n          return Err(generateSyntaxError(`debugger does not take any named arguments`, node.loc));\n        } else {\n          return Err(\n            generateSyntaxError(`debugger does not take any positional arguments`, node.loc)\n          );\n        }\n      }\n    },\n\n    translate({\n      node,\n      state: { scope },\n    }: {\n      node: ASTv2.AppendContent;\n      state: NormalizationState;\n    }): Result<mir.Statement> {\n      return Ok(new mir.Debugger({ loc: node.loc, scope }));\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CURRIED_COMPONENT),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(\n        ([definition, args]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks: null,\n          })\n      );\n    },\n  })\n  .kw('helper', {\n    assert: assertCurryKeyword(CURRIED_HELPER),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.AppendTextNode> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => {\n        let text = new mir.CallExpression({ callee: definition, args, loc: node.loc });\n\n        return new mir.AppendTextNode({\n          loc: node.loc,\n          text,\n        });\n      });\n    },\n  });\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { CURRIED_COMPONENT } from '@glimmer/constants';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { VISIT_STMTS } from '../visitors/statements';\nimport { keywords } from './impl';\nimport { assertCurryKeyword } from './utils/curry';\n\nexport const BLOCK_KEYWORDS = keywords('Block')\n  .kw('in-element', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      insertBefore: ASTv2.ExpressionNode | null;\n      destination: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      let guid = args.get('guid');\n\n      if (guid) {\n        return Err(generateSyntaxError(`Cannot pass \\`guid\\` to \\`{{#in-element}}\\``, guid.loc));\n      }\n\n      let insertBefore = args.get('insertBefore');\n      let destination = args.nth(0);\n\n      if (destination === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#in-element}} requires a target element as its first positional parameter`,\n            args.loc\n          )\n        );\n      }\n\n      // TODO Better syntax checks\n\n      return Ok({ insertBefore, destination });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      {\n        insertBefore,\n        destination,\n      }: { insertBefore: ASTv2.ExpressionNode | null; destination: ASTv2.ExpressionNode }\n    ): Result<mir.InElement> {\n      let named = node.blocks.get('default');\n      let body = VISIT_STMTS.NamedBlock(named, state);\n      let destinationResult = VISIT_EXPRS.visit(destination, state);\n\n      return Result.all(body, destinationResult)\n        .andThen(\n          ([body, destination]): Result<{\n            body: mir.NamedBlock;\n            destination: mir.ExpressionNode;\n            insertBefore: mir.ExpressionNode;\n          }> => {\n            if (insertBefore) {\n              return VISIT_EXPRS.visit(insertBefore, state).mapOk((insertBefore) => ({\n                body,\n                destination,\n                insertBefore,\n              }));\n            } else {\n              return Ok({\n                body,\n                destination,\n                insertBefore: new mir.Missing({\n                  loc: node.callee.loc.collapse('end'),\n                }),\n              });\n            }\n          }\n        )\n        .mapOk(\n          ({ body, destination, insertBefore }) =>\n            new mir.InElement({\n              loc: node.loc,\n              block: body,\n              insertBefore,\n              guid: state.generateUniqueCursor(),\n              destination,\n            })\n        );\n    },\n  })\n  .kw('if', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('unless', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition: new mir.Not({ value: condition, loc: node.loc }),\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('each', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      value: ASTv2.ExpressionNode;\n      key: ASTv2.ExpressionNode | null;\n    }> {\n      let { args } = node;\n\n      if (!args.named.entries.every((e) => e.name.chars === 'key')) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive the 'key' named parameter, received ${args.named.entries\n              .filter((e) => e.name.chars !== 'key')\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive one positional parameter, the collection being iterated. Received ${args.positional.size} parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      let value = args.nth(0);\n      let key = args.get('key');\n\n      if (value === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters`,\n            args.loc\n          )\n        );\n      }\n\n      return Ok({ value, key });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { value, key }: { value: ASTv2.ExpressionNode; key: ASTv2.ExpressionNode | null }\n    ): Result<mir.Each> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let valueResult = VISIT_EXPRS.visit(value, state);\n      let keyResult = key ? VISIT_EXPRS.visit(key, state) : Ok(null);\n\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(valueResult, keyResult, blockResult, inverseResult).mapOk(\n        ([value, key, block, inverse]) =>\n          new mir.Each({\n            loc: node.loc,\n            value,\n            key,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('let', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size === 0) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} requires at least one value as its first positional parameter, did not receive any parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      if (node.blocks.get('else')) {\n        return Err(\n          generateSyntaxError(`{{#let}} cannot receive an {{else}} block`, args.positional.loc)\n        );\n      }\n\n      return Ok({ positional: args.positional });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { positional }: { positional: ASTv2.PositionalArguments }\n    ): Result<mir.Let> {\n      let block = node.blocks.get('default');\n\n      let positionalResult = VISIT_EXPRS.Positional(positional, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(positionalResult, blockResult).mapOk(\n        ([positional, block]) =>\n          new mir.Let({\n            loc: node.loc,\n            positional,\n            block,\n          })\n      );\n    },\n  })\n  .kw('-with-dynamic-vars', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      named: ASTv2.NamedArguments;\n    }> {\n      return Ok({ named: node.args.named });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { named }: { named: ASTv2.NamedArguments }\n    ): Result<mir.WithDynamicVars> {\n      let block = node.blocks.get('default');\n\n      let namedResult = VISIT_EXPRS.NamedArguments(named, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(namedResult, blockResult).mapOk(\n        ([named, block]) =>\n          new mir.WithDynamicVars({\n            loc: node.loc,\n            named,\n            block,\n          })\n      );\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CURRIED_COMPONENT),\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n      let blocksResult = VISIT_STMTS.NamedBlocks(node.blocks, state);\n\n      return Result.all(definitionResult, argsResult, blocksResult).mapOk(\n        ([definition, args, blocks]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks,\n          })\n      );\n    },\n  });\n","import { CURRIED_COMPONENT, CURRIED_HELPER, CURRIED_MODIFIER } from '@glimmer/constants';\n\nimport { keywords } from './impl';\nimport { curryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const CALL_KEYWORDS = keywords('Call')\n  .kw('has-block', hasBlockKeyword('has-block'))\n  .kw('has-block-params', hasBlockKeyword('has-block-params'))\n  .kw('-get-dynamic-var', getDynamicVarKeyword)\n  .kw('log', logKeyword)\n  .kw('if', ifUnlessInlineKeyword('if'))\n  .kw('unless', ifUnlessInlineKeyword('unless'))\n  .kw('component', curryKeyword(CURRIED_COMPONENT))\n  .kw('helper', curryKeyword(CURRIED_HELPER))\n  .kw('modifier', curryKeyword(CURRIED_MODIFIER));\n","import { keywords } from './impl';\n\nexport const MODIFIER_KEYWORDS = keywords('Modifier');\n","import type { Dict, WellKnownAttrName, WellKnownTagName } from '@glimmer/interfaces';\nimport { WellKnownAttrNames, WellKnownTagNames } from '@glimmer/wire-format';\n\n// There is a small whitelist of namespaced attributes specially\n// enumerated in\n// https://www.w3.org/TR/html/syntax.html#attributes-0\n//\n// > When a foreign element has one of the namespaced attributes given by\n// > the local name and namespace of the first and second cells of a row\n// > from the following table, it must be written using the name given by\n// > the third cell from the same row.\n//\n// In all other cases, colons are interpreted as a regular character\n// with no special meaning:\n//\n// > No other namespaced attribute can be expressed in the HTML syntax.\n\nconst XLINK = 'http://www.w3.org/1999/xlink';\nconst XML = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\nconst WHITELIST: Dict<string | undefined> = {\n  'xlink:actuate': XLINK,\n  'xlink:arcrole': XLINK,\n  'xlink:href': XLINK,\n  'xlink:role': XLINK,\n  'xlink:show': XLINK,\n  'xlink:title': XLINK,\n  'xlink:type': XLINK,\n  'xml:base': XML,\n  'xml:lang': XML,\n  'xml:space': XML,\n  xmlns: XMLNS,\n  'xmlns:xlink': XMLNS,\n};\n\nexport function getAttrNamespace(attrName: string): string | undefined {\n  return WHITELIST[attrName];\n}\n\nconst DEFLATE_TAG_TABLE: {\n  [tagName: string]: WellKnownTagName | undefined;\n} = {\n  div: WellKnownTagNames.div,\n  span: WellKnownTagNames.span,\n  p: WellKnownTagNames.p,\n  a: WellKnownTagNames.a,\n};\n\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function deflateTagName(tagName: string): string | WellKnownTagName {\n  return DEFLATE_TAG_TABLE[tagName] ?? tagName;\n}\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nconst DEFLATE_ATTR_TABLE: {\n  [tagName: string]: WellKnownAttrName | undefined;\n} = {\n  class: WellKnownAttrNames.class,\n  id: WellKnownAttrNames.id,\n  value: WellKnownAttrNames.value,\n  name: WellKnownAttrNames.name,\n  type: WellKnownAttrNames.type,\n  style: WellKnownAttrNames.style,\n  href: WellKnownAttrNames.href,\n};\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\n\nexport function deflateAttrName(attrName: string): string | WellKnownAttrName {\n  return DEFLATE_ATTR_TABLE[attrName] ?? attrName;\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n","import { ASTv2, maybeLoc, src } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\n\nimport { OptionalList } from '../../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../../shared/result';\nimport { getAttrNamespace } from '../../../../utils';\nimport * as mir from '../../../2-encoding/mir';\nimport { MODIFIER_KEYWORDS } from '../../keywords';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\n\nexport type ValidAttr = mir.StaticAttr | mir.DynamicAttr | mir.SplatAttr;\n\ntype ProcessedAttributes = {\n  attrs: ValidAttr[];\n  args: mir.NamedArguments;\n};\n\nexport interface Classified {\n  readonly dynamicFeatures: boolean;\n\n  arg(attr: ASTv2.AttrNode, classified: ClassifiedElement): Result<mir.NamedArgument>;\n  toStatement(classified: ClassifiedElement, prepared: PreparedArgs): Result<mir.Statement>;\n}\n\nexport class ClassifiedElement {\n  readonly delegate: Classified;\n\n  constructor(\n    readonly element: ASTv2.ElementNode,\n    delegate: Classified,\n    readonly state: NormalizationState\n  ) {\n    this.delegate = delegate;\n  }\n\n  toStatement(): Result<mir.Statement> {\n    return this.prepare().andThen((prepared) => this.delegate.toStatement(this, prepared));\n  }\n\n  private attr(attr: ASTv2.HtmlAttr): Result<ValidAttr> {\n    let name = attr.name;\n    let rawValue = attr.value;\n    let namespace = getAttrNamespace(name.chars) || undefined;\n\n    if (ASTv2.isLiteral(rawValue, 'string')) {\n      return Ok(\n        new mir.StaticAttr({\n          loc: attr.loc,\n          name,\n          value: rawValue.toSlice(),\n          namespace,\n          kind: {\n            component: this.delegate.dynamicFeatures,\n          },\n        })\n      );\n    }\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk((value) => {\n      let isTrusting = attr.trusting;\n\n      return new mir.DynamicAttr({\n        loc: attr.loc,\n        name,\n        value: value,\n        namespace,\n        kind: {\n          trusting: isTrusting,\n          component: this.delegate.dynamicFeatures,\n        },\n      });\n    });\n  }\n\n  private modifier(modifier: ASTv2.ElementModifier): Result<mir.Modifier> {\n    let translated = MODIFIER_KEYWORDS.translate(modifier, this.state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(modifier.callee, this.state);\n    let args = VISIT_EXPRS.Args(modifier.args, this.state);\n\n    return Result.all(head, args).mapOk(\n      ([head, args]) =>\n        new mir.Modifier({\n          loc: modifier.loc,\n          callee: head,\n          args,\n        })\n    );\n  }\n\n  private attrs(): Result<ProcessedAttributes> {\n    let attrs = new ResultArray<ValidAttr>();\n    let args = new ResultArray<mir.NamedArgument>();\n\n    // Unlike most attributes, the `type` attribute can change how\n    // subsequent attributes are interpreted by the browser. To address\n    // this, in simple cases, we special case the `type` attribute to be set\n    // last. For elements with splattributes, where attribute order affects\n    // precedence, this re-ordering happens at runtime instead.\n    // See https://github.com/glimmerjs/glimmer-vm/pull/726\n    let typeAttr: ASTv2.AttrNode | null = null;\n    let simple = this.element.attrs.filter((attr) => attr.type === 'SplatAttr').length === 0;\n\n    for (let attr of this.element.attrs) {\n      if (attr.type === 'SplatAttr') {\n        attrs.add(\n          Ok(new mir.SplatAttr({ loc: attr.loc, symbol: this.state.scope.allocateBlock('attrs') }))\n        );\n      } else if (attr.name.chars === 'type' && simple) {\n        typeAttr = attr;\n      } else {\n        attrs.add(this.attr(attr));\n      }\n    }\n\n    for (let arg of this.element.componentArgs) {\n      args.add(this.delegate.arg(arg, this));\n    }\n\n    if (typeAttr) {\n      attrs.add(this.attr(typeAttr));\n    }\n\n    return Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({\n      attrs,\n      args: new mir.NamedArguments({\n        loc: maybeLoc(args, src.SourceSpan.NON_EXISTENT),\n        entries: OptionalList(args),\n      }),\n    }));\n  }\n\n  private prepare(): Result<PreparedArgs> {\n    let attrs = this.attrs();\n    let modifiers = new ResultArray(this.element.modifiers.map((m) => this.modifier(m))).toArray();\n\n    return Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {\n      let { attrs, args } = result;\n\n      let elementParams = [...attrs, ...modifiers];\n\n      let params = new mir.ElementParameters({\n        loc: maybeLoc(elementParams, src.SourceSpan.NON_EXISTENT),\n        body: OptionalList(elementParams),\n      });\n\n      return { args, params };\n    });\n  }\n}\n\nexport interface PreparedArgs {\n  args: mir.NamedArguments;\n  params: mir.ElementParameters;\n}\n\nexport function hasDynamicFeatures({\n  attrs,\n  modifiers,\n}: Pick<ASTv2.ElementNode, 'attrs' | 'modifiers'>): boolean {\n  // ElementModifier needs the special ComponentOperations\n  if (modifiers.length > 0) {\n    return true;\n  }\n\n  // Splattributes need the special ComponentOperations to merge into\n  return !!attrs.filter((attr) => attr.type === 'SplatAttr')[0];\n}\n","import type { ASTv2 } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport * as mir from '../../../2-encoding/mir';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedComponent implements Classified {\n  readonly dynamicFeatures = true;\n\n  constructor(\n    private tag: mir.ExpressionNode,\n    private element: ASTv2.InvokeComponent\n  ) {}\n\n  arg(attr: ASTv2.ComponentArg, { state }: ClassifiedElement): Result<mir.NamedArgument> {\n    let name = attr.name;\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(attr.value), state).mapOk(\n      (value) =>\n        new mir.NamedArgument({\n          loc: attr.loc,\n          key: name,\n          value,\n        })\n    );\n  }\n\n  toStatement(component: ClassifiedElement, { args, params }: PreparedArgs): Result<mir.Statement> {\n    let { element, state } = component;\n\n    return this.blocks(state).mapOk(\n      (blocks) =>\n        new mir.Component({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          args,\n          blocks,\n        })\n    );\n  }\n\n  private blocks(state: NormalizationState): Result<mir.NamedBlocks> {\n    return VISIT_STMTS.NamedBlocks(this.element.blocks, state);\n  }\n}\n","import type { ASTv2, SourceSlice } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport { Err } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedSimpleElement implements Classified {\n  constructor(\n    private tag: SourceSlice,\n    private element: ASTv2.SimpleElement,\n    readonly dynamicFeatures: boolean\n  ) {}\n\n  readonly isComponent = false;\n\n  arg(attr: ASTv2.ComponentArg): Result<mir.NamedArgument> {\n    return Err(\n      generateSyntaxError(\n        `${attr.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\\`${this.tag.chars}\\`) is a regular, non-component HTML element.`,\n        attr.loc\n      )\n    );\n  }\n\n  toStatement(classified: ClassifiedElement, { params }: PreparedArgs): Result<mir.Statement> {\n    let { state, element } = classified;\n\n    let body = VISIT_STMTS.visitList(this.element.body, state);\n\n    return body.mapOk(\n      (body) =>\n        new mir.SimpleElement({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          body: body.toArray(),\n          dynamicFeatures: this.dynamicFeatures,\n        })\n    );\n  }\n}\n","import { ASTv2 } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../context';\n\nimport { OptionalList } from '../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { BLOCK_KEYWORDS } from '../keywords';\nimport { APPEND_KEYWORDS } from '../keywords/append';\nimport { ClassifiedElement, hasDynamicFeatures } from './element/classified';\nimport { ClassifiedComponent } from './element/component';\nimport { ClassifiedSimpleElement } from './element/simple-element';\nimport { VISIT_EXPRS } from './expressions';\n\nclass NormalizationStatements {\n  visitList(\n    nodes: readonly ASTv2.ContentNode[],\n    state: NormalizationState\n  ): Result<OptionalList<mir.Statement>> {\n    return new ResultArray(nodes.map((e) => VISIT_STMTS.visit(e, state)))\n      .toOptionalList()\n      .mapOk((list) => list.filter((s: mir.Statement | null): s is mir.Statement => s !== null));\n  }\n\n  visit(node: ASTv2.ContentNode, state: NormalizationState): Result<mir.Statement | null> {\n    switch (node.type) {\n      case 'GlimmerComment':\n        return Ok(null);\n      case 'AppendContent':\n        return this.AppendContent(node, state);\n      case 'HtmlText':\n        return Ok(this.TextNode(node));\n      case 'HtmlComment':\n        return Ok(this.HtmlComment(node));\n      case 'InvokeBlock':\n        return this.InvokeBlock(node, state);\n      case 'InvokeComponent':\n        return this.Component(node, state);\n      case 'SimpleElement':\n        return this.SimpleElement(node, state);\n    }\n  }\n\n  InvokeBlock(node: ASTv2.InvokeBlock, state: NormalizationState): Result<mir.Statement> {\n    let translated = BLOCK_KEYWORDS.translate(node, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(node.callee, state);\n    let args = VISIT_EXPRS.Args(node.args, state);\n\n    return Result.all(head, args).andThen(([head, args]) =>\n      this.NamedBlocks(node.blocks, state).mapOk(\n        (blocks) =>\n          new mir.InvokeBlock({\n            loc: node.loc,\n            head,\n            args,\n            blocks,\n          })\n      )\n    );\n  }\n\n  NamedBlocks(blocks: ASTv2.NamedBlocks, state: NormalizationState): Result<mir.NamedBlocks> {\n    let list = new ResultArray(blocks.blocks.map((b) => this.NamedBlock(b, state)));\n\n    return list\n      .toArray()\n      .mapOk((list) => new mir.NamedBlocks({ loc: blocks.loc, blocks: OptionalList(list) }));\n  }\n\n  NamedBlock(named: ASTv2.NamedBlock, state: NormalizationState): Result<mir.NamedBlock> {\n    let body = state.visitBlock(named.block);\n\n    return body.mapOk((body) => {\n      return new mir.NamedBlock({\n        loc: named.loc,\n        name: named.name,\n        body: body.toArray(),\n        scope: named.block.scope,\n      });\n    });\n  }\n\n  SimpleElement(element: ASTv2.SimpleElement, state: NormalizationState): Result<mir.Statement> {\n    return new ClassifiedElement(\n      element,\n      new ClassifiedSimpleElement(element.tag, element, hasDynamicFeatures(element)),\n      state\n    ).toStatement();\n  }\n\n  Component(component: ASTv2.InvokeComponent, state: NormalizationState): Result<mir.Statement> {\n    return VISIT_EXPRS.visit(component.callee, state).andThen((callee) =>\n      new ClassifiedElement(\n        component,\n        new ClassifiedComponent(callee, component),\n        state\n      ).toStatement()\n    );\n  }\n\n  AppendContent(append: ASTv2.AppendContent, state: NormalizationState): Result<mir.Statement> {\n    let translated = APPEND_KEYWORDS.translate(append, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let value = VISIT_EXPRS.visit(append.value, state);\n\n    return value.mapOk((value) => {\n      if (append.trusting) {\n        return new mir.AppendTrustedHTML({\n          loc: append.loc,\n          html: value,\n        });\n      } else {\n        return new mir.AppendTextNode({\n          loc: append.loc,\n          text: value,\n        });\n      }\n    });\n  }\n\n  TextNode(text: ASTv2.HtmlText): mir.Statement {\n    return new mir.AppendTextNode({\n      loc: text.loc,\n      text: new ASTv2.LiteralExpression({ loc: text.loc, value: text.chars }),\n    });\n  }\n\n  HtmlComment(comment: ASTv2.HtmlComment): mir.Statement {\n    return new mir.AppendComment({\n      loc: comment.loc,\n      value: comment.text,\n    });\n  }\n}\n\nexport const VISIT_STMTS = new NormalizationStatements();\n","import type { ASTv2, SymbolTable } from '@glimmer/syntax';\n\nimport type { OptionalList } from '../../shared/list';\nimport type { Result } from '../../shared/result';\nimport type * as mir from '../2-encoding/mir';\n\nimport { VISIT_STMTS } from './visitors/statements';\n\n/**\n * This is the mutable state for this compiler pass.\n */\nexport class NormalizationState {\n  _currentScope: SymbolTable;\n  _cursorCount = 0;\n\n  constructor(\n    block: SymbolTable,\n    readonly isStrict: boolean\n  ) {\n    this._currentScope = block;\n  }\n\n  generateUniqueCursor(): string {\n    return `%cursor:${this._cursorCount++}%`;\n  }\n\n  get scope(): SymbolTable {\n    return this._currentScope;\n  }\n\n  visitBlock(block: ASTv2.Block): Result<OptionalList<mir.Statement>> {\n    let oldBlock = this._currentScope;\n    this._currentScope = block.scope;\n\n    try {\n      return VISIT_STMTS.visitList(block.body, this);\n    } finally {\n      this._currentScope = oldBlock;\n    }\n  }\n}\n","/// ResolutionType ///\n\nexport type VALUE_RESOLUTION = 'value';\nexport const VALUE_RESOLUTION: VALUE_RESOLUTION = 'value';\n\nexport type COMPONENT_RESOLUTION = 'component';\nexport const COMPONENT_RESOLUTION: COMPONENT_RESOLUTION = 'component';\n\nexport type HELPER_RESOLUTION = 'helper';\nexport const HELPER_RESOLUTION: HELPER_RESOLUTION = 'helper';\n\nexport type MODIFIER_RESOLUTION = 'modifier';\nexport const MODIFIER_RESOLUTION: MODIFIER_RESOLUTION = 'modifier';\n\nexport type COMPONENT_OR_HELPER_RESOLUTION = 'component or helper';\nexport const COMPONENT_OR_HELPER_RESOLUTION: COMPONENT_OR_HELPER_RESOLUTION = 'component or helper';\n\nexport type ResolutionType =\n  | VALUE_RESOLUTION\n  | COMPONENT_RESOLUTION\n  | HELPER_RESOLUTION\n  | MODIFIER_RESOLUTION\n  | COMPONENT_OR_HELPER_RESOLUTION;\n","import type { HasSourceSpan } from '@glimmer/syntax';\nimport { CURRIED_COMPONENT, CURRIED_HELPER } from '@glimmer/constants';\nimport { generateSyntaxError, loc } from '@glimmer/syntax';\n\nimport type { Result } from '../../../shared/result';\nimport type * as mir from '../../2-encoding/mir';\nimport type { ResolutionType } from './constants';\n\nimport { Err, Ok } from '../../../shared/result';\nimport {\n  COMPONENT_OR_HELPER_RESOLUTION,\n  COMPONENT_RESOLUTION,\n  HELPER_RESOLUTION,\n  MODIFIER_RESOLUTION,\n  VALUE_RESOLUTION,\n} from './constants';\n\nexport default class StrictModeValidationPass {\n  // This is done at the end of all the keyword normalizations\n  // At this point any free variables that isn't a valid keyword\n  // in its context should be considered a syntax error. We\n  // probably had various opportunities to do this inline in the\n  // earlier passes, but this aims to produce a better syntax\n  // error as we don't always have the right loc-context to do\n  // so in the other spots.\n  static validate(template: mir.Template): Result<mir.Template> {\n    return new this(template).validate();\n  }\n\n  private constructor(private template: mir.Template) {}\n\n  validate(): Result<mir.Template> {\n    return this.Statements(this.template.body).mapOk(() => this.template);\n  }\n\n  Statements(statements: mir.Statement[]): Result<null> {\n    let result = Ok(null);\n\n    for (let statement of statements) {\n      result = result.andThen(() => this.Statement(statement));\n    }\n\n    return result;\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): Result<null> {\n    let result = Ok(null);\n\n    for (let block of blocks.toArray()) {\n      result = result.andThen(() => this.NamedBlock(block));\n    }\n\n    return result;\n  }\n\n  NamedBlock(block: mir.NamedBlock): Result<null> {\n    return this.Statements(block.body);\n  }\n\n  Statement(statement: mir.Statement): Result<null> {\n    switch (statement.type) {\n      case 'InElement':\n        return this.InElement(statement);\n\n      case 'Debugger':\n        return Ok(null);\n\n      case 'Yield':\n        return this.Yield(statement);\n\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(statement);\n\n      case 'AppendTextNode':\n        return this.AppendTextNode(statement);\n\n      case 'Component':\n        return this.Component(statement);\n\n      case 'SimpleElement':\n        return this.SimpleElement(statement);\n\n      case 'InvokeBlock':\n        return this.InvokeBlock(statement);\n\n      case 'AppendComment':\n        return Ok(null);\n\n      case 'If':\n        return this.If(statement);\n\n      case 'Each':\n        return this.Each(statement);\n\n      case 'Let':\n        return this.Let(statement);\n\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(statement);\n\n      case 'InvokeComponent':\n        return this.InvokeComponent(statement);\n    }\n  }\n\n  Expressions(expressions: mir.ExpressionNode[]): Result<null> {\n    let result = Ok(null);\n\n    for (let expression of expressions) {\n      result = result.andThen(() => this.Expression(expression));\n    }\n\n    return result;\n  }\n\n  Expression(\n    expression: mir.ExpressionNode,\n    span: HasSourceSpan = expression,\n    resolution?: ResolutionType\n  ): Result<null> {\n    switch (expression.type) {\n      case 'Literal':\n      case 'Keyword':\n      case 'Missing':\n      case 'This':\n      case 'Arg':\n      case 'Local':\n      case 'HasBlock':\n      case 'HasBlockParams':\n      case 'GetDynamicVar':\n        return Ok(null);\n\n      case 'PathExpression':\n        return this.Expression(expression.head, span, resolution);\n\n      case 'Free':\n        return this.errorFor(expression.name, span, resolution);\n\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expression, span, resolution);\n\n      case 'CallExpression':\n        return this.CallExpression(expression, span, resolution ?? HELPER_RESOLUTION);\n\n      case 'Not':\n        return this.Expression(expression.value, span, resolution);\n\n      case 'IfInline':\n        return this.IfInline(expression);\n\n      case 'Curry':\n        return this.Curry(expression);\n\n      case 'Log':\n        return this.Log(expression);\n    }\n  }\n\n  Args(args: mir.Args): Result<null> {\n    return this.Positional(args.positional).andThen(() => this.NamedArguments(args.named));\n  }\n\n  Positional(positional: mir.Positional, span?: HasSourceSpan): Result<null> {\n    let result = Ok(null);\n    let expressions = positional.list.toArray();\n\n    // For cases like {{yield foo}}, when there is only a single argument, it\n    // makes for a slightly better error to report that entire span. However,\n    // when there are more than one, we need to be specific.\n    if (expressions.length === 1) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme PresentArray\n      result = this.Expression(expressions[0]!, span);\n    } else {\n      result = this.Expressions(expressions);\n    }\n\n    return result;\n  }\n\n  NamedArguments({ entries }: mir.NamedArguments): Result<null> {\n    let result = Ok(null);\n\n    for (let arg of entries.toArray()) {\n      result = result.andThen(() => this.NamedArgument(arg));\n    }\n\n    return result;\n  }\n\n  NamedArgument(arg: mir.NamedArgument): Result<null> {\n    if (arg.value.type === 'CallExpression') {\n      return this.Expression(arg.value, arg, HELPER_RESOLUTION);\n    } else {\n      return this.Expression(arg.value, arg);\n    }\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): Result<null> {\n    let result = Ok(null);\n\n    for (let param of body.toArray()) {\n      result = result.andThen(() => this.ElementParameter(param));\n    }\n\n    return result;\n  }\n\n  ElementParameter(param: mir.ElementParameter): Result<null> {\n    switch (param.type) {\n      case 'StaticAttr':\n        return Ok(null);\n      case 'DynamicAttr':\n        return this.DynamicAttr(param);\n      case 'Modifier':\n        return this.Modifier(param);\n      case 'SplatAttr':\n        return Ok(null);\n    }\n  }\n\n  DynamicAttr(attr: mir.DynamicAttr): Result<null> {\n    if (attr.value.type === 'CallExpression') {\n      return this.Expression(attr.value, attr, HELPER_RESOLUTION);\n    } else {\n      return this.Expression(attr.value, attr);\n    }\n  }\n\n  Modifier(modifier: mir.Modifier): Result<null> {\n    return this.Expression(modifier.callee, modifier, MODIFIER_RESOLUTION).andThen(() =>\n      this.Args(modifier.args)\n    );\n  }\n\n  InElement(inElement: mir.InElement): Result<null> {\n    return (\n      this.Expression(inElement.destination)\n        // Unfortunately we lost the `insertBefore=` part of the span\n        .andThen(() => this.Expression(inElement.insertBefore))\n        .andThen(() => this.NamedBlock(inElement.block))\n    );\n  }\n\n  Yield(statement: mir.Yield): Result<null> {\n    return this.Positional(statement.positional, statement);\n  }\n\n  AppendTrustedHTML(statement: mir.AppendTrustedHTML): Result<null> {\n    return this.Expression(statement.html, statement);\n  }\n\n  AppendTextNode(statement: mir.AppendTextNode): Result<null> {\n    if (statement.text.type === 'CallExpression') {\n      return this.Expression(statement.text, statement, COMPONENT_OR_HELPER_RESOLUTION);\n    } else {\n      return this.Expression(statement.text, statement);\n    }\n  }\n\n  Component(statement: mir.Component): Result<null> {\n    return this.Expression(statement.tag, statement, COMPONENT_RESOLUTION)\n      .andThen(() => this.ElementParameters(statement.params))\n      .andThen(() => this.NamedArguments(statement.args))\n      .andThen(() => this.NamedBlocks(statement.blocks));\n  }\n\n  SimpleElement(statement: mir.SimpleElement): Result<null> {\n    return this.ElementParameters(statement.params).andThen(() => this.Statements(statement.body));\n  }\n\n  InvokeBlock(statement: mir.InvokeBlock): Result<null> {\n    return this.Expression(statement.head, statement.head, COMPONENT_RESOLUTION)\n      .andThen(() => this.Args(statement.args))\n      .andThen(() => this.NamedBlocks(statement.blocks));\n  }\n\n  If(statement: mir.If): Result<null> {\n    return this.Expression(statement.condition, statement)\n      .andThen(() => this.NamedBlock(statement.block))\n      .andThen(() => {\n        if (statement.inverse) {\n          return this.NamedBlock(statement.inverse);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Each(statement: mir.Each): Result<null> {\n    return this.Expression(statement.value, statement)\n      .andThen(() => {\n        if (statement.key) {\n          return this.Expression(statement.key, statement);\n        } else {\n          return Ok(null);\n        }\n      })\n      .andThen(() => this.NamedBlock(statement.block))\n      .andThen(() => {\n        if (statement.inverse) {\n          return this.NamedBlock(statement.inverse);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Let(statement: mir.Let): Result<null> {\n    return this.Positional(statement.positional).andThen(() => this.NamedBlock(statement.block));\n  }\n\n  WithDynamicVars(statement: mir.WithDynamicVars): Result<null> {\n    return this.NamedArguments(statement.named).andThen(() => this.NamedBlock(statement.block));\n  }\n\n  InvokeComponent(statement: mir.InvokeComponent): Result<null> {\n    return this.Expression(statement.definition, statement, COMPONENT_RESOLUTION)\n      .andThen(() => this.Args(statement.args))\n      .andThen(() => {\n        if (statement.blocks) {\n          return this.NamedBlocks(statement.blocks);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  InterpolateExpression(\n    expression: mir.InterpolateExpression,\n    span: HasSourceSpan,\n    resolution?: ResolutionType\n  ): Result<null> {\n    let expressions = expression.parts.toArray();\n\n    if (expressions.length === 1) {\n      return this.Expression(expressions[0], span, resolution);\n    } else {\n      return this.Expressions(expressions);\n    }\n  }\n\n  CallExpression(\n    expression: mir.CallExpression,\n    span: HasSourceSpan,\n    resolution?: ResolutionType\n  ): Result<null> {\n    return this.Expression(expression.callee, span, resolution).andThen(() =>\n      this.Args(expression.args)\n    );\n  }\n\n  IfInline(expression: mir.IfInline): Result<null> {\n    return this.Expression(expression.condition)\n      .andThen(() => this.Expression(expression.truthy))\n      .andThen(() => {\n        if (expression.falsy) {\n          return this.Expression(expression.falsy);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Curry(expression: mir.Curry): Result<null> {\n    let resolution: ResolutionType;\n\n    if (expression.curriedType === CURRIED_COMPONENT) {\n      resolution = COMPONENT_RESOLUTION;\n    } else if (expression.curriedType === CURRIED_HELPER) {\n      resolution = HELPER_RESOLUTION;\n    } else {\n      resolution = MODIFIER_RESOLUTION;\n    }\n\n    return this.Expression(expression.definition, expression, resolution).andThen(() =>\n      this.Args(expression.args)\n    );\n  }\n\n  Log(expression: mir.Log): Result<null> {\n    return this.Positional(expression.positional, expression);\n  }\n\n  errorFor(\n    name: string,\n    span: HasSourceSpan,\n    type: ResolutionType = VALUE_RESOLUTION\n  ): Result<never> {\n    return Err(\n      generateSyntaxError(\n        `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${name}`,\n        loc(span)\n      )\n    );\n  }\n}\n","import type {\n  CurriedType,\n  Nullable,\n  SerializedInlineBlock,\n  SerializedTemplateBlock,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { CURRIED_COMPONENT, CURRIED_HELPER, CURRIED_MODIFIER } from '@glimmer/constants';\nimport { exhausted } from '@glimmer/debug-util';\nimport { dict } from '@glimmer/util';\nimport { SexpOpcodes as Op } from '@glimmer/wire-format';\n\nimport { inflateAttrName, inflateTagName } from './utils';\n\nexport default class WireFormatDebugger {\n  private upvars: string[];\n  private symbols: string[];\n\n  constructor([_statements, symbols, upvars]: SerializedTemplateBlock) {\n    this.upvars = upvars;\n    this.symbols = symbols;\n  }\n\n  format(program: SerializedTemplateBlock): unknown {\n    let out = [];\n\n    for (let statement of program[0]) {\n      out.push(this.formatOpcode(statement));\n    }\n\n    return out;\n  }\n\n  formatOpcode(opcode: WireFormat.Syntax): unknown {\n    if (Array.isArray(opcode)) {\n      switch (opcode[0]) {\n        case Op.Append:\n          return ['append', this.formatOpcode(opcode[1])];\n        case Op.TrustingAppend:\n          return ['trusting-append', this.formatOpcode(opcode[1])];\n\n        case Op.Block:\n          return [\n            'block',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.InElement:\n          return [\n            'in-element',\n            opcode[1],\n            this.formatOpcode(opcode[2]),\n            opcode[3] ? this.formatOpcode(opcode[3]) : undefined,\n          ];\n\n        case Op.OpenElement:\n          return ['open-element', inflateTagName(opcode[1])];\n\n        case Op.OpenElementWithSplat:\n          return ['open-element-with-splat', inflateTagName(opcode[1])];\n\n        case Op.CloseElement:\n          return ['close-element'];\n\n        case Op.FlushElement:\n          return ['flush-element'];\n\n        case Op.StaticAttr:\n          return ['static-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.StaticComponentAttr:\n          return ['static-component-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.DynamicAttr:\n          return [\n            'dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.ComponentAttr:\n          return [\n            'component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.AttrSplat:\n          return ['attr-splat'];\n\n        case Op.Yield:\n          return ['yield', opcode[1], this.formatParams(opcode[2])];\n\n        case Op.DynamicArg:\n          return ['dynamic-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.StaticArg:\n          return ['static-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.TrustingDynamicAttr:\n          return [\n            'trusting-dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.TrustingComponentAttr:\n          return [\n            'trusting-component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.Debugger:\n          return ['debugger', opcode[1]];\n\n        case Op.Comment:\n          return ['comment', opcode[1]];\n\n        case Op.Modifier:\n          return [\n            'modifier',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Component:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatElementParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.HasBlock:\n          return ['has-block', this.formatOpcode(opcode[1])];\n\n        case Op.HasBlockParams:\n          return ['has-block-params', this.formatOpcode(opcode[1])];\n\n        case Op.Curry:\n          return [\n            'curry',\n            this.formatOpcode(opcode[1]),\n            this.formatCurryType(opcode[2]),\n            this.formatParams(opcode[3]),\n            this.formatHash(opcode[4]),\n          ];\n\n        case Op.Undefined:\n          return ['undefined'];\n\n        case Op.Call:\n          return [\n            'call',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Concat:\n          return ['concat', this.formatParams(opcode[1] as WireFormat.Core.Params)];\n\n        case Op.GetStrictKeyword:\n          return ['get-strict-free', this.upvars[opcode[1]]];\n\n        case Op.GetFreeAsComponentOrHelperHead:\n          return ['GetFreeAsComponentOrHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsHelperHead:\n          return ['GetFreeAsHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsComponentHead:\n          return ['GetFreeAsComponentHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsModifierHead:\n          return ['GetFreeAsModifierHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetSymbol: {\n          if (opcode[1] === 0) {\n            return ['get-symbol', 'this', opcode[2]];\n          } else {\n            return ['get-symbol', this.symbols[opcode[1] - 1], opcode[2]];\n          }\n        }\n\n        case Op.GetLexicalSymbol: {\n          return ['get-template-symbol', opcode[1], opcode[2]];\n        }\n\n        case Op.If:\n          return [\n            'if',\n            this.formatOpcode(opcode[1]),\n            this.formatBlock(opcode[2]),\n            opcode[3] ? this.formatBlock(opcode[3]) : null,\n          ];\n\n        case Op.IfInline:\n          return ['if-inline'];\n\n        case Op.Not:\n          return ['not'];\n\n        case Op.Each:\n          return [\n            'each',\n            this.formatOpcode(opcode[1]),\n            opcode[2] ? this.formatOpcode(opcode[2]) : null,\n            this.formatBlock(opcode[3]),\n            opcode[4] ? this.formatBlock(opcode[4]) : null,\n          ];\n\n        case Op.Let:\n          return ['let', this.formatParams(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.Log:\n          return ['log', this.formatParams(opcode[1])];\n\n        case Op.WithDynamicVars:\n          return ['-with-dynamic-vars', this.formatHash(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.GetDynamicVar:\n          return ['-get-dynamic-vars', this.formatOpcode(opcode[1])];\n\n        case Op.InvokeComponent:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n      }\n    } else {\n      return opcode;\n    }\n  }\n\n  private formatCurryType(value: CurriedType) {\n    switch (value) {\n      case CURRIED_COMPONENT:\n        return 'component';\n      case CURRIED_HELPER:\n        return 'helper';\n      case CURRIED_MODIFIER:\n        return 'modifier';\n      default:\n        exhausted(value);\n    }\n  }\n\n  private formatElementParams(\n    opcodes: Nullable<WireFormat.ElementParameter[]>\n  ): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatParams(opcodes: Nullable<WireFormat.Expression[]>): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatHash(hash: WireFormat.Core.Hash): Nullable<object> {\n    if (hash === null) return null;\n\n    return hash[0].reduce((accum, key, index) => {\n      accum[key] = this.formatOpcode(hash[1][index]);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlocks(blocks: WireFormat.Core.Blocks): Nullable<object> {\n    if (blocks === null) return null;\n\n    return blocks[0].reduce((accum, key, index) => {\n      accum[key] = this.formatBlock(blocks[1][index] as SerializedInlineBlock);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlock(block: SerializedInlineBlock): object {\n    return {\n      statements: block[0].map((s) => this.formatOpcode(s)),\n      parameters: block[1],\n    };\n  }\n}\n","import type { PresentArray, WireFormat } from '@glimmer/interfaces';\nimport type { ASTv2 } from '@glimmer/syntax';\nimport {\n  assertPresentArray,\n  isPresentArray,\n  localAssert,\n  mapPresentArray,\n} from '@glimmer/debug-util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type * as mir from './mir';\n\nexport type HashPair = [string, WireFormat.Expression];\n\nexport class ExpressionEncoder {\n  expr(expr: mir.ExpressionNode): WireFormat.Expression {\n    switch (expr.type) {\n      case 'Missing':\n        return undefined;\n      case 'Literal':\n        return this.Literal(expr);\n      case 'Keyword':\n        return this.Keyword(expr);\n      case 'CallExpression':\n        return this.CallExpression(expr);\n      case 'PathExpression':\n        return this.PathExpression(expr);\n      case 'Arg':\n        return [SexpOpcodes.GetSymbol, expr.symbol];\n      case 'Local':\n        return this.Local(expr);\n      case 'This':\n        return [SexpOpcodes.GetSymbol, 0];\n      case 'Free':\n        return [expr.resolution.resolution(), expr.symbol];\n      case 'HasBlock':\n        return this.HasBlock(expr);\n      case 'HasBlockParams':\n        return this.HasBlockParams(expr);\n      case 'Curry':\n        return this.Curry(expr);\n      case 'Not':\n        return this.Not(expr);\n      case 'IfInline':\n        return this.IfInline(expr);\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expr);\n      case 'GetDynamicVar':\n        return this.GetDynamicVar(expr);\n      case 'Log':\n        return this.Log(expr);\n    }\n  }\n\n  Literal({\n    value,\n  }: ASTv2.LiteralExpression): WireFormat.Expressions.Value | WireFormat.Expressions.Undefined {\n    if (value === undefined) {\n      return [SexpOpcodes.Undefined];\n    } else {\n      return value;\n    }\n  }\n\n  Missing(): undefined {\n    return undefined;\n  }\n\n  HasBlock({ symbol }: mir.HasBlock): WireFormat.Expressions.HasBlock {\n    return [SexpOpcodes.HasBlock, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  HasBlockParams({ symbol }: mir.HasBlockParams): WireFormat.Expressions.HasBlockParams {\n    return [SexpOpcodes.HasBlockParams, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  Curry({ definition, curriedType, args }: mir.Curry): WireFormat.Expressions.Curry {\n    return [\n      SexpOpcodes.Curry,\n      EXPR.expr(definition),\n      curriedType,\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n    ];\n  }\n\n  Local({\n    isTemplateLocal,\n    symbol,\n  }: ASTv2.LocalVarReference):\n    | WireFormat.Expressions.GetSymbol\n    | WireFormat.Expressions.GetLexicalSymbol {\n    return [isTemplateLocal ? SexpOpcodes.GetLexicalSymbol : SexpOpcodes.GetSymbol, symbol];\n  }\n\n  Keyword({ symbol }: ASTv2.KeywordExpression): WireFormat.Expressions.GetStrictFree {\n    return [SexpOpcodes.GetStrictKeyword, symbol];\n  }\n\n  PathExpression({ head, tail }: mir.PathExpression): WireFormat.Expressions.GetPath {\n    let getOp = EXPR.expr(head) as WireFormat.Expressions.GetVar;\n    localAssert(getOp[0] !== SexpOpcodes.GetStrictKeyword, '[BUG] keyword in a PathExpression');\n    return [...getOp, EXPR.Tail(tail)];\n  }\n\n  InterpolateExpression({ parts }: mir.InterpolateExpression): WireFormat.Expressions.Concat {\n    return [SexpOpcodes.Concat, parts.map((e) => EXPR.expr(e)).toArray()];\n  }\n\n  CallExpression({ callee, args }: mir.CallExpression): WireFormat.Expressions.Helper {\n    return [SexpOpcodes.Call, EXPR.expr(callee), ...EXPR.Args(args)];\n  }\n\n  Tail({ members }: mir.Tail): PresentArray<string> {\n    return mapPresentArray(members, (member) => member.chars);\n  }\n\n  Args({ positional, named }: mir.Args): WireFormat.Core.Args {\n    return [this.Positional(positional), this.NamedArguments(named)];\n  }\n\n  Positional({ list }: mir.Positional): WireFormat.Core.Params {\n    return list.map((l) => EXPR.expr(l)).toPresentArray();\n  }\n\n  NamedArgument({ key, value }: mir.NamedArgument): HashPair {\n    return [key.chars, EXPR.expr(value)];\n  }\n\n  NamedArguments({ entries: pairs }: mir.NamedArguments): WireFormat.Core.Hash {\n    let list = pairs.toArray();\n\n    if (isPresentArray(list)) {\n      let names: string[] = [];\n      let values: WireFormat.Expression[] = [];\n\n      for (let pair of list) {\n        let [name, value] = EXPR.NamedArgument(pair);\n        names.push(name);\n        values.push(value);\n      }\n\n      assertPresentArray(names);\n      assertPresentArray(values);\n\n      return [names, values];\n    } else {\n      return null;\n    }\n  }\n\n  Not({ value }: mir.Not): WireFormat.Expressions.Not {\n    return [SexpOpcodes.Not, EXPR.expr(value)];\n  }\n\n  IfInline({ condition, truthy, falsy }: mir.IfInline): WireFormat.Expressions.IfInline {\n    let expr = [SexpOpcodes.IfInline, EXPR.expr(condition), EXPR.expr(truthy)];\n\n    if (falsy) {\n      expr.push(EXPR.expr(falsy));\n    }\n\n    return expr as WireFormat.Expressions.IfInline;\n  }\n\n  GetDynamicVar({ name }: mir.GetDynamicVar): WireFormat.Expressions.GetDynamicVar {\n    return [SexpOpcodes.GetDynamicVar, EXPR.expr(name)];\n  }\n\n  Log({ positional }: mir.Log): WireFormat.Expressions.Log {\n    return [SexpOpcodes.Log, this.Positional(positional)];\n  }\n}\n\nexport const EXPR = new ExpressionEncoder();\n","import type {\n  AttrOpcode,\n  ComponentAttrOpcode,\n  DynamicAttrOpcode,\n  StaticAttrOpcode,\n  StaticComponentAttrOpcode,\n  TrustingComponentAttrOpcode,\n  TrustingDynamicAttrOpcode,\n  WellKnownAttrName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { exhausted } from '@glimmer/debug-util';\nimport { LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { OptionalList } from '../../shared/list';\nimport type * as mir from './mir';\n\nimport { deflateAttrName, deflateTagName } from '../../utils';\nimport { EXPR } from './expressions';\n\nclass WireStatements<S extends WireFormat.Statement = WireFormat.Statement> {\n  constructor(private statements: readonly S[]) {}\n\n  toArray(): readonly S[] {\n    return this.statements;\n  }\n}\n\nexport class ContentEncoder {\n  list(statements: mir.Statement[]): WireFormat.Statement[] {\n    let out: WireFormat.Statement[] = [];\n\n    for (let statement of statements) {\n      let result = CONTENT.content(statement);\n\n      if (result instanceof WireStatements) {\n        out.push(...result.toArray());\n      } else {\n        out.push(result);\n      }\n    }\n\n    return out;\n  }\n\n  content(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    if (LOCAL_TRACE_LOGGING) {\n      LOCAL_LOGGER.debug(`encoding`, stmt);\n    }\n\n    return this.visitContent(stmt);\n  }\n\n  private visitContent(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    switch (stmt.type) {\n      case 'Debugger':\n        return [SexpOpcodes.Debugger, ...stmt.scope.getDebugInfo(), {}];\n      case 'AppendComment':\n        return this.AppendComment(stmt);\n      case 'AppendTextNode':\n        return this.AppendTextNode(stmt);\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(stmt);\n      case 'Yield':\n        return this.Yield(stmt);\n      case 'Component':\n        return this.Component(stmt);\n      case 'SimpleElement':\n        return this.SimpleElement(stmt);\n      case 'InElement':\n        return this.InElement(stmt);\n      case 'InvokeBlock':\n        return this.InvokeBlock(stmt);\n      case 'If':\n        return this.If(stmt);\n      case 'Each':\n        return this.Each(stmt);\n      case 'Let':\n        return this.Let(stmt);\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(stmt);\n      case 'InvokeComponent':\n        return this.InvokeComponent(stmt);\n      default:\n        return exhausted(stmt);\n    }\n  }\n\n  Yield({ to, positional }: mir.Yield): WireFormat.Statements.Yield {\n    return [SexpOpcodes.Yield, to, EXPR.Positional(positional)];\n  }\n\n  InElement({\n    guid,\n    insertBefore,\n    destination,\n    block,\n  }: mir.InElement): WireFormat.Statements.InElement {\n    let wireBlock = CONTENT.NamedBlock(block)[1];\n    // let guid = args.guid;\n    let wireDestination = EXPR.expr(destination);\n    let wireInsertBefore = EXPR.expr(insertBefore);\n\n    if (wireInsertBefore === undefined) {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination];\n    } else {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination, wireInsertBefore];\n    }\n  }\n\n  InvokeBlock({ head, args, blocks }: mir.InvokeBlock): WireFormat.Statements.Block {\n    return [SexpOpcodes.Block, EXPR.expr(head), ...EXPR.Args(args), CONTENT.NamedBlocks(blocks)];\n  }\n\n  AppendTrustedHTML({ html }: mir.AppendTrustedHTML): WireFormat.Statements.TrustingAppend {\n    return [SexpOpcodes.TrustingAppend, EXPR.expr(html)];\n  }\n\n  AppendTextNode({ text }: mir.AppendTextNode): WireFormat.Statements.Append {\n    return [SexpOpcodes.Append, EXPR.expr(text)];\n  }\n\n  AppendComment({ value }: mir.AppendComment): WireFormat.Statements.Comment {\n    return [SexpOpcodes.Comment, value.chars];\n  }\n\n  SimpleElement({ tag, params, body, dynamicFeatures }: mir.SimpleElement): WireStatements {\n    let op = dynamicFeatures ? SexpOpcodes.OpenElementWithSplat : SexpOpcodes.OpenElement;\n    return new WireStatements<WireFormat.Statement | WireFormat.ElementParameter>([\n      [op, deflateTagName(tag.chars)],\n      ...CONTENT.ElementParameters(params).toArray(),\n      [SexpOpcodes.FlushElement],\n      ...CONTENT.list(body),\n      [SexpOpcodes.CloseElement],\n    ]);\n  }\n\n  Component({ tag, params, args, blocks }: mir.Component): WireFormat.Statements.Component {\n    let wireTag = EXPR.expr(tag);\n    let wirePositional = CONTENT.ElementParameters(params);\n    let wireNamed = EXPR.NamedArguments(args);\n\n    let wireNamedBlocks = CONTENT.NamedBlocks(blocks);\n\n    return [\n      SexpOpcodes.Component,\n      wireTag,\n      wirePositional.toPresentArray(),\n      wireNamed,\n      wireNamedBlocks,\n    ];\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): OptionalList<WireFormat.ElementParameter> {\n    return body.map((p) => CONTENT.ElementParameter(p));\n  }\n\n  ElementParameter(param: mir.ElementParameter): WireFormat.ElementParameter {\n    switch (param.type) {\n      case 'SplatAttr':\n        return [SexpOpcodes.AttrSplat, param.symbol];\n      case 'DynamicAttr':\n        return [dynamicAttrOp(param.kind), ...dynamicAttr(param)];\n      case 'StaticAttr':\n        return [staticAttrOp(param.kind), ...staticAttr(param)];\n      case 'Modifier':\n        return [SexpOpcodes.Modifier, EXPR.expr(param.callee), ...EXPR.Args(param.args)];\n    }\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): WireFormat.Core.Blocks {\n    let names: string[] = [];\n    let serializedBlocks: WireFormat.SerializedInlineBlock[] = [];\n\n    for (let block of blocks.toArray()) {\n      let [name, serializedBlock] = CONTENT.NamedBlock(block);\n\n      names.push(name);\n      serializedBlocks.push(serializedBlock);\n    }\n\n    return names.length > 0 ? [names, serializedBlocks] : null;\n  }\n\n  NamedBlock({ name, body, scope }: mir.NamedBlock): WireFormat.Core.NamedBlock {\n    let nameChars = name.chars;\n    if (nameChars === 'inverse') {\n      nameChars = 'else';\n    }\n    return [nameChars, [CONTENT.list(body), scope.slots]];\n  }\n\n  If({ condition, block, inverse }: mir.If): WireFormat.Statements.If {\n    return [\n      SexpOpcodes.If,\n      EXPR.expr(condition),\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Each({ value, key, block, inverse }: mir.Each): WireFormat.Statements.Each {\n    return [\n      SexpOpcodes.Each,\n      EXPR.expr(value),\n      key ? EXPR.expr(key) : null,\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Let({ positional, block }: mir.Let): WireFormat.Statements.Let {\n    return [SexpOpcodes.Let, EXPR.Positional(positional), CONTENT.NamedBlock(block)[1]];\n  }\n\n  WithDynamicVars({ named, block }: mir.WithDynamicVars): WireFormat.Statements.WithDynamicVars {\n    return [SexpOpcodes.WithDynamicVars, EXPR.NamedArguments(named), CONTENT.NamedBlock(block)[1]];\n  }\n\n  InvokeComponent({\n    definition,\n    args,\n    blocks,\n  }: mir.InvokeComponent): WireFormat.Statements.InvokeComponent {\n    return [\n      SexpOpcodes.InvokeComponent,\n      EXPR.expr(definition),\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n      blocks ? CONTENT.NamedBlocks(blocks) : null,\n    ];\n  }\n}\n\nexport const CONTENT = new ContentEncoder();\n\nexport type StaticAttrArgs = [name: string | WellKnownAttrName, value: string, namespace?: string];\n\nfunction staticAttr({ name, value, namespace }: mir.StaticAttr): StaticAttrArgs {\n  let out: StaticAttrArgs = [deflateAttrName(name.chars), value.chars];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nexport type DynamicAttrArgs = [\n  name: string | WellKnownAttrName,\n  value: WireFormat.Expression,\n  namespace?: string,\n];\n\nfunction dynamicAttr({ name, value, namespace }: mir.DynamicAttr): DynamicAttrArgs {\n  let out: DynamicAttrArgs = [deflateAttrName(name.chars), EXPR.expr(value)];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nfunction staticAttrOp(kind: { component: boolean }): StaticAttrOpcode | StaticComponentAttrOpcode;\nfunction staticAttrOp(kind: { component: boolean }): AttrOpcode {\n  if (kind.component) {\n    return SexpOpcodes.StaticComponentAttr;\n  } else {\n    return SexpOpcodes.StaticAttr;\n  }\n}\n\nfunction dynamicAttrOp(\n  kind: mir.AttrKind\n):\n  | TrustingComponentAttrOpcode\n  | TrustingDynamicAttrOpcode\n  | ComponentAttrOpcode\n  | DynamicAttrOpcode {\n  if (kind.component) {\n    return kind.trusting ? SexpOpcodes.TrustingComponentAttr : SexpOpcodes.ComponentAttr;\n  } else {\n    return kind.trusting ? SexpOpcodes.TrustingDynamicAttr : SexpOpcodes.DynamicAttr;\n  }\n}\n","import type {\n  Nullable,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  TemplateJavascript,\n} from '@glimmer/interfaces';\nimport type {\n  PrecompileOptions,\n  PrecompileOptionsWithLexicalScope,\n  TemplateIdFn,\n} from '@glimmer/syntax';\nimport { LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\nimport { normalize, src } from '@glimmer/syntax';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport pass0 from './passes/1-normalization/index';\nimport { visit as pass2 } from './passes/2-encoding/index';\n\n// eslint-disable-next-line unused-imports/no-unused-vars\ndeclare function require(id: 'crypto'): Crypto;\ndeclare function require(id: string): unknown;\n\ninterface Crypto {\n  createHash(alg: 'sha1'): {\n    update(src: string, encoding: 'utf8'): void;\n    digest(encoding: 'base64'): string;\n  };\n}\n\nexport const defaultId: TemplateIdFn = (() => {\n  const req = (\n    typeof module === 'object' && typeof module.require === 'function'\n      ? // eslint-disable-next-line @typescript-eslint/unbound-method\n        module.require\n      : globalThis.require\n  ) as typeof require | undefined;\n\n  if (req) {\n    try {\n      const crypto = req('crypto');\n\n      const idFn: TemplateIdFn = (src) => {\n        const hash = crypto.createHash('sha1');\n        hash.update(src, 'utf8');\n        // trim to 6 bytes of data (2^48 - 1)\n        return hash.digest('base64').substring(0, 8);\n      };\n\n      idFn('test');\n\n      return idFn;\n    } catch {\n      // do nothing\n    }\n  }\n\n  return function idFn() {\n    return null;\n  };\n})();\n\nconst defaultOptions: PrecompileOptions = {\n  id: defaultId,\n};\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompileJSON(\n  string: Nullable<string>,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): [block: SerializedTemplateBlock, usedLocals: string[]] {\n  const source = new src.Source(string ?? '', options.meta?.moduleName);\n  const [ast, locals] = normalize(source, { lexicalScope: () => false, ...options });\n  const block = pass0(source, ast, options.strictMode ?? false).mapOk((pass2In) => {\n    return pass2(pass2In);\n  });\n\n  if (LOCAL_TRACE_LOGGING) {\n    LOCAL_LOGGER.debug(`Template ->`, block);\n  }\n\n  if (block.isOk) {\n    return [block.value, locals];\n  } else {\n    throw block.reason;\n  }\n}\n\n// UUID used as a unique placeholder for placing a snippet of JS code into\n// the otherwise JSON stringified value below.\nconst SCOPE_PLACEHOLDER = '796d24e6-2450-4fb0-8cdf-b65638b5ef70';\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompile(\n  source: string,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): TemplateJavascript {\n  const [block, usedLocals] = precompileJSON(source, options);\n\n  if ('emit' in options && options.emit?.debugSymbols && usedLocals.length > 0) {\n    block.push(usedLocals);\n  }\n\n  const moduleName = options.meta?.moduleName;\n  const idFn = options.id || defaultId;\n  const blockJSON = JSON.stringify(block);\n  const templateJSONObject: SerializedTemplateWithLazyBlock = {\n    id: idFn(JSON.stringify(options.meta) + blockJSON),\n    block: blockJSON,\n    moduleName: moduleName ?? '(unknown template module)',\n    // lying to the type checker here because we're going to\n    // replace it just below, after stringification\n    scope: SCOPE_PLACEHOLDER as unknown as null,\n    isStrictMode: options.strictMode ?? false,\n  };\n\n  if (usedLocals.length === 0) {\n    delete templateJSONObject.scope;\n  }\n\n  // JSON is javascript\n  let stringified = JSON.stringify(templateJSONObject);\n\n  if (usedLocals.length > 0) {\n    const scopeFn = `()=>[${usedLocals.join(',')}]`;\n\n    stringified = stringified.replace(`\"${SCOPE_PLACEHOLDER}\"`, scopeFn);\n  }\n\n  return stringified;\n}\n\nexport type { PrecompileOptions };\n","import type { ASTv2, src } from '@glimmer/syntax';\nimport { DebugLogger, frag, fragment, valueFragment } from '@glimmer/debug';\nimport { LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type { Result } from '../../shared/result';\n\nimport * as mir from '../2-encoding/mir';\nimport { NormalizationState } from './context';\nimport { VISIT_STMTS } from './visitors/statements';\nimport StrictModeValidationPass from './visitors/strict-mode';\n\n/**\n * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special\n * instructions for keywords like `{{yield}}`, `(has-block)` and\n * `{{#in-element}}`.\n *\n * Most importantly, it also classifies HTML element syntax into:\n *\n * 1. simple HTML element (with optional splattributes)\n * 2. component invocation\n *\n * Because the @glimmer/syntax AST gives us a string for an element's tag,\n * this pass also normalizes that string into an expression.\n *\n * ```\n * // normalized into a path expression whose head is `this` and tail is\n * // `[\"x\"]`\n * <this.x />\n *\n * {{#let expr as |t|}}\n *   // `\"t\"` is normalized into a variable lookup.\n *   <t />\n *\n *   // normalized into a path expression whose head is the variable lookup\n *   // `t` and tail is `[\"input\"]`.\n *   <t.input />\n * {{/let}}\n *\n * // normalized into a free variable lookup for `SomeComponent` (with the\n * // context `ComponentHead`).\n * <SomeComponent />\n *\n * // normalized into a path expression whose head is the free variable\n * // `notInScope` (with the context `Expression`), and whose tail is\n * // `[\"SomeComponent\"]`. In resolver mode, this path will be rejected later,\n * // since it cannot serve as an input to the resolver.\n * <notInScope.SomeComponent />\n * ```\n */\nexport default function normalize(\n  source: src.Source,\n  root: ASTv2.Template,\n  isStrict: boolean\n): Result<mir.Template> {\n  // create a new context for the normalization pass\n  let state = new NormalizationState(root.table, isStrict);\n\n  if (LOCAL_TRACE_LOGGING) {\n    const logger = DebugLogger.configured();\n    const done = logger.group(`pass0: visiting`).collapsed();\n    logger.log(valueFragment(root.table));\n    // LOCAL_LOGGER.debug('symbols', root.table);\n    logger.log(valueFragment(source));\n    done();\n  }\n\n  let body = VISIT_STMTS.visitList(root.body, state);\n\n  if (LOCAL_TRACE_LOGGING) {\n    const logger = DebugLogger.configured();\n\n    if (body.isOk) {\n      const done = logger.group(frag`pass0: out`).collapsed();\n      const ops = body.value.toPresentArray();\n\n      if (ops) {\n        const full = frag` ${valueFragment(ops)}`.subtle();\n        logger.log(frag`${fragment.array(ops.map((op) => valueFragment(op)))}${full}`);\n      }\n      done();\n      LOCAL_LOGGER.debug('-> pass0: out', body.value);\n    } else {\n      LOCAL_LOGGER.debug('-> pass0: error', body.reason);\n    }\n  }\n\n  let template = body.mapOk(\n    (body) => new mir.Template({ loc: root.loc, scope: root.table, body: body.toArray() })\n  );\n\n  if (isStrict) {\n    template = template.andThen((template) => StrictModeValidationPass.validate(template));\n  }\n\n  return template;\n}\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type * as mir from './mir';\n\nimport WireFormatDebugger from '../../wire-format-debug';\nimport { CONTENT } from './content';\n\nexport function visit(template: mir.Template): WireFormat.SerializedTemplateBlock {\n  let statements = CONTENT.list(template.body);\n  let scope = template.scope;\n  let block: WireFormat.SerializedTemplateBlock = [statements, scope.symbols, scope.upvars];\n\n  if (LOCAL_TRACE_LOGGING) {\n    let debug = new WireFormatDebugger(block);\n    LOCAL_LOGGER.debug(\n      `-> `,\n      statements.map((s) => debug.formatOpcode(s))\n    );\n  }\n\n  return block;\n}\n"],"names":["BLOCK_HEAD","CALL_HEAD","ELEMENT_HEAD","APPEND_PATH_HEAD","APPEND_EXPR_HEAD","LITERAL_HEAD","MODIFIER_HEAD","DYNAMIC_COMPONENT_HEAD","COMMENT_HEAD","SPLAT_HEAD","KEYWORD_HEAD","LOCAL_VAR","FREE_VAR","BLOCK_VAR","THIS_VAR","LITERAL_EXPR","CALL_EXPR","GET_PATH_EXPR","GET_VAR_EXPR","CONCAT_EXPR","HAS_BLOCK_EXPR","HAS_BLOCK_PARAMS_EXPR","CURRIED_COMPONENT","CURRIED_HELPER","CURRIED_MODIFIER","NS_XMLNS","isPresentArray","list","length","mapPresentArray","mapper","out","item","push","normalizeStatement","statement","Array","isArray","name","statementIsExpression","normalizeAppendExpression","isSugaryArrayStatement","params","hash","normalizeParams","normalizeHash","kind","head","normalizeCallHead","trusted","path","blocks","blockParams","normalizeBuilderBlockStatement","slice","attrs","dict","block","normalizeAttrs","normalizeBlock","extractElement","Error","JSON","stringify","normalizeSugaryArrayStatement","value","expr","normalizeExpression","normalizeVerboseStatement","normalizeAppendHead","normalizeDottedPath","assertNever","type","extractBlockHead","result","exec","normalizePath","tail","pathHead","normalizePathHead","variable","whole","rest","split","mode","test","normalizeBlocks","normalizeBlockHash","callback","Object","keys","forEach","key","entries","default","mapObject","map","s","a","normalizeAttr","attr","object","k","input","match","expression","forceTrusted","isBuilderCallExpression","normalizeCallExpression","ProgramSymbols","toSymbols","this","_symbols","toUpvars","_freeVariables","freeVar","addString","symbol","arg","local","hasLocal","_name","child","locals","LocalSymbols","top","constructor","parent","paramSymbols","values","array","index","indexOf","unimpl","message","buildStatements","statements","symbols","buildStatement","buildNormalizedStatements","normalized","Op","TrustingAppend","Append","buildGetPath","buildExpression","builtParams","buildParams","builtHash","buildHash","builtExpr","buildCallHead","VariableResolutionContext","ResolveAsHelperHead","ResolveAsComponentOrHelperHead","Call","Comment","buildBlock","buildBlocks","ResolveAsComponentHead","Block","buildKeyword","hasSplat","OpenElementWithSplat","OpenElement","AttrSplat","buildAttributeValue","extractNamespace","args","buildElementParams","FlushElement","CloseElement","buildElement","arr","interpolated","reduce","string","i","String","c","unicode","charCode","fromCharCode","parseInt","NEWLINE","childSymbols","inverse","Let","If","keyExpr","Each","some","namespace","val","StaticAttr","undefined","DynamicAttr","varContext","context","bare","buildVar","Concat","buildConcat","HasBlock","Strict","HasBlockParams","Undefined","callHead","sym","op","GetSymbol","GetStrictKeyword","GetFreeAsComponentOrHelperHead","GetFreeAsHelperHead","ResolveAsModifierHead","GetFreeAsModifierHead","GetFreeAsComponentHead","expressionContextOp","getSymbolForVar","exprs","e","Template","node","fields","InElement","Not","IfInline","WithDynamicVars","GetDynamicVar","Log","InvokeComponent","NamedBlocks","NamedBlock","AppendTrustedHTML","AppendTextNode","AppendComment","Component","SimpleElement","ElementParameters","Yield","Debugger","CallExpression","Modifier","InvokeBlock","SplatAttr","PathExpression","Missing","InterpolateExpression","Curry","Positional","NamedArguments","NamedArgument","Args","Tail","PresentList","toArray","filter","predicate","OptionalList","toPresentArray","into","ifPresent","EmptyList","_callback","_predicate","ifEmpty","ResultImpl","all","results","isErr","cast","Ok","Result","OkImpl","super","isOk","expect","_message","ifOk","andThen","mapOk","ifErr","mapErr","ErrImpl","reason","Err","ResultArray","items","add","err","toOptionalList","convertPathToCallIfKeyword","ref","KEYWORDS_TYPES","ASTv2","callee","empty","loc","VISIT_EXPRS","visit","state","Literal","Keyword","Interpolate","translated","CALL_KEYWORDS","translate","visitList","nodes","VariableReference","tailLoc","extend","mir","members","literal","keyword","parts","positional","named","pairs","KeywordImpl","delegate","Set","nodeType","KEYWORD_NODES","types","has","getCalleeExpression","generateSyntaxError","asString","assert","param","Keywords","_keywords","_type","kw","isKeyword","usedType","validTypes","includes","typesToReadableName","join","generateTypesMessage","keywords","toAppend","text","CurriedTypeToReadableType","assertCurryKeyword","curriedType","readableType","stringsAllowed","definition","nth","isStrict","PositionalArguments","translateCurryKeyword","definitionResult","argsResult","curryKeyword","getDynamicVarKeyword","call","positionals","isEmpty","varName","size","assertHasBlockKeyword","SourceSlice","synthetic","isLiteral","toSlice","translateHasBlockKeyword","scope","target","allocateBlock","chars","hasBlockKeyword","assertIfUnlessInlineKeyword","originalNode","inverted","condition","truthy","falsy","translateIfUnlessInlineKeyword","conditionResult","truthyResult","falsyResult","ifUnlessInlineKeyword","logKeyword","APPEND_KEYWORDS","src","SourceSpan","get","to","BLOCK_KEYWORDS","guid","insertBefore","destination","body","VISIT_STMTS","destinationResult","collapse","generateUniqueCursor","blockResult","inverseResult","every","valueResult","keyResult","positionalResult","namedResult","blocksResult","MODIFIER_KEYWORDS","XLINK","XML","XMLNS","WHITELIST","xmlns","DEFLATE_TAG_TABLE","div","WellKnownTagNames","span","p","INFLATE_TAG_TABLE","inflateTagName","tagName","DEFLATE_ATTR_TABLE","class","WellKnownAttrNames","id","style","href","INFLATE_ATTR_TABLE","deflateAttrName","attrName","inflateAttrName","ClassifiedElement","element","toStatement","prepare","prepared","rawValue","component","dynamicFeatures","isTrusting","trusting","modifier","typeAttr","simple","componentArgs","maybeLoc","NON_EXISTENT","modifiers","m","elementParams","ClassifiedComponent","tag","ClassifiedSimpleElement","isComponent","classified","AppendContent","TextNode","HtmlComment","b","visitBlock","hasDynamicFeatures","append","html","LiteralExpression","comment","NormalizationState","_cursorCount","_currentScope","oldBlock","COMPONENT_RESOLUTION","HELPER_RESOLUTION","MODIFIER_RESOLUTION","StrictModeValidationPass","validate","template","Statements","Statement","Expressions","expressions","Expression","resolution","errorFor","ElementParameter","inElement","WireFormatDebugger","_statements","upvars","format","program","formatOpcode","opcode","formatParams","formatHash","formatBlocks","StaticComponentAttr","ComponentAttr","DynamicArg","StaticArg","TrustingDynamicAttr","TrustingComponentAttr","formatElementParams","formatCurryType","GetLexicalSymbol","formatBlock","opcodes","o","accum","parameters","EXPR","SexpOpcodes","Local","isTemplateLocal","getOp","member","l","names","pair","WireStatements","CONTENT","content","stmt","visitContent","getDebugInfo","wireBlock","wireDestination","wireInsertBefore","wireTag","wirePositional","wireNamed","wireNamedBlocks","dynamicAttr","staticAttrOp","staticAttr","serializedBlocks","serializedBlock","nameChars","slots","defaultId","req","module","require","globalThis","crypto","idFn","createHash","update","digest","substring","defaultOptions","precompileJSON","options","source","Source","meta","moduleName","ast","normalize","lexicalScope","root","table","pass0","strictMode","pass2In","pass2","SCOPE_PLACEHOLDER","precompile","usedLocals","emit","debugSymbols","blockJSON","templateJSONObject","isStrictMode","stringified","scopeFn","replace"],"mappings":"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"}