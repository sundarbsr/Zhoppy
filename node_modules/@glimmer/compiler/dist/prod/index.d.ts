import { PresentArray, Nullable, Dict, WireFormat, TemplateJavascript, SerializedTemplateBlock } from '@glimmer/interfaces';
import { TemplateIdFn, PrecompileOptions, PrecompileOptionsWithLexicalScope } from '@glimmer/syntax';
export { PrecompileOptions } from '@glimmer/syntax';

type BUILDER_LITERAL = 0;
declare const BUILDER_LITERAL: BUILDER_LITERAL;
type BUILDER_COMMENT = 1;
declare const BUILDER_COMMENT: BUILDER_COMMENT;
type BUILDER_APPEND = 2;
declare const BUILDER_APPEND: BUILDER_APPEND;
type BUILDER_MODIFIER = 3;
declare const BUILDER_MODIFIER: BUILDER_MODIFIER;
type BUILDER_DYNAMIC_COMPONENT = 4;
declare const BUILDER_DYNAMIC_COMPONENT: BUILDER_DYNAMIC_COMPONENT;
type BUILDER_GET = 5;
declare const BUILDER_GET: BUILDER_GET;
type BUILDER_CONCAT = 6;
declare const BUILDER_CONCAT: BUILDER_CONCAT;
type BUILDER_HAS_BLOCK = 7;
declare const BUILDER_HAS_BLOCK: BUILDER_HAS_BLOCK;
type BUILDER_HAS_BLOCK_PARAMS = 8;
declare const BUILDER_HAS_BLOCK_PARAMS: BUILDER_HAS_BLOCK_PARAMS;
type BLOCK_HEAD = 'Block';
declare const BLOCK_HEAD: BLOCK_HEAD;
type CALL_HEAD = 'Call';
declare const CALL_HEAD: CALL_HEAD;
type ELEMENT_HEAD = 'Element';
declare const ELEMENT_HEAD: ELEMENT_HEAD;
type APPEND_PATH_HEAD = 'AppendPath';
declare const APPEND_PATH_HEAD: APPEND_PATH_HEAD;
type APPEND_EXPR_HEAD = 'AppendExpr';
declare const APPEND_EXPR_HEAD: APPEND_EXPR_HEAD;
type LITERAL_HEAD = 'Literal';
declare const LITERAL_HEAD: LITERAL_HEAD;
type MODIFIER_HEAD = 'Modifier';
declare const MODIFIER_HEAD: MODIFIER_HEAD;
type DYNAMIC_COMPONENT_HEAD = 'DynamicComponent';
declare const DYNAMIC_COMPONENT_HEAD: DYNAMIC_COMPONENT_HEAD;
type COMMENT_HEAD = 'Comment';
declare const COMMENT_HEAD: COMMENT_HEAD;
type SPLAT_HEAD = 'Splat';
declare const SPLAT_HEAD: SPLAT_HEAD;
type KEYWORD_HEAD = 'Keyword';
declare const KEYWORD_HEAD: KEYWORD_HEAD;
type LOCAL_VAR = 'Local';
declare const LOCAL_VAR: LOCAL_VAR;
type FREE_VAR = 'Free';
declare const FREE_VAR: FREE_VAR;
type ARG_VAR = 'Arg';
declare const ARG_VAR: ARG_VAR;
type BLOCK_VAR = 'Block';
declare const BLOCK_VAR: BLOCK_VAR;
type THIS_VAR = 'This';
declare const THIS_VAR: THIS_VAR;
type VariableKind = LOCAL_VAR | FREE_VAR | ARG_VAR | BLOCK_VAR | THIS_VAR;
type LITERAL_EXPR = 'Literal';
declare const LITERAL_EXPR: LITERAL_EXPR;
type CALL_EXPR = 'Call';
declare const CALL_EXPR: CALL_EXPR;
type GET_PATH_EXPR = 'GetPath';
declare const GET_PATH_EXPR: GET_PATH_EXPR;
type GET_VAR_EXPR = 'GetVar';
declare const GET_VAR_EXPR: GET_VAR_EXPR;
type CONCAT_EXPR = 'Concat';
declare const CONCAT_EXPR: CONCAT_EXPR;
type HAS_BLOCK_EXPR = 'HasBlock';
declare const HAS_BLOCK_EXPR: HAS_BLOCK_EXPR;
type HAS_BLOCK_PARAMS_EXPR = 'HasBlockParams';
declare const HAS_BLOCK_PARAMS_EXPR: HAS_BLOCK_PARAMS_EXPR;

type BuilderParams = BuilderExpression[];
type BuilderHash = Nullable<Dict<BuilderExpression>>;
type BuilderBlockHash = BuilderHash | {
    as: string | string[];
};
type BuilderBlocks = Dict<BuilderBlock>;
type BuilderAttrs = Dict<BuilderAttr>;
type NormalizedParams = NormalizedExpression[];
type NormalizedHash = Dict<NormalizedExpression>;
type NormalizedBlock = NormalizedStatement[];
type NormalizedBlocks = Dict<NormalizedBlock>;
type NormalizedAttrs = Dict<NormalizedAttr>;
type NormalizedAttr = SPLAT_HEAD | NormalizedExpression;
interface Variable {
    kind: VariableKind;
    name: string;
    /**
     * Differences:
     *
     * - strict mode variables always refer to in-scope variables
     * - loose mode variables use this algorithm:
     *   1. otherwise, fall back to `this.<name>`
     */
    mode: 'loose' | 'strict';
}
interface Path {
    head: Variable;
    tail: PresentArray<string>;
}
interface AppendExpr {
    kind: APPEND_EXPR_HEAD;
    expr: NormalizedExpression;
    trusted: boolean;
}
interface AppendPath {
    kind: APPEND_PATH_HEAD;
    path: NormalizedPath;
    trusted: boolean;
}
interface NormalizedKeywordStatement {
    kind: KEYWORD_HEAD;
    name: string;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
    blockParams: Nullable<string[]>;
    blocks: NormalizedBlocks;
}
type NormalizedStatement = {
    kind: CALL_HEAD;
    head: NormalizedHead;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
    trusted: boolean;
} | {
    kind: BLOCK_HEAD;
    head: NormalizedHead;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
    blockParams: Nullable<string[]>;
    blocks: NormalizedBlocks;
} | NormalizedKeywordStatement | {
    kind: ELEMENT_HEAD;
    name: string;
    attrs: NormalizedAttrs;
    block: NormalizedBlock;
} | {
    kind: COMMENT_HEAD;
    value: string;
} | {
    kind: LITERAL_HEAD;
    value: string;
} | AppendPath | AppendExpr | {
    kind: MODIFIER_HEAD;
    params: NormalizedParams;
    hash: Nullable<NormalizedHash>;
} | {
    kind: DYNAMIC_COMPONENT_HEAD;
    expr: NormalizedExpression;
    hash: Nullable<NormalizedHash>;
    block: NormalizedBlock;
};
type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;
type BuilderBlockStatement = [string, BuilderBlock | BuilderBlocks] | [string, BuilderParams | BuilderBlockHash, BuilderBlock | BuilderBlocks] | [string, BuilderParams, BuilderBlockHash, BuilderBlock | BuilderBlocks];
type BuilderElement = [string] | [string, BuilderAttrs, BuilderBlock] | [string, BuilderBlock] | [string, BuilderAttrs];
type BuilderComment = [BUILDER_COMMENT, string];
type VerboseStatement = [BUILDER_LITERAL, string] | [BUILDER_COMMENT, string] | [BUILDER_APPEND, BuilderExpression, true] | [BUILDER_APPEND, BuilderExpression] | [BUILDER_MODIFIER, Params, Hash] | [BUILDER_DYNAMIC_COMPONENT, BuilderExpression, Hash, BuilderBlock];
type BuilderStatement = VerboseStatement | SugaryArrayStatement | TupleBuilderExpression | string;
/**
 * The special value 'splat' is used to indicate that the attribute is a splat
 */
type BuilderAttr = BuilderExpression;
type TupleBuilderExpression = [BUILDER_LITERAL, string | boolean | null | undefined] | [BUILDER_GET, string] | [BUILDER_GET, string, string[]] | [BUILDER_CONCAT, ...BuilderExpression[]] | [BUILDER_HAS_BLOCK, string] | [BUILDER_HAS_BLOCK_PARAMS, string] | BuilderCallExpression;
type Params = BuilderParams;
type Hash = Dict<BuilderExpression>;
interface NormalizedCallExpression {
    type: CALL_EXPR;
    head: NormalizedHead;
    params: Nullable<NormalizedParams>;
    hash: Nullable<NormalizedHash>;
}
interface NormalizedPath {
    type: GET_PATH_EXPR;
    path: Path;
}
interface NormalizedVar {
    type: GET_VAR_EXPR;
    variable: Variable;
}
type NormalizedHead = NormalizedPath | NormalizedVar;
interface NormalizedConcat {
    type: CONCAT_EXPR;
    params: [NormalizedExpression, ...NormalizedExpression[]];
}
type NormalizedExpression = {
    type: LITERAL_EXPR;
    value: null | undefined | boolean | string | number;
} | NormalizedCallExpression | NormalizedPath | NormalizedVar | NormalizedConcat | {
    type: HAS_BLOCK_EXPR;
    name: string;
} | {
    type: HAS_BLOCK_PARAMS_EXPR;
    name: string;
};
type BuilderExpression = TupleBuilderExpression | BuilderCallExpression | null | undefined | boolean | string | number;
type MiniBuilderBlock = BuilderStatement[];
type BuilderBlock = MiniBuilderBlock;
type BuilderCallExpression = [string] | [string, Params | Hash] | [string, Params, Hash];

interface Symbols {
    top: ProgramSymbols;
    freeVar(name: string): number;
    arg(name: string): number;
    block(name: string): number;
    local(name: string): number;
    this(): number;
    hasLocal(name: string): boolean;
    child(params: string[]): LocalSymbols;
}
declare class ProgramSymbols implements Symbols {
    _freeVariables: string[];
    _symbols: string[];
    top: this;
    toSymbols(): string[];
    toUpvars(): string[];
    freeVar(name: string): number;
    block(name: string): number;
    arg(name: string): number;
    local(name: string): never;
    this(): number;
    hasLocal(_name: string): false;
    symbol(name: string): number;
    child(locals: string[]): LocalSymbols;
}
declare class LocalSymbols implements Symbols {
    private parent;
    private locals;
    constructor(parent: Symbols, locals: string[]);
    get paramSymbols(): number[];
    get top(): ProgramSymbols;
    freeVar(name: string): number;
    arg(name: string): number;
    block(name: string): number;
    local(name: string): number;
    this(): number;
    hasLocal(name: string): boolean;
    child(locals: string[]): LocalSymbols;
}
declare function buildStatements(statements: BuilderStatement[], symbols: Symbols): WireFormat.Statement[];
declare function buildStatement(normalized: NormalizedStatement, symbols?: Symbols): WireFormat.Statement[];
declare function s(arr: TemplateStringsArray, ...interpolated: unknown[]): [BUILDER_LITERAL, string];
declare function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment;
declare function unicode(charCode: string): string;
declare const NEWLINE = "\n";

declare const defaultId: TemplateIdFn;
declare function precompileJSON(string: Nullable<string>, options?: PrecompileOptions | PrecompileOptionsWithLexicalScope): [block: SerializedTemplateBlock, usedLocals: string[]];
declare function precompile(source: string, options?: PrecompileOptions | PrecompileOptionsWithLexicalScope): TemplateJavascript;

declare class WireFormatDebugger {
    private upvars;
    private symbols;
    constructor([_statements, symbols, upvars]: SerializedTemplateBlock);
    format(program: SerializedTemplateBlock): unknown;
    formatOpcode(opcode: WireFormat.Syntax): unknown;
    private formatCurryType;
    private formatElementParams;
    private formatParams;
    private formatHash;
    private formatBlocks;
    private formatBlock;
}

export { type BuilderStatement, NEWLINE, ProgramSymbols, WireFormatDebugger, buildStatement, buildStatements, c, defaultId, precompile, precompileJSON, s, unicode };
