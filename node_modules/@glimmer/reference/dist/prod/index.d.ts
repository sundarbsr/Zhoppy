import { Reference, Nullable, ReferenceSymbol } from '@glimmer/interfaces';
export { Reference } from '@glimmer/interfaces';

declare const REFERENCE: ReferenceSymbol;

interface ReferenceEnvironment {
    getProp(obj: unknown, path: string): unknown;
    setProp(obj: unknown, path: string, value: unknown): unknown;
}
declare function createPrimitiveRef<T extends string | symbol | number | boolean | null | undefined>(value: T): Reference<T>;
declare const UNDEFINED_REFERENCE: Reference<undefined>;
declare const NULL_REFERENCE: Reference<null>;
declare const TRUE_REFERENCE: Reference<true>;
declare const FALSE_REFERENCE: Reference<false>;
declare function createConstRef<T>(value: T, debugLabel: false | string): Reference<T>;
declare function createUnboundRef<T>(value: T, debugLabel: false | string): Reference<T>;
declare function createComputeRef<T = unknown>(compute: () => T, update?: Nullable<(value: T) => void>, debugLabel?: false | string): Reference<T>;
declare function createReadOnlyRef(ref: Reference): Reference;
declare function isInvokableRef(ref: Reference): boolean;
declare function createInvokableRef(inner: Reference): Reference;
declare function isConstRef(_ref: Reference): boolean;
declare function isUpdatableRef(_ref: Reference): boolean;
declare function valueForRef<T>(_ref: Reference<T>): T;
declare function updateRef(_ref: Reference, value: unknown): void;
declare function childRefFor(_parentRef: Reference, path: string): Reference;
declare function childRefFromParts(root: Reference, parts: string[]): Reference;
declare let createDebugAliasRef: undefined | ((debugLabel: string, inner: Reference) => Reference);

interface IterationItem<T, U> {
    key: unknown;
    value: T;
    memo: U;
}
interface AbstractIterator<T, U, V extends IterationItem<T, U>> {
    isEmpty(): boolean;
    next(): Nullable<V>;
}
type OpaqueIterationItem = IterationItem<unknown, unknown>;
type OpaqueIterator = AbstractIterator<unknown, unknown, OpaqueIterationItem>;
interface IteratorDelegate {
    isEmpty(): boolean;
    next(): {
        value: unknown;
        memo: unknown;
    } | null;
}
type KeyFor = (item: unknown, index: unknown) => unknown;
declare function createIteratorRef(listRef: Reference, key: string): Reference<ArrayIterator | IteratorWrapper>;
declare function createIteratorItemRef(_value: unknown): Reference<unknown>;
declare class IteratorWrapper implements OpaqueIterator {
    private inner;
    private keyFor;
    constructor(inner: IteratorDelegate, keyFor: KeyFor);
    isEmpty(): boolean;
    next(): OpaqueIterationItem | null;
}
declare class ArrayIterator implements OpaqueIterator {
    private iterator;
    private keyFor;
    private current;
    private pos;
    constructor(iterator: unknown[] | readonly unknown[], keyFor: KeyFor);
    isEmpty(): boolean;
    next(): Nullable<IterationItem<unknown, number>>;
}

export { type AbstractIterator, FALSE_REFERENCE, type IterationItem, type IteratorDelegate, NULL_REFERENCE, type OpaqueIterationItem, type OpaqueIterator, REFERENCE, type ReferenceEnvironment, TRUE_REFERENCE, UNDEFINED_REFERENCE, childRefFor, childRefFromParts, createComputeRef, createConstRef, createDebugAliasRef, createInvokableRef, createIteratorItemRef, createIteratorRef, createPrimitiveRef, createReadOnlyRef, createUnboundRef, isConstRef, isInvokableRef, isUpdatableRef, updateRef, valueForRef };
