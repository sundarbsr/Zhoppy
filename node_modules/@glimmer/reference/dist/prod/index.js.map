{"version":3,"file":"index.js","sources":["../../lib/reference.ts","../../lib/iterable.ts"],"sourcesContent":["import type {\n  ComputeReference,\n  ConstantReference,\n  InvokableReference,\n  Nullable,\n  Reference,\n  ReferenceSymbol,\n  ReferenceType,\n  UnboundReference,\n} from '@glimmer/interfaces';\nimport type { Revision, Tag } from '@glimmer/validator';\nimport { expect } from '@glimmer/debug-util';\nimport { getProp, setProp } from '@glimmer/global-context';\nimport { isDict } from '@glimmer/util';\nimport {\n  CONSTANT_TAG,\n  consumeTag,\n  INITIAL,\n  track,\n  validateTag,\n  valueForTag,\n} from '@glimmer/validator';\n\nexport const REFERENCE: ReferenceSymbol = Symbol('REFERENCE') as ReferenceSymbol;\n\nconst CONSTANT: ConstantReference = 0;\nconst COMPUTE: ComputeReference = 1;\nconst UNBOUND: UnboundReference = 2;\nconst INVOKABLE: InvokableReference = 3;\n\nexport type { Reference as default };\nexport type { Reference };\n\n//////////\n\nexport interface ReferenceEnvironment {\n  getProp(obj: unknown, path: string): unknown;\n  setProp(obj: unknown, path: string, value: unknown): unknown;\n}\n\nclass ReferenceImpl<T = unknown> implements Reference<T> {\n  [REFERENCE]: ReferenceType;\n  public tag: Nullable<Tag> = null;\n  public lastRevision: Revision = INITIAL;\n  public lastValue?: T;\n\n  public children: Nullable<Map<string | Reference, Reference>> = null;\n\n  public compute: Nullable<() => T> = null;\n  public update: Nullable<(val: T) => void> = null;\n\n  public debugLabel?: string;\n\n  constructor(type: ReferenceType) {\n    this[REFERENCE] = type;\n  }\n}\n\nexport function createPrimitiveRef<T extends string | symbol | number | boolean | null | undefined>(\n  value: T\n): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.tag = CONSTANT_TAG;\n  ref.lastValue = value;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = String(value);\n  }\n\n  return ref;\n}\n\nexport const UNDEFINED_REFERENCE = createPrimitiveRef(undefined);\nexport const NULL_REFERENCE = createPrimitiveRef(null);\nexport const TRUE_REFERENCE = createPrimitiveRef(true as const);\nexport const FALSE_REFERENCE = createPrimitiveRef(false as const);\n\nexport function createConstRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(CONSTANT);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createUnboundRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createComputeRef<T = unknown>(\n  compute: () => T,\n  update: Nullable<(value: T) => void> = null,\n  debugLabel: false | string = 'unknown'\n): Reference<T> {\n  const ref = new ReferenceImpl<T>(COMPUTE);\n\n  ref.compute = compute;\n  ref.update = update;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = `(result of a \\`${debugLabel}\\` helper)`;\n  }\n\n  return ref;\n}\n\nexport function createReadOnlyRef(ref: Reference): Reference {\n  if (!isUpdatableRef(ref)) return ref;\n\n  return createComputeRef(() => valueForRef(ref), null, ref.debugLabel);\n}\n\nexport function isInvokableRef(ref: Reference) {\n  return ref[REFERENCE] === INVOKABLE;\n}\n\nexport function createInvokableRef(inner: Reference): Reference {\n  const ref = createComputeRef(\n    () => valueForRef(inner),\n    (value) => updateRef(inner, value)\n  );\n  ref.debugLabel = inner.debugLabel;\n  ref[REFERENCE] = INVOKABLE;\n\n  return ref;\n}\n\nexport function isConstRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.tag === CONSTANT_TAG;\n}\n\nexport function isUpdatableRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.update !== null;\n}\n\nexport function valueForRef<T>(_ref: Reference<T>): T {\n  const ref = _ref as ReferenceImpl<T>;\n\n  let { tag } = ref;\n\n  if (tag === CONSTANT_TAG) {\n    return ref.lastValue as T;\n  }\n\n  const { lastRevision } = ref;\n  let lastValue;\n\n  if (tag === null || !validateTag(tag, lastRevision)) {\n    const { compute } = ref;\n\n    const newTag = track(\n      () => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        lastValue = ref.lastValue = compute!();\n      },\n      import.meta.env.DEV && ref.debugLabel\n    );\n\n    tag = ref.tag = newTag;\n\n    ref.lastRevision = valueForTag(newTag);\n  } else {\n    lastValue = ref.lastValue;\n  }\n\n  consumeTag(tag);\n\n  return lastValue as T;\n}\n\nexport function updateRef(_ref: Reference, value: unknown) {\n  const ref = _ref as ReferenceImpl;\n\n  const update = expect(ref.update, 'called update on a non-updatable reference');\n\n  update(value);\n}\n\nexport function childRefFor(_parentRef: Reference, path: string): Reference {\n  const parentRef = _parentRef as ReferenceImpl;\n\n  const type = parentRef[REFERENCE];\n\n  let children = parentRef.children;\n  let child: Reference;\n\n  if (children === null) {\n    children = parentRef.children = new Map();\n  } else {\n    const next = children.get(path);\n\n    if (next) return next;\n  }\n\n  if (type === UNBOUND) {\n    const parent = valueForRef(parentRef);\n\n    if (isDict(parent)) {\n      child = createUnboundRef(\n        (parent as Record<string, unknown>)[path],\n        import.meta.env.DEV && `${parentRef.debugLabel}.${path}`\n      );\n    } else {\n      child = UNDEFINED_REFERENCE;\n    }\n  } else {\n    child = createComputeRef(\n      () => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return getProp(parent, path);\n        }\n      },\n      (val) => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return setProp(parent, path, val);\n        }\n      }\n    );\n\n    if (import.meta.env.DEV) {\n      child.debugLabel = `${parentRef.debugLabel}.${path}`;\n    }\n  }\n\n  children.set(path, child);\n\n  return child;\n}\n\nexport function childRefFromParts(root: Reference, parts: string[]): Reference {\n  let reference = root;\n\n  for (const part of parts) {\n    reference = childRefFor(reference, part);\n  }\n\n  return reference;\n}\n\nexport let createDebugAliasRef: undefined | ((debugLabel: string, inner: Reference) => Reference);\n\nif (import.meta.env.DEV) {\n  createDebugAliasRef = (debugLabel: string, inner: Reference) => {\n    const update = isUpdatableRef(inner) ? (value: unknown): void => updateRef(inner, value) : null;\n    const ref = createComputeRef(() => valueForRef(inner), update);\n\n    ref[REFERENCE] = inner[REFERENCE];\n\n    ref.debugLabel = debugLabel;\n\n    return ref;\n  };\n}\n","import type { Dict, Nullable } from '@glimmer/interfaces';\nimport { getPath, toIterator } from '@glimmer/global-context';\nimport { EMPTY_ARRAY, isIndexable } from '@glimmer/util';\nimport { consumeTag, createTag, dirtyTag } from '@glimmer/validator';\n\nimport type { Reference, ReferenceEnvironment } from './reference';\n\nimport { createComputeRef, valueForRef } from './reference';\n\nexport interface IterationItem<T, U> {\n  key: unknown;\n  value: T;\n  memo: U;\n}\n\nexport interface AbstractIterator<T, U, V extends IterationItem<T, U>> {\n  isEmpty(): boolean;\n  next(): Nullable<V>;\n}\n\nexport type OpaqueIterationItem = IterationItem<unknown, unknown>;\nexport type OpaqueIterator = AbstractIterator<unknown, unknown, OpaqueIterationItem>;\n\nexport interface IteratorDelegate {\n  isEmpty(): boolean;\n  next(): { value: unknown; memo: unknown } | null;\n}\n\nexport interface IteratorReferenceEnvironment extends ReferenceEnvironment {\n  getPath(obj: unknown, path: string): unknown;\n  toIterator(obj: unknown): Nullable<IteratorDelegate>;\n}\n\ntype KeyFor = (item: unknown, index: unknown) => unknown;\n\nconst NULL_IDENTITY = {};\n\nconst KEY: KeyFor = (_, index) => index;\nconst INDEX: KeyFor = (_, index) => String(index);\nconst IDENTITY: KeyFor = (item) => {\n  if (item === null) {\n    // Returning null as an identity will cause failures since the iterator\n    // can't tell that it's actually supposed to be null\n    return NULL_IDENTITY;\n  }\n\n  return item;\n};\n\nfunction keyForPath(path: string): KeyFor {\n  if (import.meta.env.DEV && path[0] === '@') {\n    throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);\n  }\n  return uniqueKeyFor((item) => getPath(item as object, path));\n}\n\nfunction makeKeyFor(key: string) {\n  switch (key) {\n    case '@key':\n      return uniqueKeyFor(KEY);\n    case '@index':\n      return uniqueKeyFor(INDEX);\n    case '@identity':\n      return uniqueKeyFor(IDENTITY);\n    default:\n      return keyForPath(key);\n  }\n}\n\nclass WeakMapWithPrimitives<T> {\n  private _weakMap?: WeakMap<object, T>;\n  private _primitiveMap?: Map<unknown, T>;\n\n  private get weakMap() {\n    if (this._weakMap === undefined) {\n      this._weakMap = new WeakMap();\n    }\n\n    return this._weakMap;\n  }\n\n  private get primitiveMap() {\n    if (this._primitiveMap === undefined) {\n      this._primitiveMap = new Map();\n    }\n\n    return this._primitiveMap;\n  }\n\n  set(key: unknown, value: T) {\n    if (isIndexable(key)) {\n      this.weakMap.set(key, value);\n    } else {\n      this.primitiveMap.set(key, value);\n    }\n  }\n\n  get(key: unknown): T | undefined {\n    if (isIndexable(key)) {\n      return this.weakMap.get(key);\n    } else {\n      return this.primitiveMap.get(key);\n    }\n  }\n}\n\nconst IDENTITIES = new WeakMapWithPrimitives<object[]>();\n\nfunction identityForNthOccurence(value: unknown, count: number) {\n  let identities = IDENTITIES.get(value);\n\n  if (identities === undefined) {\n    identities = [];\n    IDENTITIES.set(value, identities);\n  }\n\n  let identity = identities[count];\n\n  if (identity === undefined) {\n    identity = { value, count };\n    identities[count] = identity;\n  }\n\n  return identity;\n}\n\n/**\n * When iterating over a list, it's possible that an item with the same unique\n * key could be encountered twice:\n *\n * ```js\n * let arr = ['same', 'different', 'same', 'same'];\n * ```\n *\n * In general, we want to treat these items as _unique within the list_. To do\n * this, we track the occurences of every item as we iterate the list, and when\n * an item occurs more than once, we generate a new unique key just for that\n * item, and that occurence within the list. The next time we iterate the list,\n * and encounter an item for the nth time, we can get the _same_ key, and let\n * Glimmer know that it should reuse the DOM for the previous nth occurence.\n */\nfunction uniqueKeyFor(keyFor: KeyFor) {\n  let seen = new WeakMapWithPrimitives<number>();\n\n  return (value: unknown, memo: unknown) => {\n    let key = keyFor(value, memo);\n    let count = seen.get(key) || 0;\n\n    seen.set(key, count + 1);\n\n    if (count === 0) {\n      return key;\n    }\n\n    return identityForNthOccurence(key, count);\n  };\n}\n\nexport function createIteratorRef(listRef: Reference, key: string) {\n  return createComputeRef(() => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let iterable = valueForRef(listRef) as { [Symbol.iterator]: any } | null | false;\n\n    let keyFor = makeKeyFor(key);\n\n    if (Array.isArray(iterable)) {\n      return new ArrayIterator(iterable, keyFor);\n    }\n\n    let maybeIterator = toIterator(iterable);\n\n    if (maybeIterator === null) {\n      return new ArrayIterator(EMPTY_ARRAY, () => null);\n    }\n\n    return new IteratorWrapper(maybeIterator, keyFor);\n  });\n}\n\nexport function createIteratorItemRef(_value: unknown) {\n  let value = _value;\n  let tag = createTag();\n\n  return createComputeRef(\n    () => {\n      consumeTag(tag);\n      return value;\n    },\n    (newValue) => {\n      if (value !== newValue) {\n        value = newValue;\n        dirtyTag(tag);\n      }\n    }\n  );\n}\n\nclass IteratorWrapper implements OpaqueIterator {\n  constructor(\n    private inner: IteratorDelegate,\n    private keyFor: KeyFor\n  ) {}\n\n  isEmpty() {\n    return this.inner.isEmpty();\n  }\n\n  next() {\n    let nextValue = this.inner.next() as OpaqueIterationItem | null;\n\n    if (nextValue !== null) {\n      nextValue.key = this.keyFor(nextValue.value, nextValue.memo);\n    }\n\n    return nextValue;\n  }\n}\n\nclass ArrayIterator implements OpaqueIterator {\n  private current: { kind: 'empty' } | { kind: 'first'; value: unknown } | { kind: 'progress' };\n  private pos = 0;\n\n  constructor(\n    private iterator: unknown[] | readonly unknown[],\n    private keyFor: KeyFor\n  ) {\n    if (iterator.length === 0) {\n      this.current = { kind: 'empty' };\n    } else {\n      this.current = { kind: 'first', value: iterator[this.pos] };\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.current.kind === 'empty';\n  }\n\n  next(): Nullable<IterationItem<unknown, number>> {\n    let value: unknown;\n\n    let current = this.current;\n    if (current.kind === 'first') {\n      this.current = { kind: 'progress' };\n      value = current.value;\n    } else if (this.pos >= this.iterator.length - 1) {\n      return null;\n    } else {\n      value = this.iterator[++this.pos];\n    }\n\n    let { keyFor } = this;\n\n    let key = keyFor(value as Dict, this.pos);\n    let memo = this.pos;\n\n    return { key, value, memo };\n  }\n}\n"],"names":["REFERENCE","Symbol","ReferenceImpl","constructor","type","tag","lastRevision","INITIAL","children","compute","update","this","createPrimitiveRef","value","ref","CONSTANT_TAG","lastValue","UNDEFINED_REFERENCE","undefined","NULL_REFERENCE","TRUE_REFERENCE","FALSE_REFERENCE","createConstRef","createUnboundRef","createComputeRef","createReadOnlyRef","isUpdatableRef","valueForRef","debugLabel","isInvokableRef","createInvokableRef","inner","updateRef","isConstRef","_ref","validateTag","newTag","track","valueForTag","consumeTag","childRefFor","_parentRef","path","parentRef","child","Map","next","get","parent","isDict","getProp","val","setProp","set","childRefFromParts","root","parts","reference","part","createDebugAliasRef","NULL_IDENTITY","KEY","_","index","INDEX","String","IDENTITY","item","WeakMapWithPrimitives","weakMap","_weakMap","WeakMap","primitiveMap","_primitiveMap","key","isIndexable","IDENTITIES","uniqueKeyFor","keyFor","seen","memo","count","identities","identity","identityForNthOccurence","createIteratorRef","listRef","iterable","getPath","makeKeyFor","Array","isArray","ArrayIterator","maybeIterator","toIterator","EMPTY_ARRAY","IteratorWrapper","createIteratorItemRef","_value","createTag","newValue","dirtyTag","isEmpty","nextValue","iterator","pos","length","current","kind"],"mappings":"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"}