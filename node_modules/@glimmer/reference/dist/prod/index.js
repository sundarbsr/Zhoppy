import{setProp as t,getProp as e,toIterator as n,getPath as r}from"@glimmer/global-context";import{isDict as i,EMPTY_ARRAY as s,isIndexable as u}from"@glimmer/util";import{CONSTANT_TAG as l,INITIAL as o,validateTag as a,track as c,valueForTag as p,consumeTag as h,createTag as f,dirtyTag as m}from"@glimmer/validator";const g=Symbol("REFERENCE");class d{constructor(t){this.tag=null,this.lastRevision=o,this.children=null,this.compute=null,this.update=null,this[g]=t}}function v(t){const e=new d(2);return e.tag=l,e.lastValue=t,e}const k=v(void 0),w=v(null),y=v(!0),M=v(!1);function b(t){const e=new d(0);return e.lastValue=t,e.tag=l,e}function E(t){const e=new d(2);return e.lastValue=t,e.tag=l,e}function x(t,e=null){const n=new d(1);return n.compute=t,n.update=e,n}function V(t){return L(t)?x((()=>A(t)),null,t.debugLabel):t}function _(t){return 3===t[g]}function F(t){const e=x((()=>A(t)),(e=>S(t,e)));return e.debugLabel=t.debugLabel,e[g]=3,e}function R(t){return t.tag===l}function L(t){return null!==t.update}function A(t){const e=t;let{tag:n}=e;if(n===l)return e.lastValue;const{lastRevision:r}=e;let i;if(null!==n&&a(n,r))i=e.lastValue;else{const{compute:t}=e,r=c((()=>{i=e.lastValue=t()}),!1);n=e.tag=r,e.lastRevision=p(r)}return h(n),i}function S(t,e){(0,t.update)(e)}function C(n,r){const s=n,u=s[g];let l,o=s.children;if(null===o)o=s.children=new Map;else{const t=o.get(r);if(t)return t}if(2===u){const t=A(s);l=i(t)?E(t[r]):k}else l=x((()=>{const t=A(s);if(i(t))return e(t,r)}),(e=>{const n=A(s);if(i(n))return t(n,r,e)}));return o.set(r,l),l}function N(t,e){let n=t;for(const t of e)n=C(n,t);return n}let W;const j={},q=(t,e)=>e,z=(t,e)=>String(e),B=t=>null===t?j:t;class D{get weakMap(){return void 0===this._weakMap&&(this._weakMap=new WeakMap),this._weakMap}get primitiveMap(){return void 0===this._primitiveMap&&(this._primitiveMap=new Map),this._primitiveMap}set(t,e){u(t)?this.weakMap.set(t,e):this.primitiveMap.set(t,e)}get(t){return u(t)?this.weakMap.get(t):this.primitiveMap.get(t)}}const G=new D;function H(t){let e=new D;return(n,r)=>{let i=t(n,r),s=e.get(i)||0;return e.set(i,s+1),0===s?i:function(t,e){let n=G.get(t);void 0===n&&(n=[],G.set(t,n));let r=n[e];return void 0===r&&(r={value:t,count:e},n[e]=r),r}(i,s)}}function I(t,e){return x((()=>{let i=A(t),u=function(t){switch(t){case"@key":return H(q);case"@index":return H(z);case"@identity":return H(B);default:return e=t,H((t=>r(t,e)))}var e}(e);if(Array.isArray(i))return new O(i,u);let l=n(i);return null===l?new O(s,(()=>null)):new K(l,u)}))}function J(t){let e=t,n=f();return x((()=>(h(n),e)),(t=>{e!==t&&(e=t,m(n))}))}class K{constructor(t,e){this.inner=t,this.keyFor=e}isEmpty(){return this.inner.isEmpty()}next(){let t=this.inner.next();return null!==t&&(t.key=this.keyFor(t.value,t.memo)),t}}class O{constructor(t,e){this.iterator=t,this.keyFor=e,this.pos=0,0===t.length?this.current={kind:"empty"}:this.current={kind:"first",value:t[this.pos]}}isEmpty(){return"empty"===this.current.kind}next(){let t,e=this.current;if("first"===e.kind)this.current={kind:"progress"},t=e.value;else{if(this.pos>=this.iterator.length-1)return null;t=this.iterator[++this.pos]}let{keyFor:n}=this;return{key:n(t,this.pos),value:t,memo:this.pos}}}export{M as FALSE_REFERENCE,w as NULL_REFERENCE,g as REFERENCE,y as TRUE_REFERENCE,k as UNDEFINED_REFERENCE,C as childRefFor,N as childRefFromParts,x as createComputeRef,b as createConstRef,W as createDebugAliasRef,F as createInvokableRef,J as createIteratorItemRef,I as createIteratorRef,v as createPrimitiveRef,V as createReadOnlyRef,E as createUnboundRef,R as isConstRef,_ as isInvokableRef,L as isUpdatableRef,S as updateRef,A as valueForRef};
//# sourceMappingURL=index.js.map
