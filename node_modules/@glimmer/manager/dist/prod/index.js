import{debugAssert as e}from"@glimmer/global-context";import{associateDestroyableChild as t,registerDestructor as n}from"@glimmer/destroyable";import{valueForRef as o,createComputeRef as r,createConstRef as a,UNDEFINED_REFERENCE as i}from"@glimmer/reference";import{track as l,createUpdatableTag as u,untrack as s}from"@glimmer/validator";import{InternalComponentCapabilities as c}from"@glimmer/vm";const f=new WeakMap;function d(e){return f.get(e)}function p(e,t){f.set(e,t)}function g(e){if("symbol"==typeof e)return null;const t=Number(e);return isNaN(t)?null:t%1==0?t:null}class m{constructor(e){this.named=e}get(e,t){const n=this.named[t];if(void 0!==n)return o(n)}has(e,t){return t in this.named}ownKeys(){return Object.keys(this.named)}isExtensible(){return!1}getOwnPropertyDescriptor(e,t){return{enumerable:!0,configurable:!0}}}class h{constructor(e){this.positional=e}get(e,t){let{positional:n}=this;if("length"===t)return n.length;const r=g(t);return null!==r&&r<n.length?o(n[r]):e[t]}isExtensible(){return!1}has(e,t){const n=g(t);return null!==n&&n<this.positional.length}}const y=e=>{const{named:t,positional:n}=e,r=new m(t),a=new h(n),i=Object.create(null),u=new Proxy(i,r),s=new Proxy([],a);return p(u,((e,n)=>function(e,t){return l((()=>{t in e&&o(e[t])}))}(t,n))),p(s,((e,t)=>function(e,t){return l((()=>{"[]"===t&&e.forEach(o);const n=g(t);null!==n&&n<e.length&&o(e[n])}))}(n,t))),{named:u,positional:s}},b=c.Empty;function w(e){return b|D(e,"dynamicLayout")|D(e,"dynamicTag")|D(e,"prepareArgs")|D(e,"createArgs")|D(e,"attributeHook")|D(e,"elementHook")|D(e,"dynamicScope")|D(e,"createCaller")|D(e,"updateHook")|D(e,"createInstance")|D(e,"wrapped")|D(e,"willDestroy")|D(e,"hasSubOwner")}function D(e,t){return e[t]?c[t]:b}function k(e,t,n){return!!(t&n)}function v(e,t){return!!(e&t)}function M(t,n={}){return e("3.23"===t,(()=>`Invalid helper manager compatibility specified; you specified ${t}, but only '3.23' is supported.`)),{hasValue:Boolean(n.hasValue),hasDestroyable:Boolean(n.hasDestroyable),hasScheduledEffect:Boolean(n.hasScheduledEffect)}}function C(e){return e.capabilities.hasValue}function H(e){return e.capabilities.hasDestroyable}class A{constructor(e){this.factory=e,this.helperManagerDelegates=new WeakMap,this.undefinedDelegate=null}getDelegateForOwner(e){let t=this.helperManagerDelegates.get(e);if(void 0===t){let{factory:n}=this;t=n(e),this.helperManagerDelegates.set(e,t)}return t}getDelegateFor(e){if(void 0===e){let{undefinedDelegate:e}=this;if(null===e){let{factory:t}=this;this.undefinedDelegate=e=t(void 0)}return e}return this.getDelegateForOwner(e)}getHelper(e){return(n,o)=>{let l=this.getDelegateFor(o);const u=y(n),s=l.createHelper(e,u);if(C(l)){let e=r((()=>l.getValue(s)),null,!1);return H(l)&&t(e,l.getDestroyable(s)),e}if(H(l)){let e=a(void 0,!1);return t(e,l.getDestroyable(s)),e}return i}}}class O{createHelper(e,t){return{fn:e,args:t}}getValue({fn:e,args:t}){return Object.keys(t.named).length>0?e(...t.positional,t.named):e(...t.positional)}getDebugName(e){return e.name?`(helper function ${e.name})`:"(anonymous helper function)"}constructor(){this.capabilities={hasValue:!0,hasDestroyable:!1,hasScheduledEffect:!1}}}const j=new WeakMap,S=new WeakMap,T=new WeakMap,F=Object.getPrototypeOf;function W(e,t,n){return e.set(n,t),n}function x(e,t){let n=t;for(;null!==n;){const t=e.get(n);if(void 0!==t)return t;n=F(n)}}function B(e,t){return W(S,e,t)}function E(e){const t=x(S,e);return void 0===t?null:t}function L(e,t){return W(T,e,t)}const N=new A((()=>new O));function V(t){e("object"==typeof t&&null!==t||"function"==typeof t,(()=>`Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${t}`));let n=x(T,t);return void 0===n&&"function"==typeof t&&(n=N),n||null}function $(e,t){return W(j,e,t)}function I(t,n){e("object"==typeof t&&null!==t||"function"==typeof t,(()=>`Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${t}`));const o=x(j,t);return void 0===o?(e(n,(()=>`Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${(void 0)(t)}`)),null):o}function P(e){return void 0!==x(j,e)}function U(e){return function(e){return"function"==typeof e}(e)||void 0!==x(T,e)}function R(e){return void 0!==x(S,e)}const K={dynamicLayout:!1,dynamicTag:!1,prepareArgs:!1,createArgs:!0,attributeHook:!1,elementHook:!1,createCaller:!1,dynamicScope:!0,updateHook:!0,createInstance:!0,wrapped:!1,willDestroy:!1,hasSubOwner:!1};function q(e,t={}){let n=Boolean(t.updateHook);return{asyncLifeCycleCallbacks:Boolean(t.asyncLifecycleCallbacks),destructor:Boolean(t.destructor),updateHook:n}}function z(e){return e.capabilities.asyncLifeCycleCallbacks}function G(e){return e.capabilities.updateHook}class J{constructor(e){this.factory=e,this.componentManagerDelegates=new WeakMap}getDelegateFor(e){let{componentManagerDelegates:t}=this,n=t.get(e);if(void 0===n){let{factory:o}=this;n=o(e),t.set(e,n)}return n}create(e,t,n){let o=this.getDelegateFor(e),r=y(n.capture()),a=o.createComponent(t,r);return new Q(a,o,r)}getDebugName(e){return"function"==typeof e?e.name:e.toString()}update(e){let{delegate:t}=e;if(G(t)){let{component:n,args:o}=e;t.updateComponent(n,o)}}didCreate({component:e,delegate:t}){z(t)&&t.didCreateComponent(e)}didUpdate({component:e,delegate:t}){(function(e){return z(e)&&G(e)})(t)&&t.didUpdateComponent(e)}didRenderLayout(){}didUpdateLayout(){}getSelf({component:e,delegate:t}){return a(t.getContext(e),"this")}getDestroyable(e){const{delegate:t}=e;if(function(e){return e.capabilities.destructor}(t)){const{component:o}=e;return n(e,(()=>t.destroyComponent(o))),e}return null}getCapabilities(){return K}}class Q{constructor(e,t,n){this.component=e,this.delegate=t,this.args=n}}function X(t,n={}){return e("3.22"===t,(()=>`Invalid modifier manager compatibility specified; you specified ${t}, but only '3.22' is supported.`)),{disableAutoTracking:Boolean(n.disableAutoTracking)}}class Y{constructor(e){this.factory=e,this.componentManagerDelegates=new WeakMap}getDelegateFor(e){let{componentManagerDelegates:t}=this,n=t.get(e);if(void 0===n){let{factory:o}=this;n=o(e),t.set(e,n)}return n}create(e,t,o,r){let a,i=this.getDelegateFor(e),l=y(r),s=i.createModifier(o,l);return a={tag:u(),element:t,delegate:i,args:l,modifier:s},n(a,(()=>i.destroyModifier(s,l))),a}getDebugName(e){return"function"==typeof e?e.name||e.toString():"<unknown>"}getDebugInstance({modifier:e}){return e}getTag({tag:e}){return e}install({element:e,args:t,modifier:n,delegate:o}){let{capabilities:r}=o;r.disableAutoTracking?s((()=>o.installModifier(n,e,t))):o.installModifier(n,e,t)}update({args:e,modifier:t,delegate:n}){let{capabilities:o}=n;o.disableAutoTracking?s((()=>n.updateModifier(t,e))):n.updateModifier(t,e)}getDestroyable(e){return e}}function Z(e,t){return $(new J(e),t)}function _(e,t){return B(new Y(e),t)}function ee(e,t){return L(new A(e),t)}const te=new WeakMap,ne=Reflect.getPrototypeOf;function oe(e,t){return te.set(t,e),t}function re(e){let t=e;for(;null!==t;){let e=te.get(t);if(void 0!==e)return e;t=ne(t)}}export{J as CustomComponentManager,A as CustomHelperManager,Y as CustomModifierManager,w as capabilityFlagsFrom,q as componentCapabilities,re as getComponentTemplate,d as getCustomTagFor,I as getInternalComponentManager,V as getInternalHelperManager,E as getInternalModifierManager,v as hasCapability,H as hasDestroyable,P as hasInternalComponentManager,U as hasInternalHelperManager,R as hasInternalModifierManager,C as hasValue,M as helperCapabilities,k as managerHasCapability,X as modifierCapabilities,Z as setComponentManager,oe as setComponentTemplate,p as setCustomTagFor,ee as setHelperManager,$ as setInternalComponentManager,L as setInternalHelperManager,B as setInternalModifierManager,_ as setModifierManager};
//# sourceMappingURL=index.js.map
