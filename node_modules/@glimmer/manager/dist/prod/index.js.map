{"version":3,"file":"index.js","sources":["../../lib/util/args-proxy.ts","../../lib/util/capabilities.ts","../../lib/public/helper.ts","../../lib/internal/defaults.ts","../../lib/internal/api.ts","../../../debug-util/lib/debug-to-string.ts","../../lib/public/component.ts","../../lib/public/modifier.ts","../../lib/public/api.ts","../../lib/public/template.ts"],"sourcesContent":["import type {\n  Arguments,\n  CapturedArguments,\n  CapturedNamedArguments,\n  CapturedPositionalArguments,\n} from '@glimmer/interfaces';\nimport type { Tag } from '@glimmer/validator';\nimport { valueForRef } from '@glimmer/reference';\nimport { track } from '@glimmer/validator';\n\nconst CUSTOM_TAG_FOR = new WeakMap<object, (obj: object, key: string) => Tag>();\n\nexport function getCustomTagFor(obj: object): ((obj: object, key: string) => Tag) | undefined {\n  return CUSTOM_TAG_FOR.get(obj);\n}\n\nexport function setCustomTagFor(obj: object, customTagFn: (obj: object, key: string) => Tag) {\n  CUSTOM_TAG_FOR.set(obj, customTagFn);\n}\n\nfunction convertToInt(prop: number | string | symbol): number | null {\n  if (typeof prop === 'symbol') return null;\n\n  const num = Number(prop);\n\n  if (isNaN(num)) return null;\n\n  return num % 1 === 0 ? num : null;\n}\n\nfunction tagForNamedArg(namedArgs: CapturedNamedArguments, key: string): Tag {\n  return track(() => {\n    if (key in namedArgs) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      valueForRef(namedArgs[key]!);\n    }\n  });\n}\n\nfunction tagForPositionalArg(positionalArgs: CapturedPositionalArguments, key: string): Tag {\n  return track(() => {\n    if (key === '[]') {\n      // consume all of the tags in the positional array\n      positionalArgs.forEach(valueForRef);\n    }\n\n    const parsed = convertToInt(key);\n\n    if (parsed !== null && parsed < positionalArgs.length) {\n      // consume the tag of the referenced index\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      valueForRef(positionalArgs[parsed]!);\n    }\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme\nclass NamedArgsProxy implements ProxyHandler<{}> {\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme\n  declare set?: (target: {}, prop: string | number | symbol) => boolean;\n\n  constructor(private named: CapturedNamedArguments) {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme\n  get(_target: {}, prop: string | number | symbol) {\n    const ref = this.named[prop as string];\n\n    if (ref !== undefined) {\n      return valueForRef(ref);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme\n  has(_target: {}, prop: string | number | symbol) {\n    return prop in this.named;\n  }\n\n  ownKeys() {\n    return Object.keys(this.named);\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme\n  getOwnPropertyDescriptor(_target: {}, prop: string | number | symbol) {\n    if (import.meta.env.DEV && !(prop in this.named)) {\n      throw new Error(\n        `args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \\`${String(\n          prop\n        )}\\``\n      );\n    }\n\n    return {\n      enumerable: true,\n      configurable: true,\n    };\n  }\n}\n\nclass PositionalArgsProxy implements ProxyHandler<[]> {\n  declare set?: (target: [], prop: string | number | symbol) => boolean;\n  declare ownKeys?: (target: []) => string[];\n\n  constructor(private positional: CapturedPositionalArguments) {}\n\n  get(target: [], prop: string | number | symbol) {\n    let { positional } = this;\n\n    if (prop === 'length') {\n      return positional.length;\n    }\n\n    const parsed = convertToInt(prop);\n\n    if (parsed !== null && parsed < positional.length) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      return valueForRef(positional[parsed]!);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n    return (target as any)[prop];\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  has(_target: [], prop: string | number | symbol) {\n    const parsed = convertToInt(prop);\n\n    return parsed !== null && parsed < this.positional.length;\n  }\n}\n\nexport const argsProxyFor = (\n  capturedArgs: CapturedArguments,\n  type: 'component' | 'helper' | 'modifier'\n): Arguments => {\n  const { named, positional } = capturedArgs;\n\n  let getNamedTag = (_obj: object, key: string) => tagForNamedArg(named, key);\n  let getPositionalTag = (_obj: object, key: string) => tagForPositionalArg(positional, key);\n\n  const namedHandler = new NamedArgsProxy(named);\n  const positionalHandler = new PositionalArgsProxy(positional);\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const namedTarget = Object.create(null);\n  const positionalTarget: unknown[] = [];\n\n  if (import.meta.env.DEV) {\n    const setHandler = function (_target: unknown, prop: symbol | string | number): never {\n      throw new Error(\n        `You attempted to set ${String(\n          prop\n        )} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`\n      );\n    };\n\n    const forInDebugHandler = (): never => {\n      throw new Error(\n        `Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`\n      );\n    };\n\n    namedHandler.set = setHandler;\n    positionalHandler.set = setHandler;\n    positionalHandler.ownKeys = forInDebugHandler;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const namedProxy = new Proxy(namedTarget, namedHandler);\n  const positionalProxy = new Proxy(positionalTarget, positionalHandler);\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  setCustomTagFor(namedProxy, getNamedTag);\n  setCustomTagFor(positionalProxy, getPositionalTag);\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    named: namedProxy,\n    positional: positionalProxy,\n  };\n};\n","import type {\n  AttributeHookCapability,\n  Capabilities,\n  CapabilityMask,\n  CreateArgsCapability,\n  CreateCallerCapability,\n  CreateInstanceCapability,\n  DynamicLayoutCapability,\n  DynamicScopeCapability,\n  DynamicTagCapability,\n  ElementHookCapability,\n  Expand,\n  HasSubOwnerCapability,\n  InternalComponentCapability,\n  InternalComponentManager,\n  PrepareArgsCapability,\n  UpdateHookCapability,\n  WillDestroyCapability,\n  WithCreateInstance,\n  WithDynamicLayout,\n  WithPrepareArgs,\n  WithSubOwner,\n  WithUpdateHook,\n  WrappedCapability,\n} from '@glimmer/interfaces';\nimport { check, CheckNumber } from '@glimmer/debug';\nimport { InternalComponentCapabilities } from '@glimmer/vm';\n\nexport const FROM_CAPABILITIES = import.meta.env.DEV ? new WeakSet() : undefined;\n\nexport function buildCapabilities<T extends object>(capabilities: T): T & Capabilities {\n  if (import.meta.env.DEV) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    FROM_CAPABILITIES!.add(capabilities);\n    Object.freeze(capabilities);\n  }\n\n  return capabilities as T & Capabilities;\n}\n\nconst EMPTY = InternalComponentCapabilities.Empty;\n\ntype CapabilityOptions = Expand<{\n  [P in keyof Omit<typeof InternalComponentCapabilities, 'Empty'>]?: boolean | undefined;\n}>;\n\n/**\n * Converts a ComponentCapabilities object into a 32-bit integer representation.\n */\nexport function capabilityFlagsFrom(capabilities: CapabilityOptions): CapabilityMask {\n  return (EMPTY |\n    capability(capabilities, 'dynamicLayout') |\n    capability(capabilities, 'dynamicTag') |\n    capability(capabilities, 'prepareArgs') |\n    capability(capabilities, 'createArgs') |\n    capability(capabilities, 'attributeHook') |\n    capability(capabilities, 'elementHook') |\n    capability(capabilities, 'dynamicScope') |\n    capability(capabilities, 'createCaller') |\n    capability(capabilities, 'updateHook') |\n    capability(capabilities, 'createInstance') |\n    capability(capabilities, 'wrapped') |\n    capability(capabilities, 'willDestroy') |\n    capability(capabilities, 'hasSubOwner')) as CapabilityMask;\n}\n\nfunction capability(\n  capabilities: CapabilityOptions,\n  capability: keyof CapabilityOptions\n): InternalComponentCapability {\n  return capabilities[capability] ? InternalComponentCapabilities[capability] : EMPTY;\n}\n\nexport type InternalComponentCapabilityFor<C extends InternalComponentCapability> =\n  C extends DynamicLayoutCapability\n    ? WithDynamicLayout\n    : C extends DynamicTagCapability\n      ? InternalComponentManager\n      : C extends PrepareArgsCapability\n        ? WithPrepareArgs\n        : C extends CreateArgsCapability\n          ? InternalComponentManager\n          : C extends AttributeHookCapability\n            ? InternalComponentManager\n            : C extends ElementHookCapability\n              ? InternalComponentManager\n              : C extends DynamicScopeCapability\n                ? InternalComponentManager\n                : C extends CreateCallerCapability\n                  ? InternalComponentManager\n                  : C extends UpdateHookCapability\n                    ? WithUpdateHook\n                    : C extends CreateInstanceCapability\n                      ? WithCreateInstance\n                      : C extends WrappedCapability\n                        ? InternalComponentManager\n                        : C extends WillDestroyCapability\n                          ? InternalComponentManager\n                          : C extends HasSubOwnerCapability\n                            ? WithSubOwner\n                            : never;\n\nexport function managerHasCapability<F extends InternalComponentCapability>(\n  _manager: InternalComponentManager,\n  capabilities: CapabilityMask,\n  capability: F\n): _manager is InternalComponentCapabilityFor<F> {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n\nexport function hasCapability(\n  capabilities: CapabilityMask,\n  capability: InternalComponentCapability\n): boolean {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n","import type {\n  Helper,\n  HelperCapabilities,\n  HelperCapabilitiesVersions,\n  HelperDefinitionState,\n  HelperManager,\n  HelperManagerWithDestroyable,\n  HelperManagerWithValue,\n  InternalHelperManager,\n  Owner,\n} from '@glimmer/interfaces';\nimport { associateDestroyableChild } from '@glimmer/destroyable';\nimport { debugAssert } from '@glimmer/global-context';\nimport { createComputeRef, createConstRef, UNDEFINED_REFERENCE } from '@glimmer/reference';\n\nimport type { ManagerFactory } from './index';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nexport function helperCapabilities<Version extends keyof HelperCapabilitiesVersions>(\n  managerAPI: Version,\n  options: Partial<HelperCapabilities> = {}\n): HelperCapabilities {\n  debugAssert(\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check\n    managerAPI === '3.23',\n    () =>\n      `Invalid helper manager compatibility specified; you specified ${managerAPI}, but only '3.23' is supported.`\n  );\n\n  if (\n    import.meta.env.DEV &&\n    (!(options.hasValue || options.hasScheduledEffect) ||\n      (options.hasValue && options.hasScheduledEffect))\n  ) {\n    throw new Error(\n      'You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.'\n    );\n  }\n\n  if (import.meta.env.DEV && options.hasScheduledEffect) {\n    throw new Error(\n      'The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead'\n    );\n  }\n\n  return buildCapabilities({\n    hasValue: Boolean(options.hasValue),\n    hasDestroyable: Boolean(options.hasDestroyable),\n    hasScheduledEffect: Boolean(options.hasScheduledEffect),\n  });\n}\n\n////////////\n\nexport function hasValue(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithValue<unknown> {\n  return manager.capabilities.hasValue;\n}\n\nexport function hasDestroyable(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithDestroyable<unknown> {\n  return manager.capabilities.hasDestroyable;\n}\n\n////////////\n\nexport class CustomHelperManager<O extends Owner = Owner> implements InternalHelperManager<O> {\n  constructor(private factory: ManagerFactory<O | undefined, HelperManager<unknown>>) {}\n\n  private helperManagerDelegates = new WeakMap<O, HelperManager<unknown>>();\n  private undefinedDelegate: HelperManager<unknown> | null = null;\n\n  private getDelegateForOwner(owner: O) {\n    let delegate = this.helperManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom helper managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.23')\\` (imported via \\`import { capabilities } from '@ember/helper';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      this.helperManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  getDelegateFor(owner: O | undefined) {\n    if (owner === undefined) {\n      let { undefinedDelegate } = this;\n\n      if (undefinedDelegate === null) {\n        let { factory } = this;\n        this.undefinedDelegate = undefinedDelegate = factory(undefined);\n      }\n\n      return undefinedDelegate;\n    } else {\n      return this.getDelegateForOwner(owner);\n    }\n  }\n\n  getHelper(definition: HelperDefinitionState): Helper {\n    return (capturedArgs, owner) => {\n      let manager = this.getDelegateFor(owner as O | undefined);\n\n      const args = argsProxyFor(capturedArgs, 'helper');\n      const bucket = manager.createHelper(definition, args);\n\n      if (hasValue(manager)) {\n        let cache = createComputeRef(\n          () => manager.getValue(bucket),\n          null,\n          import.meta.env.DEV && manager.getDebugName && manager.getDebugName(definition)\n        );\n\n        if (hasDestroyable(manager)) {\n          associateDestroyableChild(cache, manager.getDestroyable(bucket));\n        }\n\n        return cache;\n      } else if (hasDestroyable(manager)) {\n        let ref = createConstRef(\n          undefined,\n          import.meta.env.DEV && (manager.getDebugName?.(definition) ?? 'unknown helper')\n        );\n\n        associateDestroyableChild(ref, manager.getDestroyable(bucket));\n\n        return ref;\n      } else {\n        return UNDEFINED_REFERENCE;\n      }\n    };\n  }\n}\n","import type {\n  CapturedArguments as Arguments,\n  HelperCapabilities,\n  HelperManagerWithValue,\n} from '@glimmer/interfaces';\n\nimport { buildCapabilities } from '../util/capabilities';\n\ntype FnArgs<Args extends Arguments = Arguments> =\n  | [...Args['positional'], Args['named']]\n  | [...Args['positional']];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyFunction = (...args: any[]) => unknown;\n\ninterface State {\n  fn: AnyFunction;\n  args: Arguments;\n}\n\nexport class FunctionHelperManager implements HelperManagerWithValue<State> {\n  capabilities = buildCapabilities({\n    hasValue: true,\n    hasDestroyable: false,\n    hasScheduledEffect: false,\n  }) as HelperCapabilities;\n\n  createHelper(fn: AnyFunction, args: Arguments): State {\n    return { fn, args };\n  }\n\n  getValue({ fn, args }: State): unknown {\n    if (Object.keys(args.named).length > 0) {\n      let argsForFn: FnArgs = [...args.positional, args.named];\n\n      return fn(...argsForFn);\n    }\n\n    return fn(...args.positional);\n  }\n\n  getDebugName(fn: AnyFunction): string {\n    if (fn.name) {\n      return `(helper function ${fn.name})`;\n    }\n\n    return '(anonymous helper function)';\n  }\n}\n","import type {\n  Helper,\n  InternalComponentManager,\n  InternalModifierManager,\n  Owner,\n} from '@glimmer/interfaces';\nimport { debugToString } from '@glimmer/debug-util';\nimport { debugAssert } from '@glimmer/global-context';\n\nimport { CustomHelperManager } from '../public/helper';\nimport { FunctionHelperManager } from './defaults';\n\ntype InternalManager =\n  | InternalComponentManager\n  | InternalModifierManager\n  | CustomHelperManager\n  | Helper;\n\nconst COMPONENT_MANAGERS = new WeakMap<object, InternalComponentManager>();\n\nconst MODIFIER_MANAGERS = new WeakMap<object, InternalModifierManager>();\n\nconst HELPER_MANAGERS = new WeakMap<object, CustomHelperManager | Helper>();\n\n///////////\n\n/**\n * There is also Reflect.getPrototypeOf,\n * which errors when non-objects are passed.\n *\n * Since our conditional for figuring out whether to render primitives or not\n * may contain non-object values, we don't want to throw errors when we call this.\n */\nconst getPrototypeOf = Object.getPrototypeOf;\n\nfunction setManager<Def extends object>(\n  map: WeakMap<object, object>,\n  manager: object,\n  obj: Def\n): Def {\n  if (import.meta.env.DEV) {\n    debugAssert(\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check\n      obj !== null && (typeof obj === 'object' || typeof obj === 'function'),\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      `Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${debugToString!(\n        obj\n      )}`\n    );\n\n    debugAssert(\n      !map.has(obj), // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      `Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${debugToString!(\n        obj\n      )}`\n    );\n  }\n\n  map.set(obj, manager);\n  return obj;\n}\n\nfunction getManager<M extends InternalManager>(\n  map: WeakMap<object, M>,\n  obj: object\n): M | undefined {\n  let pointer: object | null = obj;\n  while (pointer !== null) {\n    const manager = map.get(pointer);\n\n    if (manager !== undefined) {\n      return manager;\n    }\n\n    pointer = getPrototypeOf(pointer) as object | null;\n  }\n\n  return undefined;\n}\n\n///////////\n\nexport function setInternalModifierManager<T extends object>(\n  manager: InternalModifierManager,\n  definition: T\n): T {\n  return setManager(MODIFIER_MANAGERS, manager, definition);\n}\n\nexport function getInternalModifierManager(definition: object): InternalModifierManager;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalModifierManager | null;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional?: true\n): InternalModifierManager | null {\n  if (import.meta.env.DEV) {\n    debugAssert(\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check\n      (typeof definition === 'object' && definition !== null) || typeof definition === 'function',\n      () =>\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n        `Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${definition}`\n    );\n  }\n\n  const manager = getManager(MODIFIER_MANAGERS, definition);\n\n  if (manager === undefined) {\n    if (import.meta.env.DEV) {\n      debugAssert(\n        isOptional,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        `Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n\n    return null;\n  }\n\n  return manager;\n}\n\nexport function setInternalHelperManager<T extends object, O extends Owner>(\n  manager: CustomHelperManager<O> | Helper<O>,\n  definition: T\n): T {\n  return setManager(HELPER_MANAGERS, manager, definition);\n}\n\nconst DEFAULT_MANAGER = new CustomHelperManager(() => new FunctionHelperManager());\n\nexport function getInternalHelperManager(definition: object): CustomHelperManager | Helper;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional: true | undefined\n): CustomHelperManager | Helper | null;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional?: true\n): CustomHelperManager | Helper | null {\n  debugAssert(\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check\n    (typeof definition === 'object' && definition !== null) || typeof definition === 'function',\n    () =>\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n      `Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${definition}`\n  );\n\n  let manager = getManager(HELPER_MANAGERS, definition);\n\n  // Functions are special-cased because functions are defined\n  // as the \"default\" helper, per: https://github.com/emberjs/rfcs/pull/756\n  if (manager === undefined && typeof definition === 'function') {\n    manager = DEFAULT_MANAGER;\n  }\n\n  if (manager) {\n    return manager;\n  } else if (isOptional === true) {\n    return null;\n  } else if (import.meta.env.DEV) {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      `Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${debugToString!(\n        definition\n      )}`\n    );\n  }\n\n  return null;\n}\n\nexport function setInternalComponentManager<T extends object>(\n  factory: InternalComponentManager,\n  obj: T\n): T {\n  return setManager(COMPONENT_MANAGERS, factory, obj);\n}\n\nexport function getInternalComponentManager(definition: object): InternalComponentManager;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalComponentManager | null;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional?: true\n): InternalComponentManager | null {\n  debugAssert(\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check\n    (typeof definition === 'object' && definition !== null) || typeof definition === 'function',\n    () =>\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n      `Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${definition}`\n  );\n\n  const manager = getManager(COMPONENT_MANAGERS, definition);\n\n  if (manager === undefined) {\n    debugAssert(\n      isOptional,\n      () =>\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        `Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n    );\n\n    return null;\n  }\n\n  return manager;\n}\n\n///////////\n\nexport function hasInternalComponentManager(definition: object): boolean {\n  return (\n    hasDefaultComponentManager(definition) ||\n    getManager(COMPONENT_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalHelperManager(definition: object): boolean {\n  return (\n    hasDefaultHelperManager(definition) || getManager(HELPER_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalModifierManager(definition: object): boolean {\n  return (\n    hasDefaultModifierManager(definition) || getManager(MODIFIER_MANAGERS, definition) !== undefined\n  );\n}\n\nfunction hasDefaultComponentManager(_definition: object): boolean {\n  return false;\n}\n\nfunction hasDefaultHelperManager(definition: object): boolean {\n  return typeof definition === 'function';\n}\n\nfunction hasDefaultModifierManager(_definition: object): boolean {\n  return false;\n}\n","import type { AnyFn } from '@glimmer/interfaces';\n\nlet debugToString: undefined | ((value: unknown) => string);\n\nif (import.meta.env.DEV) {\n  let getFunctionName = (fn: AnyFn) => {\n    let functionName = fn.name;\n\n    if (functionName === '') {\n      let match = /function (\\w+)\\s*\\(/u.exec(String(fn));\n\n      functionName = (match && match[1]) || '';\n    }\n\n    return functionName.replace(/^bound /u, '');\n  };\n\n  let getObjectName = (obj: object) => {\n    let name;\n    let className;\n\n    if (typeof obj.constructor === 'function') {\n      className = getFunctionName(obj.constructor);\n    }\n\n    if (\n      'toString' in obj &&\n      obj.toString !== Object.prototype.toString &&\n      obj.toString !== Function.prototype.toString\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      name = obj.toString();\n    }\n\n    // If the class has a decent looking name, and the `toString` is one of the\n    // default Ember toStrings, replace the constructor portion of the toString\n    // with the class name. We check the length of the class name to prevent doing\n    // this when the value is minified.\n    if (\n      name &&\n      /<.*:ember\\d+>/u.test(name) &&\n      className &&\n      className[0] !== '_' &&\n      className.length > 2 &&\n      className !== 'Class'\n    ) {\n      return name.replace(/<.*:/u, `<${className}:`);\n    }\n\n    return name || className;\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let getPrimitiveName = (value: any) => {\n    return String(value);\n  };\n\n  debugToString = (value: unknown) => {\n    if (typeof value === 'function') {\n      return getFunctionName(value) || `(unknown function)`;\n    } else if (typeof value === 'object' && value !== null) {\n      return getObjectName(value) || `(unknown object)`;\n    } else {\n      return getPrimitiveName(value);\n    }\n  };\n}\n\nexport default debugToString;\n","import type {\n  Arguments,\n  ComponentCapabilities,\n  ComponentCapabilitiesVersions,\n  ComponentDefinitionState,\n  ComponentManager,\n  ComponentManagerWithAsyncLifeCycleCallbacks,\n  ComponentManagerWithAsyncUpdateHook,\n  ComponentManagerWithDestructors,\n  ComponentManagerWithUpdateHook,\n  Destroyable,\n  InternalComponentCapabilities,\n  InternalComponentManager,\n  Nullable,\n  Owner,\n  VMArguments,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { createConstRef } from '@glimmer/reference';\n\nimport type { ManagerFactory } from './api';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nconst CAPABILITIES = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  createCaller: false,\n  dynamicScope: true,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport function componentCapabilities<Version extends keyof ComponentCapabilitiesVersions>(\n  managerAPI: Version,\n  options: ComponentCapabilitiesVersions[Version] = {}\n): ComponentCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.13') {\n    throw new Error('Invalid component manager compatibility specified');\n  }\n\n  let updateHook = Boolean((options as ComponentCapabilitiesVersions['3.13']).updateHook);\n\n  return buildCapabilities({\n    asyncLifeCycleCallbacks: Boolean(options.asyncLifecycleCallbacks),\n    destructor: Boolean(options.destructor),\n    updateHook,\n  });\n}\n\nexport function hasAsyncLifeCycleCallbacks<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncLifeCycleCallbacks<ComponentInstance> {\n  return delegate.capabilities.asyncLifeCycleCallbacks;\n}\n\nexport function hasUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithUpdateHook<ComponentInstance> {\n  return delegate.capabilities.updateHook;\n}\n\nexport function hasAsyncUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncUpdateHook<ComponentInstance> {\n  return hasAsyncLifeCycleCallbacks(delegate) && hasUpdateHook(delegate);\n}\n\nexport function hasDestructors<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithDestructors<ComponentInstance> {\n  return delegate.capabilities.destructor;\n}\n\n/**\n  The CustomComponentManager allows addons to provide custom component\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom component manager, which\n  implements a set of hooks that determine component behavior.\n\n  To create a custom component manager, instantiate a new CustomComponentManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomComponentManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a component, the component manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n\n  * `create()` - invoked when a new instance of a component should be created\n  * `update()` - invoked when the arguments passed to a component change\n  * `getContext()` - returns the object that should be\n*/\nexport class CustomComponentManager<O extends Owner, ComponentInstance>\n  implements InternalComponentManager<CustomComponentState<ComponentInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ComponentManager<ComponentInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ComponentManager<ComponentInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom component managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.13')\\` (imported via \\`import { capabilities } from '@ember/component';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(\n    owner: O,\n    definition: ComponentDefinitionState,\n    vmArgs: VMArguments\n  ): CustomComponentState<ComponentInstance> {\n    let delegate = this.getDelegateFor(owner);\n    let args = argsProxyFor(vmArgs.capture(), 'component');\n\n    let component: ComponentInstance = delegate.createComponent(definition, args);\n\n    return new CustomComponentState(component, delegate, args);\n  }\n\n  getDebugName(definition: ComponentDefinitionState): string {\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    return typeof definition === 'function' ? definition.name : definition.toString();\n  }\n\n  update(bucket: CustomComponentState<ComponentInstance>): void {\n    let { delegate } = bucket;\n    if (hasUpdateHook(delegate)) {\n      let { component, args } = bucket;\n\n      delegate.updateComponent(component, args);\n    }\n  }\n\n  didCreate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncLifeCycleCallbacks(delegate)) {\n      delegate.didCreateComponent(component);\n    }\n  }\n\n  didUpdate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncUpdateHook(delegate)) {\n      delegate.didUpdateComponent(component);\n    }\n  }\n\n  didRenderLayout(): void {}\n\n  didUpdateLayout(): void {}\n\n  getSelf({ component, delegate }: CustomComponentState<ComponentInstance>): Reference {\n    return createConstRef(delegate.getContext(component), 'this');\n  }\n\n  getDestroyable(bucket: CustomComponentState<ComponentInstance>): Nullable<Destroyable> {\n    const { delegate } = bucket;\n\n    if (hasDestructors(delegate)) {\n      const { component } = bucket;\n\n      registerDestructor(bucket, () => delegate.destroyComponent(component));\n      return bucket;\n    }\n\n    return null;\n  }\n\n  getCapabilities(): InternalComponentCapabilities {\n    return CAPABILITIES;\n  }\n}\n\n/**\n * Stores internal state about a component instance after it's been created.\n */\nexport class CustomComponentState<ComponentInstance> {\n  constructor(\n    public component: ComponentInstance,\n    public delegate: ComponentManager<ComponentInstance>,\n    public args: Arguments\n  ) {}\n}\n","import type {\n  Arguments,\n  CapturedArguments,\n  InternalModifierManager,\n  ModifierCapabilities,\n  ModifierCapabilitiesVersions,\n  ModifierManager,\n  Owner,\n  SimpleElement,\n  UpdatableTag,\n} from '@glimmer/interfaces';\nimport { castToBrowser } from '@glimmer/debug-util';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { debugAssert } from '@glimmer/global-context';\nimport { valueForRef } from '@glimmer/reference';\nimport { dict } from '@glimmer/util';\nimport { createUpdatableTag, untrack } from '@glimmer/validator';\n\nimport type { ManagerFactory } from '.';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nexport function modifierCapabilities<Version extends keyof ModifierCapabilitiesVersions>(\n  managerAPI: Version,\n  optionalFeatures: ModifierCapabilitiesVersions[Version] = {}\n): ModifierCapabilities {\n  debugAssert(\n    (managerAPI as string) === '3.22',\n    () =>\n      `Invalid modifier manager compatibility specified; you specified ${managerAPI}, but only '3.22' is supported.`\n  );\n\n  return buildCapabilities({\n    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking),\n  });\n}\n\nexport interface CustomModifierState<ModifierInstance> {\n  tag: UpdatableTag;\n  element: SimpleElement;\n  modifier: ModifierInstance;\n  delegate: ModifierManager<ModifierInstance>;\n  args: Arguments;\n  debugName?: string;\n}\n\n/**\n  The CustomModifierManager allows addons to provide custom modifier\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom modifier manager, which\n  implements a set of hooks that determine modifier behavior.\n  To create a custom modifier manager, instantiate a new CustomModifierManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomModifierManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a modifier, the modifier manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n  * `createModifier()` - invoked when a new instance of a modifier should be created\n  * `installModifier()` - invoked when the modifier is installed on the element\n  * `updateModifier()` - invoked when the arguments passed to a modifier change\n  * `destroyModifier()` - invoked when the modifier is about to be destroyed\n*/\nexport class CustomModifierManager<O extends Owner, ModifierInstance>\n  implements InternalModifierManager<CustomModifierState<ModifierInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ModifierManager<ModifierInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ModifierManager<ModifierInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom modifier managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.22')\\` (imported via \\`import { capabilities } from '@ember/modifier';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(owner: O, element: SimpleElement, definition: object, capturedArgs: CapturedArguments) {\n    let delegate = this.getDelegateFor(owner);\n\n    let args = argsProxyFor(capturedArgs, 'modifier');\n    let instance: ModifierInstance = delegate.createModifier(definition, args);\n\n    let tag = createUpdatableTag();\n    let state: CustomModifierState<ModifierInstance>;\n\n    state = {\n      tag,\n      element,\n      delegate,\n      args,\n      modifier: instance,\n    };\n\n    registerDestructor(state, () => delegate.destroyModifier(instance, args));\n\n    return state;\n  }\n\n  getDebugName(definition: object) {\n    if (typeof definition === 'function') {\n      return definition.name || definition.toString();\n    } else {\n      return '<unknown>';\n    }\n  }\n\n  getDebugInstance({ modifier }: CustomModifierState<ModifierInstance>) {\n    return modifier;\n  }\n\n  getTag({ tag }: CustomModifierState<ModifierInstance>) {\n    return tag;\n  }\n\n  install({ element, args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking) {\n      untrack(() => delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args));\n    } else {\n      delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args);\n    }\n  }\n\n  update({ args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking) {\n      untrack(() => delegate.updateModifier(modifier, args));\n    } else {\n      delegate.updateModifier(modifier, args);\n    }\n  }\n\n  getDestroyable(state: CustomModifierState<ModifierInstance>) {\n    return state;\n  }\n}\n\nexport function reifyArgs({ named, positional }: CapturedArguments): {\n  named: Record<string, unknown>;\n  positional: unknown[];\n} {\n  let reifiedNamed = dict();\n\n  for (const [key, value] of Object.entries(named)) {\n    reifiedNamed[key] = valueForRef(value);\n  }\n\n  let reifiedPositional = positional.map(valueForRef);\n\n  return {\n    named: reifiedNamed,\n    positional: reifiedPositional,\n  };\n}\n","import type { ComponentManager, HelperManager, ModifierManager, Owner } from '@glimmer/interfaces';\n\nimport {\n  setInternalComponentManager,\n  setInternalHelperManager,\n  setInternalModifierManager,\n} from '../internal/api';\nimport { CustomComponentManager } from './component';\nimport { CustomHelperManager } from './helper';\nimport { CustomModifierManager } from './modifier';\n\ntype Manager = ComponentManager<unknown> | ModifierManager<unknown> | HelperManager<unknown>;\n\nexport type ManagerFactory<O, D extends Manager = Manager> = (owner: O) => D;\n\nexport function setComponentManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ComponentManager<unknown>>,\n  obj: T\n): T {\n  return setInternalComponentManager(new CustomComponentManager(factory), obj);\n}\n\nexport function setModifierManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ModifierManager<unknown>>,\n  obj: T\n): T {\n  return setInternalModifierManager(new CustomModifierManager(factory), obj);\n}\n\nexport function setHelperManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O | undefined, HelperManager<unknown>>,\n  obj: T\n): T {\n  return setInternalHelperManager(new CustomHelperManager(factory), obj);\n}\n","import type { TemplateFactory } from '@glimmer/interfaces';\nimport { debugToString } from '@glimmer/debug-util';\n\nconst TEMPLATES: WeakMap<object, TemplateFactory> = new WeakMap();\n\nconst getPrototypeOf = Reflect.getPrototypeOf;\n\nexport function setComponentTemplate(factory: TemplateFactory, obj: object) {\n  if (\n    import.meta.env.DEV &&\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check\n    !(obj !== null && (typeof obj === 'object' || typeof obj === 'function'))\n  ) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    throw new Error(`Cannot call \\`setComponentTemplate\\` on \\`${debugToString!(obj)}\\``);\n  }\n\n  if (import.meta.env.DEV && TEMPLATES.has(obj)) {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      `Cannot call \\`setComponentTemplate\\` multiple times on the same class (\\`${debugToString!(\n        obj\n      )}\\`)`\n    );\n  }\n\n  TEMPLATES.set(obj, factory);\n\n  return obj;\n}\n\nexport function getComponentTemplate(obj: object): TemplateFactory | undefined {\n  let pointer: object | null = obj;\n\n  while (pointer !== null) {\n    let template = TEMPLATES.get(pointer);\n\n    if (template !== undefined) {\n      return template;\n    }\n\n    pointer = getPrototypeOf(pointer);\n  }\n\n  return undefined;\n}\n"],"names":["CUSTOM_TAG_FOR","WeakMap","getCustomTagFor","obj","get","setCustomTagFor","customTagFn","set","convertToInt","prop","num","Number","isNaN","NamedArgsProxy","constructor","named","_target","ref","this","undefined","valueForRef","has","ownKeys","Object","keys","isExtensible","getOwnPropertyDescriptor","enumerable","configurable","PositionalArgsProxy","positional","target","length","parsed","argsProxyFor","capturedArgs","namedHandler","positionalHandler","namedTarget","create","namedProxy","Proxy","positionalProxy","_obj","key","namedArgs","track","tagForNamedArg","positionalArgs","forEach","tagForPositionalArg","EMPTY","InternalComponentCapabilities","Empty","capabilityFlagsFrom","capabilities","capability","managerHasCapability","_manager","hasCapability","helperCapabilities","managerAPI","options","debugAssert","hasValue","Boolean","hasDestroyable","hasScheduledEffect","manager","CustomHelperManager","factory","helperManagerDelegates","undefinedDelegate","getDelegateForOwner","owner","delegate","getDelegateFor","getHelper","definition","args","bucket","createHelper","cache","createComputeRef","getValue","associateDestroyableChild","getDestroyable","createConstRef","UNDEFINED_REFERENCE","FunctionHelperManager","fn","getDebugName","name","COMPONENT_MANAGERS","MODIFIER_MANAGERS","HELPER_MANAGERS","getPrototypeOf","setManager","map","getManager","pointer","setInternalModifierManager","getInternalModifierManager","setInternalHelperManager","DEFAULT_MANAGER","getInternalHelperManager","setInternalComponentManager","getInternalComponentManager","isOptional","debugToString","hasInternalComponentManager","hasInternalHelperManager","hasDefaultHelperManager","hasInternalModifierManager","CAPABILITIES","dynamicLayout","dynamicTag","prepareArgs","createArgs","attributeHook","elementHook","createCaller","dynamicScope","updateHook","createInstance","wrapped","willDestroy","hasSubOwner","componentCapabilities","asyncLifeCycleCallbacks","asyncLifecycleCallbacks","destructor","hasAsyncLifeCycleCallbacks","hasUpdateHook","CustomComponentManager","componentManagerDelegates","vmArgs","capture","component","createComponent","CustomComponentState","toString","update","updateComponent","didCreate","didCreateComponent","didUpdate","hasAsyncUpdateHook","didUpdateComponent","didRenderLayout","didUpdateLayout","getSelf","getContext","hasDestructors","registerDestructor","destroyComponent","getCapabilities","modifierCapabilities","optionalFeatures","disableAutoTracking","CustomModifierManager","element","state","instance","createModifier","tag","createUpdatableTag","modifier","destroyModifier","getDebugInstance","getTag","install","untrack","installModifier","updateModifier","setComponentManager","setModifierManager","setHelperManager","TEMPLATES","Reflect","setComponentTemplate","getComponentTemplate","template"],"mappings":"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"}