import { ProgramConstants, Template, ConstantPool, HelperDefinitionState, ModifierDefinitionState, ComponentDefinitionState, ComponentDefinition, ResolvedComponentDefinition, RuntimeArtifacts, RuntimeOp, ProgramHeap, SomeVmOp, StdLibOperand, Program } from '@glimmer/interfaces';

declare class ConstantsImpl implements ProgramConstants {
    protected reifiedArrs: {
        [key: number]: unknown[];
    };
    defaultTemplate: Template;
    helperDefinitionCount: number;
    modifierDefinitionCount: number;
    componentDefinitionCount: number;
    private values;
    private indexMap;
    private helperDefinitionCache;
    private modifierDefinitionCache;
    private componentDefinitionCache;
    value(value: unknown): number;
    array(values: unknown[]): number;
    toPool(): ConstantPool;
    hasHandle(handle: number): boolean;
    helper(definitionState: HelperDefinitionState, _resolvedName: string | null, isOptional: true): number | null;
    helper(definitionState: HelperDefinitionState, _resolvedName?: string | null): number;
    modifier(definitionState: ModifierDefinitionState, resolvedName: string | null, isOptional: true): number | null;
    modifier(definitionState: ModifierDefinitionState, resolvedName?: string | null): number;
    component(definitionState: ComponentDefinitionState, owner: object): ComponentDefinition;
    resolvedComponent(resolvedDefinition: ResolvedComponentDefinition, resolvedName: string): ComponentDefinition;
    getValue<T>(index: number): T;
    getArray<T>(index: number): T[];
}

declare function artifacts(): RuntimeArtifacts;

declare class RuntimeOpImpl implements RuntimeOp {
    readonly heap: ProgramHeap;
    offset: number;
    constructor(heap: ProgramHeap);
    get size(): number;
    get isMachine(): 0 | 1;
    get type(): SomeVmOp;
    get op1(): number;
    get op2(): number;
    get op3(): number;
}

type Placeholder = [number, () => number];
type StdlibPlaceholder = [number, StdLibOperand];
/**
 * The Program Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)   | size (u32) |
 * | ... |  Handle  | Scope Size | State | Size       |
 * | ... | 32bits   | 30bits     | 2bits | 32bit      |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */
declare class ProgramHeapImpl implements ProgramHeap {
    offset: number;
    private heap;
    private handleTable;
    private handleState;
    private handle;
    constructor();
    entries(): number;
    pushRaw(value: number): void;
    pushOp(item: number): void;
    pushMachine(item: number): void;
    private sizeCheck;
    getbyaddr(address: number): number;
    setbyaddr(address: number, value: number): void;
    malloc(): number;
    finishMalloc(handle: number): void;
    size(): number;
    getaddr(handle: number): number;
    sizeof(handle: number): number;
    free(handle: number): void;
    /**
     * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
     * reachable memory to the bottom of the heap and freeable
     * memory to the top of the heap. When we have shifted all
     * the reachable memory to the top of the heap, we move the
     * offset to the next free position.
     */
    compact(): void;
}
declare class ProgramImpl implements Program {
    constants: ProgramConstants;
    heap: ProgramHeap;
    [key: number]: never;
    private _opcode;
    constructor(constants: ProgramConstants, heap: ProgramHeap);
    opcode(offset: number): RuntimeOpImpl;
}

export { ConstantsImpl, type Placeholder, ProgramHeapImpl, ProgramImpl, RuntimeOpImpl, type StdlibPlaceholder, artifacts };
