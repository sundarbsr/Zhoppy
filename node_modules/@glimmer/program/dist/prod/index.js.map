{"version":3,"file":"index.js","sources":["../../../debug-util/lib/template.ts","../../lib/util/default-template.ts","../../lib/constants.ts","../../../constants/lib/immediate.ts","../../lib/opcode.ts","../../lib/program.ts","../../lib/helpers.ts"],"sourcesContent":["import type { ErrHandle, HandleResult, OkHandle, Template, TemplateOk } from '@glimmer/interfaces';\n\nexport function unwrapHandle(handle: HandleResult): number {\n  if (typeof handle === 'number') {\n    return handle;\n  } else {\n    let error = handle.errors[0];\n    throw new Error(`Compile Error: ${error.problem} @ ${error.span.start}..${error.span.end}`);\n  }\n}\n\nexport function unwrapTemplate(template: Template): TemplateOk {\n  if (template.result === 'error') {\n    throw new Error(\n      `Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`\n    );\n  }\n\n  return template;\n}\n\nexport function extractHandle(handle: HandleResult): number {\n  if (typeof handle === 'number') {\n    return handle;\n  } else {\n    return handle.handle;\n  }\n}\n\nexport function isOkHandle(handle: HandleResult): handle is OkHandle {\n  return typeof handle === 'number';\n}\n\nexport function isErrHandle(handle: HandleResult): handle is ErrHandle {\n  return typeof handle === 'number';\n}\n","import type { SerializedTemplateBlock, SerializedTemplateWithLazyBlock } from '@glimmer/interfaces';\nimport { SexpOpcodes as op } from '@glimmer/wire-format';\n\n/**\n * Default component template, which is a plain yield\n */\nconst DEFAULT_TEMPLATE_BLOCK: SerializedTemplateBlock = [[[op.Yield, 1, null]], ['&default'], []];\n\nexport const DEFAULT_TEMPLATE: SerializedTemplateWithLazyBlock = {\n  // random uuid\n  id: '1b32f5c2-7623-43d6-a0ad-9672898920a1',\n  moduleName: '__default__.hbs',\n  block: JSON.stringify(DEFAULT_TEMPLATE_BLOCK),\n  scope: null,\n  isStrictMode: true,\n};\n","import type {\n  ComponentDefinition,\n  ComponentDefinitionState,\n  ConstantPool,\n  HelperDefinitionState,\n  ModifierDefinitionState,\n  Optional,\n  ProgramConstants,\n  ResolvedComponentDefinition,\n  Template,\n} from '@glimmer/interfaces';\nimport { constants } from '@glimmer/constants';\nimport { expect, localAssert, unwrapTemplate } from '@glimmer/debug-util';\nimport {\n  capabilityFlagsFrom,\n  getComponentTemplate,\n  getInternalComponentManager,\n  getInternalHelperManager,\n  getInternalModifierManager,\n  managerHasCapability,\n} from '@glimmer/manager';\nimport { templateFactory } from '@glimmer/opcode-compiler';\nimport { enumerate } from '@glimmer/util';\nimport { InternalComponentCapabilities } from '@glimmer/vm';\n\nimport { DEFAULT_TEMPLATE } from './util/default-template';\n\nconst WELL_KNOWN_EMPTY_ARRAY: unknown = Object.freeze([]);\nconst STARTER_CONSTANTS = constants(WELL_KNOWN_EMPTY_ARRAY);\nconst WELL_KNOWN_EMPTY_ARRAY_POSITION: number = STARTER_CONSTANTS.indexOf(WELL_KNOWN_EMPTY_ARRAY);\n\nexport class ConstantsImpl implements ProgramConstants {\n  protected reifiedArrs: { [key: number]: unknown[] } = {\n    [WELL_KNOWN_EMPTY_ARRAY_POSITION]: WELL_KNOWN_EMPTY_ARRAY as unknown[],\n  };\n\n  defaultTemplate: Template = templateFactory(DEFAULT_TEMPLATE)();\n\n  // Used for tests and debugging purposes, and to be able to analyze large apps\n  // This is why it's enabled even in production\n  helperDefinitionCount = 0;\n  modifierDefinitionCount = 0;\n  componentDefinitionCount = 0;\n\n  private values: unknown[] = STARTER_CONSTANTS.slice();\n  private indexMap: Map<unknown, number> = new Map(\n    this.values.map((value, index) => [value, index])\n  );\n\n  private helperDefinitionCache = new WeakMap<HelperDefinitionState, number | null>();\n\n  private modifierDefinitionCache = new WeakMap<ModifierDefinitionState, number | null>();\n\n  private componentDefinitionCache = new WeakMap<\n    ComponentDefinitionState | ResolvedComponentDefinition,\n    ComponentDefinition | null\n  >();\n\n  value(value: unknown) {\n    let indexMap = this.indexMap;\n    let index = indexMap.get(value);\n\n    if (index === undefined) {\n      index = this.values.push(value) - 1;\n      indexMap.set(value, index);\n    }\n\n    return index;\n  }\n\n  array(values: unknown[]): number {\n    if (values.length === 0) {\n      return WELL_KNOWN_EMPTY_ARRAY_POSITION;\n    }\n\n    let handles = new Array<number>(values.length);\n\n    for (let i = 0; i < values.length; i++) {\n      handles[i] = this.value(values[i]);\n    }\n\n    return this.value(handles);\n  }\n\n  toPool(): ConstantPool {\n    return this.values;\n  }\n\n  hasHandle(handle: number): boolean {\n    return this.values.length > handle;\n  }\n\n  helper(\n    definitionState: HelperDefinitionState,\n\n    // TODO: Add a way to expose resolved name for debugging\n    _resolvedName: string | null,\n    isOptional: true\n  ): number | null;\n  helper(\n    definitionState: HelperDefinitionState,\n\n    // TODO: Add a way to expose resolved name for debugging\n    _resolvedName?: string | null\n  ): number;\n  helper(\n    definitionState: HelperDefinitionState,\n\n    // TODO: Add a way to expose resolved name for debugging\n    _resolvedName: string | null = null,\n    isOptional?: true\n  ): number | null {\n    let handle = this.helperDefinitionCache.get(definitionState);\n\n    if (handle === undefined) {\n      let managerOrHelper = getInternalHelperManager(definitionState, isOptional);\n\n      if (managerOrHelper === null) {\n        this.helperDefinitionCache.set(definitionState, null);\n        return null;\n      }\n\n      localAssert(managerOrHelper, 'BUG: expected manager or helper');\n\n      let helper =\n        typeof managerOrHelper === 'function'\n          ? managerOrHelper\n          : managerOrHelper.getHelper(definitionState);\n\n      handle = this.value(helper);\n\n      this.helperDefinitionCache.set(definitionState, handle);\n      this.helperDefinitionCount++;\n    }\n\n    return handle;\n  }\n\n  modifier(\n    definitionState: ModifierDefinitionState,\n    resolvedName: string | null,\n    isOptional: true\n  ): number | null;\n  modifier(definitionState: ModifierDefinitionState, resolvedName?: string | null): number;\n  modifier(\n    definitionState: ModifierDefinitionState,\n    resolvedName: string | null = null,\n    isOptional?: true\n  ): number | null {\n    let handle = this.modifierDefinitionCache.get(definitionState);\n\n    if (handle === undefined) {\n      let manager = getInternalModifierManager(definitionState, isOptional);\n\n      if (manager === null) {\n        this.modifierDefinitionCache.set(definitionState, null);\n        return null;\n      }\n\n      let definition = {\n        resolvedName,\n        manager,\n        state: definitionState,\n      };\n\n      handle = this.value(definition);\n\n      this.modifierDefinitionCache.set(definitionState, handle);\n      this.modifierDefinitionCount++;\n    }\n\n    return handle;\n  }\n\n  component(definitionState: ComponentDefinitionState, owner: object): ComponentDefinition;\n  component(\n    definitionState: ComponentDefinitionState,\n    owner: object,\n    isOptional?: true,\n    debugName?: string\n  ): ComponentDefinition | null {\n    let definition = this.componentDefinitionCache.get(definitionState);\n\n    if (definition === undefined) {\n      let manager = getInternalComponentManager(definitionState, isOptional);\n\n      if (manager === null) {\n        this.componentDefinitionCache.set(definitionState, null);\n        return null;\n      }\n\n      localAssert(manager, 'BUG: expected manager');\n\n      let capabilities = capabilityFlagsFrom(manager.getCapabilities(definitionState));\n\n      let templateFactory = getComponentTemplate(definitionState);\n\n      let compilable = null;\n      let template;\n\n      if (\n        !managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout)\n      ) {\n        template = templateFactory?.(owner) ?? this.defaultTemplate;\n      } else {\n        template = templateFactory?.(owner);\n      }\n\n      if (template !== undefined) {\n        template = unwrapTemplate(template);\n\n        compilable = managerHasCapability(\n          manager,\n          capabilities,\n          InternalComponentCapabilities.wrapped\n        )\n          ? template.asWrappedLayout()\n          : template.asLayout();\n      }\n\n      definition = {\n        resolvedName: null,\n        handle: -1, // replaced momentarily\n        manager,\n        capabilities,\n        state: definitionState,\n        compilable,\n      };\n\n      definition.handle = this.value(definition);\n\n      if (debugName) {\n        definition.debugName = debugName;\n      }\n\n      this.componentDefinitionCache.set(definitionState, definition);\n      this.componentDefinitionCount++;\n    }\n\n    return definition;\n  }\n\n  resolvedComponent(\n    resolvedDefinition: ResolvedComponentDefinition,\n    resolvedName: string\n  ): ComponentDefinition {\n    let definition = this.componentDefinitionCache.get(resolvedDefinition);\n\n    if (definition === undefined) {\n      let { manager, state, template } = resolvedDefinition;\n      let capabilities = capabilityFlagsFrom(manager.getCapabilities(resolvedDefinition));\n\n      let compilable = null;\n\n      if (\n        !managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout)\n      ) {\n        template = template ?? this.defaultTemplate;\n      }\n\n      if (template !== null) {\n        template = unwrapTemplate(template);\n\n        compilable = managerHasCapability(\n          manager,\n          capabilities,\n          InternalComponentCapabilities.wrapped\n        )\n          ? template.asWrappedLayout()\n          : template.asLayout();\n      }\n\n      definition = {\n        resolvedName,\n        handle: -1, // replaced momentarily\n        manager,\n        capabilities,\n        state,\n        compilable,\n      };\n\n      definition.handle = this.value(definition);\n      this.componentDefinitionCache.set(resolvedDefinition, definition);\n      this.componentDefinitionCount++;\n    }\n\n    return expect(definition, 'BUG: resolved component definitions cannot be null');\n  }\n\n  getValue<T>(index: number) {\n    localAssert(index >= 0, `cannot get value for handle: ${index}`);\n\n    return this.values[index] as T;\n  }\n\n  getArray<T>(index: number): T[] {\n    let reifiedArrs = this.reifiedArrs;\n    let reified = reifiedArrs[index] as Optional<T[]>;\n\n    if (reified === undefined) {\n      let names: number[] = this.getValue(index);\n      reified = new Array(names.length);\n\n      for (const [i, name] of enumerate(names)) {\n        reified[i] = this.getValue(name);\n      }\n\n      reifiedArrs[index] = reified;\n    }\n\n    return reified;\n  }\n}\n","import { localAssert } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\n/*\n  Encoding notes\n\n  We use 30 bit integers for encoding, so that we don't ever encode a non-SMI\n  integer to push on the stack.\n\n  Handles are >= 0\n  Immediates are < 0\n\n  True, False, Undefined and Null are pushed as handles into the symbol table,\n  with well known handles (0, 1, 2, 3)\n\n  The negative space is divided into positives and negatives. Positives are\n  higher numbers (-1, -2, -3, etc), negatives are lower.\n\n  We only encode immediates for two reasons:\n\n  1. To transfer over the wire, so they're smaller in general\n  2. When pushing values onto the stack from the low level/inner VM, which may\n     be converted into WASM one day.\n\n  This allows the low-level VM to always use SMIs, and to minimize using JS\n  values via handles for things like the stack pointer and frame pointer.\n  Externally, most code pushes values as JS values, except when being pulled\n  from the append byte code where it was already encoded.\n\n  Logically, this is because the low level VM doesn't really care about these\n  higher level values. For instance, the result of a userland helper may be a\n  number, or a boolean, or undefined/null, but it's extra work to figure that\n  out and push it correctly, vs. just pushing the value as a JS value with a\n  handle.\n\n  Note: The details could change here in the future, this is just the current\n  strategy.\n*/\n\nexport const MAX_SMI = 2 ** 30 - 1;\nexport const MIN_SMI = ~MAX_SMI;\nexport const SIGN_BIT = ~(2 ** 29);\nexport const MAX_INT = ~SIGN_BIT - 1;\nexport const MIN_INT = ~MAX_INT;\n\nexport const FALSE_HANDLE = 0;\nexport const TRUE_HANDLE = 1;\nexport const NULL_HANDLE = 2;\nexport const UNDEFINED_HANDLE = 3;\n\nexport const ENCODED_FALSE_HANDLE = FALSE_HANDLE;\nexport const ENCODED_TRUE_HANDLE = TRUE_HANDLE;\nexport const ENCODED_NULL_HANDLE = NULL_HANDLE;\nexport const ENCODED_UNDEFINED_HANDLE = UNDEFINED_HANDLE;\n\nexport function isHandle(value: number) {\n  return value >= 0;\n}\n\nexport function isNonPrimitiveHandle(value: number) {\n  return value > ENCODED_UNDEFINED_HANDLE;\n}\n\nexport function constants(...values: unknown[]): unknown[] {\n  return [false, true, null, undefined, ...values];\n}\n\nexport function isSmallInt(value: number) {\n  return value % 1 === 0 && value <= MAX_INT && value >= MIN_INT;\n}\n\nexport function encodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= MIN_INT && num < 0, `Could not encode negative: ${num}`);\n  }\n\n  return num & SIGN_BIT;\n}\n\nexport function decodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(\n      num % 1 === 0 && num < ~MAX_INT && num >= MIN_SMI,\n      `Could not decode negative: ${num}`\n    );\n  }\n\n  return num | ~SIGN_BIT;\n}\n\nexport function encodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= 0 && num <= MAX_INT, `Could not encode positive: ${num}`);\n  }\n\n  return ~num;\n}\n\nexport function decodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num <= 0 && num >= ~MAX_INT, `Could not decode positive: ${num}`);\n  }\n\n  return ~num;\n}\n\nexport function encodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= 0 && num <= MAX_SMI, `Could not encode handle: ${num}`);\n  }\n\n  return num;\n}\n\nexport function decodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num <= MAX_SMI && num >= 0, `Could not decode handle: ${num}`);\n  }\n\n  return num;\n}\n\nexport function encodeImmediate(num: number) {\n  num |= 0;\n  return num < 0 ? encodeNegative(num) : encodePositive(num);\n}\n\nexport function decodeImmediate(num: number) {\n  num |= 0;\n  return num > SIGN_BIT ? decodePositive(num) : decodeNegative(num);\n}\n\n// Warm\n[1, 2, 3].forEach((x) => decodeHandle(encodeHandle(x)));\n[1, -1].forEach((x) => decodeImmediate(encodeImmediate(x)));\n","import type { ProgramHeap, RuntimeOp, SomeVmOp } from '@glimmer/interfaces';\nimport { ARG_SHIFT, MACHINE_MASK, OPERAND_LEN_MASK, TYPE_MASK } from '@glimmer/vm';\n\nexport class RuntimeOpImpl implements RuntimeOp {\n  public offset = 0;\n  constructor(readonly heap: ProgramHeap) {}\n\n  get size() {\n    let rawType = this.heap.getbyaddr(this.offset);\n    return ((rawType & OPERAND_LEN_MASK) >> ARG_SHIFT) + 1;\n  }\n\n  get isMachine(): 0 | 1 {\n    let rawType = this.heap.getbyaddr(this.offset);\n    return rawType & MACHINE_MASK ? 1 : 0;\n  }\n\n  get type(): SomeVmOp {\n    return (this.heap.getbyaddr(this.offset) & TYPE_MASK) as SomeVmOp;\n  }\n\n  get op1() {\n    return this.heap.getbyaddr(this.offset + 1);\n  }\n\n  get op2() {\n    return this.heap.getbyaddr(this.offset + 2);\n  }\n\n  get op3() {\n    return this.heap.getbyaddr(this.offset + 3);\n  }\n}\n","import type { Program, ProgramConstants, ProgramHeap, StdLibOperand } from '@glimmer/interfaces';\nimport { unwrap } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { MACHINE_MASK } from '@glimmer/vm';\n\nimport { RuntimeOpImpl } from './opcode';\n\nconst ALLOCATED = 0;\nconst FREED = 1;\nconst PURGED = 2;\nconst POINTER = 3;\n\ntype TableSlotState = typeof ALLOCATED | typeof FREED | typeof PURGED | typeof POINTER;\n\nexport type Placeholder = [number, () => number];\nexport type StdlibPlaceholder = [number, StdLibOperand];\n\nconst PAGE_SIZE = 0x100000;\n\n/**\n * The Program Heap is responsible for dynamically allocating\n * memory in which we read/write the VM's instructions\n * from/to. When we malloc we pass out a VMHandle, which\n * is used as an indirect way of accessing the memory during\n * execution of the VM. Internally we track the different\n * regions of the memory in an int array known as the table.\n *\n * The table 32-bit aligned and has the following layout:\n *\n * | ... | hp (u32) |       info (u32)   | size (u32) |\n * | ... |  Handle  | Scope Size | State | Size       |\n * | ... | 32bits   | 30bits     | 2bits | 32bit      |\n *\n * With this information we effectively have the ability to\n * control when we want to free memory. That being said you\n * can not free during execution as raw address are only\n * valid during the execution. This means you cannot close\n * over them as you will have a bad memory access exception.\n */\nexport class ProgramHeapImpl implements ProgramHeap {\n  offset = 0;\n\n  private heap: Int32Array;\n  private handleTable: number[];\n  private handleState: TableSlotState[];\n  private handle = 0;\n\n  constructor() {\n    this.heap = new Int32Array(PAGE_SIZE);\n    this.handleTable = [];\n    this.handleState = [];\n  }\n  entries(): number {\n    return this.offset;\n  }\n\n  pushRaw(value: number): void {\n    this.sizeCheck();\n    this.heap[this.offset++] = value;\n  }\n\n  pushOp(item: number): void {\n    this.pushRaw(item);\n  }\n\n  pushMachine(item: number): void {\n    this.pushRaw(item | MACHINE_MASK);\n  }\n\n  private sizeCheck() {\n    let { heap } = this;\n\n    if (this.offset === this.heap.length) {\n      let newHeap = new Int32Array(heap.length + PAGE_SIZE);\n      newHeap.set(heap, 0);\n      this.heap = newHeap;\n    }\n  }\n\n  getbyaddr(address: number): number {\n    return unwrap(this.heap[address]);\n  }\n\n  setbyaddr(address: number, value: number) {\n    this.heap[address] = value;\n  }\n\n  malloc(): number {\n    // push offset, info, size\n    this.handleTable.push(this.offset);\n    return this.handleTable.length - 1;\n  }\n\n  finishMalloc(handle: number): void {\n    // @TODO: At the moment, garbage collection isn't actually used, so this is\n    // wrapped to prevent us from allocating extra space in prod. In the future,\n    // if we start using the compact API, we should change this.\n    if (LOCAL_DEBUG) {\n      this.handleState[handle] = ALLOCATED;\n      this.handleTable[handle + 1] = this.offset;\n    }\n  }\n\n  size(): number {\n    return this.offset;\n  }\n\n  // It is illegal to close over this address, as compaction\n  // may move it. However, it is legal to use this address\n  // multiple times between compactions.\n  getaddr(handle: number): number {\n    return unwrap(this.handleTable[handle]);\n  }\n\n  sizeof(handle: number): number {\n    return sizeof(this.handleTable, handle);\n  }\n\n  free(handle: number): void {\n    this.handleState[handle] = FREED;\n  }\n\n  /**\n   * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift\n   * reachable memory to the bottom of the heap and freeable\n   * memory to the top of the heap. When we have shifted all\n   * the reachable memory to the top of the heap, we move the\n   * offset to the next free position.\n   */\n  compact(): void {\n    let compactedSize = 0;\n    let { handleTable, handleState, heap } = this;\n\n    for (let i = 0; i < length; i++) {\n      let offset = unwrap(handleTable[i]);\n      let size = unwrap(handleTable[i + 1]) - unwrap(offset);\n      let state = handleState[i];\n\n      if (state === PURGED) {\n        continue;\n      } else if (state === FREED) {\n        // transition to \"already freed\" aka \"purged\"\n        // a good improvement would be to reuse\n        // these slots\n        handleState[i] = PURGED;\n        compactedSize += size;\n      } else if (state === ALLOCATED) {\n        for (let j = offset; j <= i + size; j++) {\n          heap[j - compactedSize] = unwrap(heap[j]);\n        }\n\n        handleTable[i] = offset - compactedSize;\n      } else if (state === POINTER) {\n        handleTable[i] = offset - compactedSize;\n      }\n    }\n\n    this.offset = this.offset - compactedSize;\n  }\n}\n\nexport class ProgramImpl implements Program {\n  [key: number]: never;\n\n  private _opcode: RuntimeOpImpl;\n\n  constructor(\n    public constants: ProgramConstants,\n    public heap: ProgramHeap\n  ) {\n    this._opcode = new RuntimeOpImpl(this.heap);\n  }\n\n  opcode(offset: number): RuntimeOpImpl {\n    this._opcode.offset = offset;\n    return this._opcode;\n  }\n}\n\nfunction sizeof(table: number[], handle: number) {\n  if (LOCAL_DEBUG) {\n    return unwrap(table[handle + 1]) - unwrap(table[handle]);\n  } else {\n    return -1;\n  }\n}\n","import type { RuntimeArtifacts } from '@glimmer/interfaces';\n\nimport { ConstantsImpl } from './constants';\nimport { ProgramHeapImpl } from './program';\n\nexport function artifacts(): RuntimeArtifacts {\n  return {\n    constants: new ConstantsImpl(),\n    heap: new ProgramHeapImpl(),\n  };\n}\n"],"names":["unwrapTemplate","template","result","Error","problem","span","start","end","DEFAULT_TEMPLATE_BLOCK","op","Yield","DEFAULT_TEMPLATE","id","moduleName","block","JSON","stringify","scope","isStrictMode","WELL_KNOWN_EMPTY_ARRAY","Object","freeze","STARTER_CONSTANTS","undefined","WELL_KNOWN_EMPTY_ARRAY_POSITION","indexOf","ConstantsImpl","value","indexMap","this","index","get","values","push","set","array","length","handles","Array","i","toPool","hasHandle","handle","helper","definitionState","_resolvedName","isOptional","helperDefinitionCache","managerOrHelper","getInternalHelperManager","getHelper","helperDefinitionCount","modifier","resolvedName","modifierDefinitionCache","manager","getInternalModifierManager","definition","state","modifierDefinitionCount","component","owner","debugName","componentDefinitionCache","getInternalComponentManager","capabilities","capabilityFlagsFrom","getCapabilities","templateFactory","getComponentTemplate","compilable","managerHasCapability","InternalComponentCapabilities","dynamicLayout","defaultTemplate","wrapped","asWrappedLayout","asLayout","componentDefinitionCount","resolvedComponent","resolvedDefinition","getValue","getArray","reifiedArrs","reified","names","name","enumerate","slice","Map","map","WeakMap","RuntimeOpImpl","constructor","heap","offset","size","getbyaddr","OPERAND_LEN_MASK","ARG_SHIFT","isMachine","MACHINE_MASK","type","TYPE_MASK","op1","op2","op3","PAGE_SIZE","ProgramHeapImpl","Int32Array","handleTable","handleState","entries","pushRaw","sizeCheck","pushOp","item","pushMachine","newHeap","address","setbyaddr","malloc","finishMalloc","getaddr","sizeof","free","compact","compactedSize","j","ProgramImpl","constants","_opcode","opcode","artifacts"],"mappings":"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"}