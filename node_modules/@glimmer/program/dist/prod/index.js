import{getInternalHelperManager as e,getInternalModifierManager as t,getInternalComponentManager as i,capabilityFlagsFrom as n,getComponentTemplate as s,managerHasCapability as a}from"@glimmer/manager";import{templateFactory as h}from"@glimmer/opcode-compiler";import{enumerate as r}from"@glimmer/util";import{InternalComponentCapabilities as l,OPERAND_LEN_MASK as o,ARG_SHIFT as f,MACHINE_MASK as u,TYPE_MASK as p}from"@glimmer/vm";import{SexpOpcodes as d}from"@glimmer/wire-format";function c(e){if("error"===e.result)throw new Error(`Compile Error: ${e.problem} @ ${e.span.start}..${e.span.end}`);return e}const m=[[[d.Yield,1,null]],["&default"],[]],g={id:"1b32f5c2-7623-43d6-a0ad-9672898920a1",moduleName:"__default__.hbs",block:JSON.stringify(m),scope:null,isStrictMode:!0},C=Object.freeze([]),b=[!1,!0,null,void 0,C],v=b.indexOf(C);class y{value(e){let t=this.indexMap,i=t.get(e);return void 0===i&&(i=this.values.push(e)-1,t.set(e,i)),i}array(e){if(0===e.length)return v;let t=new Array(e.length);for(let i=0;i<e.length;i++)t[i]=this.value(e[i]);return this.value(t)}toPool(){return this.values}hasHandle(e){return this.values.length>e}helper(t,i=null,n){let s=this.helperDefinitionCache.get(t);if(void 0===s){let i=e(t,n);if(null===i)return this.helperDefinitionCache.set(t,null),null;let a="function"==typeof i?i:i.getHelper(t);s=this.value(a),this.helperDefinitionCache.set(t,s),this.helperDefinitionCount++}return s}modifier(e,i=null,n){let s=this.modifierDefinitionCache.get(e);if(void 0===s){let a=t(e,n);if(null===a)return this.modifierDefinitionCache.set(e,null),null;let h={resolvedName:i,manager:a,state:e};s=this.value(h),this.modifierDefinitionCache.set(e,s),this.modifierDefinitionCount++}return s}component(e,t,h,r){let o=this.componentDefinitionCache.get(e);if(void 0===o){let f=i(e,h);if(null===f)return this.componentDefinitionCache.set(e,null),null;let u,p=n(f.getCapabilities(e)),d=s(e),m=null;u=a(f,p,l.dynamicLayout)?d?.(t):d?.(t)??this.defaultTemplate,void 0!==u&&(u=c(u),m=a(f,p,l.wrapped)?u.asWrappedLayout():u.asLayout()),o={resolvedName:null,handle:-1,manager:f,capabilities:p,state:e,compilable:m},o.handle=this.value(o),r&&(o.debugName=r),this.componentDefinitionCache.set(e,o),this.componentDefinitionCount++}return o}resolvedComponent(e,t){let i=this.componentDefinitionCache.get(e);if(void 0===i){let{manager:s,state:h,template:r}=e,o=n(s.getCapabilities(e)),f=null;a(s,o,l.dynamicLayout)||(r=r??this.defaultTemplate),null!==r&&(r=c(r),f=a(s,o,l.wrapped)?r.asWrappedLayout():r.asLayout()),i={resolvedName:t,handle:-1,manager:s,capabilities:o,state:h,compilable:f},i.handle=this.value(i),this.componentDefinitionCache.set(e,i),this.componentDefinitionCount++}return i}getValue(e){return this.values[e]}getArray(e){let t=this.reifiedArrs,i=t[e];if(void 0===i){let n=this.getValue(e);i=new Array(n.length);for(const[e,t]of r(n))i[e]=this.getValue(t);t[e]=i}return i}constructor(){this.reifiedArrs={[v]:C},this.defaultTemplate=h(g)(),this.helperDefinitionCount=0,this.modifierDefinitionCount=0,this.componentDefinitionCount=0,this.values=b.slice(),this.indexMap=new Map(this.values.map(((e,t)=>[e,t]))),this.helperDefinitionCache=new WeakMap,this.modifierDefinitionCache=new WeakMap,this.componentDefinitionCache=new WeakMap}}class D{constructor(e){this.heap=e,this.offset=0}get size(){return 1+((this.heap.getbyaddr(this.offset)&o)>>f)}get isMachine(){return this.heap.getbyaddr(this.offset)&u?1:0}get type(){return this.heap.getbyaddr(this.offset)&p}get op1(){return this.heap.getbyaddr(this.offset+1)}get op2(){return this.heap.getbyaddr(this.offset+2)}get op3(){return this.heap.getbyaddr(this.offset+3)}}const w=1048576;class M{constructor(){this.offset=0,this.handle=0,this.heap=new Int32Array(w),this.handleTable=[],this.handleState=[]}entries(){return this.offset}pushRaw(e){this.sizeCheck(),this.heap[this.offset++]=e}pushOp(e){this.pushRaw(e)}pushMachine(e){this.pushRaw(e|u)}sizeCheck(){let{heap:e}=this;if(this.offset===this.heap.length){let t=new Int32Array(e.length+w);t.set(e,0),this.heap=t}}getbyaddr(e){return this.heap[e]}setbyaddr(e,t){this.heap[e]=t}malloc(){return this.handleTable.push(this.offset),this.handleTable.length-1}finishMalloc(e){}size(){return this.offset}getaddr(e){return this.handleTable[e]}sizeof(e){return this.handleTable,-1}free(e){this.handleState[e]=1}compact(){let e=0,{handleTable:t,handleState:i,heap:n}=this;for(let s=0;s<length;s++){let a=t[s],h=t[s+1]-a,r=i[s];if(2!==r)if(1===r)i[s]=2,e+=h;else if(0===r){for(let t=a;t<=s+h;t++)n[t-e]=n[t];t[s]=a-e}else 3===r&&(t[s]=a-e)}this.offset=this.offset-e}}class T{constructor(e,t){this.constants=e,this.heap=t,this._opcode=new D(this.heap)}opcode(e){return this._opcode.offset=e,this._opcode}}function A(){return{constants:new y,heap:new M}}export{y as ConstantsImpl,M as ProgramHeapImpl,T as ProgramImpl,D as RuntimeOpImpl,A as artifacts};
//# sourceMappingURL=index.js.map
