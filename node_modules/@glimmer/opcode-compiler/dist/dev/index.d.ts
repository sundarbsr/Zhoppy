import { LayoutWithContext, CompilableProgram, Statement, BlockMetadata, EvaluationContext, HandleResult, CompilationContext, InternalComponentCapabilities, Nullable, CompileTimeComponent, BuilderOp, HighLevelOp, WireFormat, ProgramConstants, ProgramHeap, ClassicResolver, STDLib, CreateRuntimeOp, Environment, Program, RuntimeArtifacts, RuntimeOptions, SerializedTemplateWithLazyBlock, TemplateFactory, TemplateOk, Owner, NamedBlocks, SerializedInlineBlock, ProgramSymbolTable } from '@glimmer/interfaces';

declare function compilable(layout: LayoutWithContext, moduleName: string): CompilableProgram;
declare function compileStatements(statements: Statement[], meta: BlockMetadata, syntaxContext: EvaluationContext): HandleResult;

declare let debugCompiler: (context: CompilationContext, handle: HandleResult) => void;

declare function templateCompilationContext(evaluation: EvaluationContext, meta: BlockMetadata): CompilationContext;

declare const DEFAULT_CAPABILITIES: InternalComponentCapabilities;
declare const MINIMAL_CAPABILITIES: InternalComponentCapabilities;
interface ResolverDelegate<R = unknown> {
    lookupHelper?(name: string, referrer: R): Nullable<number> | void;
    lookupModifier?(name: string, referrer: R): Nullable<number> | void;
    lookupComponent?(name: string, referrer: R): Nullable<CompileTimeComponent> | void;
    resolve?(handle: number): R;
}

declare const STATEMENT: unique symbol;
type HighLevelStatementOp = [{
    [STATEMENT]: undefined;
}];
type PushStatementOp = (...op: BuilderOp | HighLevelOp | HighLevelStatementOp) => void;

/**
 * Invoke a block that is known statically at compile time.
 *
 * @param block a Compilable block
 */
declare function InvokeStaticBlock(op: PushStatementOp, block: WireFormat.SerializedInlineBlock): void;
/**
 * Invoke a static block, preserving some number of stack entries for use in
 * updating.
 *
 * @param block A compilable block
 * @param callerCount A number of stack entries to preserve
 */
declare function InvokeStaticBlockWithStack(op: PushStatementOp, block: WireFormat.SerializedInlineBlock, callerCount: number): void;

declare function meta(layout: LayoutWithContext): BlockMetadata;

declare class StdLib {
    main: number;
    private trustingGuardedAppend;
    private cautiousGuardedAppend;
    private trustingNonDynamicAppend;
    private cautiousNonDynamicAppend;
    constructor(main: number, trustingGuardedAppend: number, cautiousGuardedAppend: number, trustingNonDynamicAppend: number, cautiousNonDynamicAppend: number);
    get 'trusting-append'(): number;
    get 'cautious-append'(): number;
    get 'trusting-non-dynamic-append'(): number;
    get 'cautious-non-dynamic-append'(): number;
    getAppend(trusting: boolean): number;
}

declare function compileStd(context: EvaluationContext): StdLib;

declare class EvaluationContextImpl implements EvaluationContext {
    readonly constants: ProgramConstants;
    readonly heap: ProgramHeap;
    readonly resolver: Nullable<ClassicResolver>;
    readonly stdlib: STDLib;
    readonly createOp: CreateRuntimeOp;
    readonly env: Environment;
    readonly program: Program;
    constructor({ constants, heap }: RuntimeArtifacts, createOp: CreateRuntimeOp, runtime: RuntimeOptions);
}

declare let templateCacheCounters: {
    cacheHit: number;
    cacheMiss: number;
};
interface TemplateFactoryWithIdAndMeta extends TemplateFactory {
    __id?: string;
    __meta?: {
        moduleName: string;
    };
}
interface TemplateWithIdAndReferrer extends TemplateOk {
    id: string;
    referrer: {
        moduleName: string;
        owner: Owner | null;
    };
}
/**
 * Wraps a template js in a template module to change it into a factory
 * that handles lazy parsing the template and to create per env singletons
 * of the template.
 */
declare function templateFactory({ id: templateId, moduleName, block, scope, isStrictMode, }: SerializedTemplateWithLazyBlock): TemplateFactory;

interface NamedBlocksDict {
    [key: string]: Nullable<WireFormat.SerializedInlineBlock>;
}
declare class NamedBlocksImpl implements NamedBlocks {
    private blocks;
    names: string[];
    constructor(blocks: Nullable<NamedBlocksDict>);
    get(name: string): Nullable<SerializedInlineBlock>;
    has(name: string): boolean;
    with(name: string, block: Nullable<SerializedInlineBlock>): NamedBlocks;
    get hasAny(): boolean;
}
declare const EMPTY_BLOCKS: NamedBlocksImpl;

declare class WrappedBuilder implements CompilableProgram {
    private readonly layout;
    moduleName: string;
    symbolTable: ProgramSymbolTable;
    private compiled;
    private attrsBlockNumber;
    readonly meta: BlockMetadata;
    constructor(layout: LayoutWithContext, moduleName: string);
    compile(syntax: EvaluationContext): HandleResult;
}

export { DEFAULT_CAPABILITIES, EMPTY_BLOCKS, EvaluationContextImpl, MINIMAL_CAPABILITIES, type ResolverDelegate, StdLib, type TemplateFactoryWithIdAndMeta, type TemplateWithIdAndReferrer, WrappedBuilder, compilable, compileStatements, compileStd, debugCompiler, InvokeStaticBlock as invokeStaticBlock, InvokeStaticBlockWithStack as invokeStaticBlockWithStack, meta, templateCacheCounters, templateCompilationContext, templateFactory };
