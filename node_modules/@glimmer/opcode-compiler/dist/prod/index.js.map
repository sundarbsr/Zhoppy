{"version":3,"file":"index.js","sources":["../../../constants/lib/immediate.ts","../../../constants/lib/syscall-ops.ts","../../lib/compiler.ts","../../lib/opcode-builder/helpers/resolution.ts","../../lib/opcode-builder/opcodes.ts","../../lib/opcode-builder/operands.ts","../../lib/opcode-builder/encoder.ts","../../../constants/lib/vm-ops.ts","../../../debug-util/lib/present.ts","../../lib/compilable-template.ts","../../lib/opcode-builder/context.ts","../../lib/syntax/compilers.ts","../../lib/syntax/expressions.ts","../../lib/opcode-builder/helpers/expr.ts","../../lib/opcode-builder/helpers/vm.ts","../../lib/opcode-builder/helpers/blocks.ts","../../lib/opcode-builder/helpers/shared.ts","../../lib/utils.ts","../../lib/opcode-builder/helpers/conditional.ts","../../lib/opcode-builder/helpers/components.ts","../../lib/syntax/statements.ts","../../lib/opcode-builder/delegate.ts","../../lib/opcode-builder/stdlib.ts","../../lib/opcode-builder/helpers/stdlib.ts","../../lib/program-context.ts","../../lib/wrapped-component.ts","../../lib/template.ts"],"sourcesContent":["import { localAssert } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\n/*\n  Encoding notes\n\n  We use 30 bit integers for encoding, so that we don't ever encode a non-SMI\n  integer to push on the stack.\n\n  Handles are >= 0\n  Immediates are < 0\n\n  True, False, Undefined and Null are pushed as handles into the symbol table,\n  with well known handles (0, 1, 2, 3)\n\n  The negative space is divided into positives and negatives. Positives are\n  higher numbers (-1, -2, -3, etc), negatives are lower.\n\n  We only encode immediates for two reasons:\n\n  1. To transfer over the wire, so they're smaller in general\n  2. When pushing values onto the stack from the low level/inner VM, which may\n     be converted into WASM one day.\n\n  This allows the low-level VM to always use SMIs, and to minimize using JS\n  values via handles for things like the stack pointer and frame pointer.\n  Externally, most code pushes values as JS values, except when being pulled\n  from the append byte code where it was already encoded.\n\n  Logically, this is because the low level VM doesn't really care about these\n  higher level values. For instance, the result of a userland helper may be a\n  number, or a boolean, or undefined/null, but it's extra work to figure that\n  out and push it correctly, vs. just pushing the value as a JS value with a\n  handle.\n\n  Note: The details could change here in the future, this is just the current\n  strategy.\n*/\n\nexport const MAX_SMI = 2 ** 30 - 1;\nexport const MIN_SMI = ~MAX_SMI;\nexport const SIGN_BIT = ~(2 ** 29);\nexport const MAX_INT = ~SIGN_BIT - 1;\nexport const MIN_INT = ~MAX_INT;\n\nexport const FALSE_HANDLE = 0;\nexport const TRUE_HANDLE = 1;\nexport const NULL_HANDLE = 2;\nexport const UNDEFINED_HANDLE = 3;\n\nexport const ENCODED_FALSE_HANDLE = FALSE_HANDLE;\nexport const ENCODED_TRUE_HANDLE = TRUE_HANDLE;\nexport const ENCODED_NULL_HANDLE = NULL_HANDLE;\nexport const ENCODED_UNDEFINED_HANDLE = UNDEFINED_HANDLE;\n\nexport function isHandle(value: number) {\n  return value >= 0;\n}\n\nexport function isNonPrimitiveHandle(value: number) {\n  return value > ENCODED_UNDEFINED_HANDLE;\n}\n\nexport function constants(...values: unknown[]): unknown[] {\n  return [false, true, null, undefined, ...values];\n}\n\nexport function isSmallInt(value: number) {\n  return value % 1 === 0 && value <= MAX_INT && value >= MIN_INT;\n}\n\nexport function encodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= MIN_INT && num < 0, `Could not encode negative: ${num}`);\n  }\n\n  return num & SIGN_BIT;\n}\n\nexport function decodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(\n      num % 1 === 0 && num < ~MAX_INT && num >= MIN_SMI,\n      `Could not decode negative: ${num}`\n    );\n  }\n\n  return num | ~SIGN_BIT;\n}\n\nexport function encodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= 0 && num <= MAX_INT, `Could not encode positive: ${num}`);\n  }\n\n  return ~num;\n}\n\nexport function decodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num <= 0 && num >= ~MAX_INT, `Could not decode positive: ${num}`);\n  }\n\n  return ~num;\n}\n\nexport function encodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= 0 && num <= MAX_SMI, `Could not encode handle: ${num}`);\n  }\n\n  return num;\n}\n\nexport function decodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num <= MAX_SMI && num >= 0, `Could not decode handle: ${num}`);\n  }\n\n  return num;\n}\n\nexport function encodeImmediate(num: number) {\n  num |= 0;\n  return num < 0 ? encodeNegative(num) : encodePositive(num);\n}\n\nexport function decodeImmediate(num: number) {\n  num |= 0;\n  return num > SIGN_BIT ? decodePositive(num) : decodeNegative(num);\n}\n\n// Warm\n[1, 2, 3].forEach((x) => decodeHandle(encodeHandle(x)));\n[1, -1].forEach((x) => decodeImmediate(encodeImmediate(x)));\n","import type {\n  VmAppendDocumentFragment,\n  VmAppendHTML,\n  VmAppendNode,\n  VmAppendSafeHTML,\n  VmAppendText,\n  VmAssertSame,\n  VmBeginComponentTransaction,\n  VmBindDynamicScope,\n  VmCaptureArgs,\n  VmChildScope,\n  VmCloseElement,\n  VmComment,\n  VmCommitComponentTransaction,\n  VmCompileBlock,\n  VmComponentAttr,\n  VmConcat,\n  VmConstant,\n  VmConstantReference,\n  VmContentType,\n  VmCreateComponent,\n  VmCurry,\n  VmDebugger,\n  VmDidCreateElement,\n  VmDidRenderLayout,\n  VmDup,\n  VmDynamicAttr,\n  VmDynamicContentType,\n  VmDynamicHelper,\n  VmDynamicModifier,\n  VmEnter,\n  VmEnterList,\n  VmExit,\n  VmExitList,\n  VmFetch,\n  VmFlushElement,\n  VmGetBlock,\n  VmGetComponentLayout,\n  VmGetComponentSelf,\n  VmGetComponentTagName,\n  VmGetDynamicVar,\n  VmGetProperty,\n  VmGetVariable,\n  VmHasBlock,\n  VmHasBlockParams,\n  VmHelper,\n  VmIfInline,\n  VmInvokeComponentLayout,\n  VmInvokeYield,\n  VmIterate,\n  VmJumpEq,\n  VmJumpIf,\n  VmJumpUnless,\n  VmLoad,\n  VmLog,\n  VmMain,\n  VmModifier,\n  VmNot,\n  VmOp,\n  VmOpenDynamicElement,\n  VmOpenElement,\n  VmPop,\n  VmPopArgs,\n  VmPopDynamicScope,\n  VmPopRemoteElement,\n  VmPopScope,\n  VmPopulateLayout,\n  VmPrepareArgs,\n  VmPrimitive,\n  VmPrimitiveReference,\n  VmPushArgs,\n  VmPushBlockScope,\n  VmPushComponentDefinition,\n  VmPushDynamicComponentInstance,\n  VmPushDynamicScope,\n  VmPushEmptyArgs,\n  VmPushRemoteElement,\n  VmPushSymbolTable,\n  VmPutComponentOperations,\n  VmRegisterComponentDestructor,\n  VmReifyU32,\n  VmResolveCurriedComponent,\n  VmResolveDynamicComponent,\n  VmRootScope,\n  VmSetBlock,\n  VmSetBlocks,\n  VmSetNamedVariables,\n  VmSetVariable,\n  VmSize,\n  VmSpreadBlock,\n  VmStaticAttr,\n  VmStaticComponentAttr,\n  VmText,\n  VmToBoolean,\n  VmVirtualRootScope,\n} from '@glimmer/interfaces';\n\nexport const VM_HELPER_OP = 16 satisfies VmHelper;\nexport const VM_SET_NAMED_VARIABLES_OP = 17 satisfies VmSetNamedVariables;\nexport const VM_SET_BLOCKS_OP = 18 satisfies VmSetBlocks;\nexport const VM_SET_VARIABLE_OP = 19 satisfies VmSetVariable;\nexport const VM_SET_BLOCK_OP = 20 satisfies VmSetBlock;\nexport const VM_GET_VARIABLE_OP = 21 satisfies VmGetVariable;\nexport const VM_GET_PROPERTY_OP = 22 satisfies VmGetProperty;\nexport const VM_GET_BLOCK_OP = 23 satisfies VmGetBlock;\nexport const VM_SPREAD_BLOCK_OP = 24 satisfies VmSpreadBlock;\nexport const VM_HAS_BLOCK_OP = 25 satisfies VmHasBlock;\nexport const VM_HAS_BLOCK_PARAMS_OP = 26 satisfies VmHasBlockParams;\nexport const VM_CONCAT_OP = 27 satisfies VmConcat;\nexport const VM_CONSTANT_OP = 28 satisfies VmConstant;\nexport const VM_CONSTANT_REFERENCE_OP = 29 satisfies VmConstantReference;\nexport const VM_PRIMITIVE_OP = 30 satisfies VmPrimitive;\nexport const VM_PRIMITIVE_REFERENCE_OP = 31 satisfies VmPrimitiveReference;\nexport const VM_REIFY_U32_OP = 32 satisfies VmReifyU32;\nexport const VM_DUP_OP = 33 satisfies VmDup;\nexport const VM_POP_OP = 34 satisfies VmPop;\nexport const VM_LOAD_OP = 35 satisfies VmLoad;\nexport const VM_FETCH_OP = 36 satisfies VmFetch;\nexport const VM_ROOT_SCOPE_OP = 37 satisfies VmRootScope;\nexport const VM_VIRTUAL_ROOT_SCOPE_OP = 38 satisfies VmVirtualRootScope;\nexport const VM_CHILD_SCOPE_OP = 39 satisfies VmChildScope;\nexport const VM_POP_SCOPE_OP = 40 satisfies VmPopScope;\nexport const VM_TEXT_OP = 41 satisfies VmText;\nexport const VM_COMMENT_OP = 42 satisfies VmComment;\nexport const VM_APPEND_HTML_OP = 43 satisfies VmAppendHTML;\nexport const VM_APPEND_SAFE_HTML_OP = 44 satisfies VmAppendSafeHTML;\nexport const VM_APPEND_DOCUMENT_FRAGMENT_OP = 45 satisfies VmAppendDocumentFragment;\nexport const VM_APPEND_NODE_OP = 46 satisfies VmAppendNode;\nexport const VM_APPEND_TEXT_OP = 47 satisfies VmAppendText;\nexport const VM_OPEN_ELEMENT_OP = 48 satisfies VmOpenElement;\nexport const VM_OPEN_DYNAMIC_ELEMENT_OP = 49 satisfies VmOpenDynamicElement;\nexport const VM_PUSH_REMOTE_ELEMENT_OP = 50 satisfies VmPushRemoteElement;\nexport const VM_STATIC_ATTR_OP = 51 satisfies VmStaticAttr;\nexport const VM_DYNAMIC_ATTR_OP = 52 satisfies VmDynamicAttr;\nexport const VM_COMPONENT_ATTR_OP = 53 satisfies VmComponentAttr;\nexport const VM_FLUSH_ELEMENT_OP = 54 satisfies VmFlushElement;\nexport const VM_CLOSE_ELEMENT_OP = 55 satisfies VmCloseElement;\nexport const VM_POP_REMOTE_ELEMENT_OP = 56 satisfies VmPopRemoteElement;\nexport const VM_MODIFIER_OP = 57 satisfies VmModifier;\nexport const VM_BIND_DYNAMIC_SCOPE_OP = 58 satisfies VmBindDynamicScope;\nexport const VM_PUSH_DYNAMIC_SCOPE_OP = 59 satisfies VmPushDynamicScope;\nexport const VM_POP_DYNAMIC_SCOPE_OP = 60 satisfies VmPopDynamicScope;\nexport const VM_COMPILE_BLOCK_OP = 61 satisfies VmCompileBlock;\nexport const VM_PUSH_BLOCK_SCOPE_OP = 62 satisfies VmPushBlockScope;\nexport const VM_PUSH_SYMBOL_TABLE_OP = 63 satisfies VmPushSymbolTable;\nexport const VM_INVOKE_YIELD_OP = 64 satisfies VmInvokeYield;\nexport const VM_JUMP_IF_OP = 65 satisfies VmJumpIf;\nexport const VM_JUMP_UNLESS_OP = 66 satisfies VmJumpUnless;\nexport const VM_JUMP_EQ_OP = 67 satisfies VmJumpEq;\nexport const VM_ASSERT_SAME_OP = 68 satisfies VmAssertSame;\nexport const VM_ENTER_OP = 69 satisfies VmEnter;\nexport const VM_EXIT_OP = 70 satisfies VmExit;\nexport const VM_TO_BOOLEAN_OP = 71 satisfies VmToBoolean;\nexport const VM_ENTER_LIST_OP = 72 satisfies VmEnterList;\nexport const VM_EXIT_LIST_OP = 73 satisfies VmExitList;\nexport const VM_ITERATE_OP = 74 satisfies VmIterate;\nexport const VM_MAIN_OP = 75 satisfies VmMain;\nexport const VM_CONTENT_TYPE_OP = 76 satisfies VmContentType;\nexport const VM_CURRY_OP = 77 satisfies VmCurry;\nexport const VM_PUSH_COMPONENT_DEFINITION_OP = 78 satisfies VmPushComponentDefinition;\nexport const VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP = 79 satisfies VmPushDynamicComponentInstance;\nexport const VM_RESOLVE_DYNAMIC_COMPONENT_OP = 80 satisfies VmResolveDynamicComponent;\nexport const VM_RESOLVE_CURRIED_COMPONENT_OP = 81 satisfies VmResolveCurriedComponent;\nexport const VM_PUSH_ARGS_OP = 82 satisfies VmPushArgs;\nexport const VM_PUSH_EMPTY_ARGS_OP = 83 satisfies VmPushEmptyArgs;\nexport const VM_POP_ARGS_OP = 84 satisfies VmPopArgs;\nexport const VM_PREPARE_ARGS_OP = 85 satisfies VmPrepareArgs;\nexport const VM_CAPTURE_ARGS_OP = 86 satisfies VmCaptureArgs;\nexport const VM_CREATE_COMPONENT_OP = 87 satisfies VmCreateComponent;\nexport const VM_REGISTER_COMPONENT_DESTRUCTOR_OP = 88 satisfies VmRegisterComponentDestructor;\nexport const VM_PUT_COMPONENT_OPERATIONS_OP = 89 satisfies VmPutComponentOperations;\nexport const VM_GET_COMPONENT_SELF_OP = 90 satisfies VmGetComponentSelf;\nexport const VM_GET_COMPONENT_TAG_NAME_OP = 91 satisfies VmGetComponentTagName;\nexport const VM_GET_COMPONENT_LAYOUT_OP = 92 satisfies VmGetComponentLayout;\nexport const VM_POPULATE_LAYOUT_OP = 95 satisfies VmPopulateLayout;\nexport const VM_INVOKE_COMPONENT_LAYOUT_OP = 96 satisfies VmInvokeComponentLayout;\nexport const VM_BEGIN_COMPONENT_TRANSACTION_OP = 97 satisfies VmBeginComponentTransaction;\nexport const VM_COMMIT_COMPONENT_TRANSACTION_OP = 98 satisfies VmCommitComponentTransaction;\nexport const VM_DID_CREATE_ELEMENT_OP = 99 satisfies VmDidCreateElement;\nexport const VM_DID_RENDER_LAYOUT_OP = 100 satisfies VmDidRenderLayout;\nexport const VM_DEBUGGER_OP = 103 satisfies VmDebugger;\nexport const VM_STATIC_COMPONENT_ATTR_OP = 105 satisfies VmStaticComponentAttr;\nexport const VM_DYNAMIC_CONTENT_TYPE_OP = 106 satisfies VmDynamicContentType;\nexport const VM_DYNAMIC_HELPER_OP = 107 satisfies VmDynamicHelper;\nexport const VM_DYNAMIC_MODIFIER_OP = 108 satisfies VmDynamicModifier;\nexport const VM_IF_INLINE_OP = 109 satisfies VmIfInline;\nexport const VM_NOT_OP = 110 satisfies VmNot;\nexport const VM_GET_DYNAMIC_VAR_OP = 111 satisfies VmGetDynamicVar;\nexport const VM_LOG_OP = 112 satisfies VmLog;\nexport const VM_SYSCALL_SIZE = 113 satisfies VmSize;\n\nexport function isOp(value: number): value is VmOp {\n  return value >= 16;\n}\n","import type { CompilationContext, HandleResult } from '@glimmer/interfaces';\nimport { logOpcodeSlice } from '@glimmer/debug';\nimport { extractHandle } from '@glimmer/debug-util';\nimport { LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\n\nexport let debugCompiler: (context: CompilationContext, handle: HandleResult) => void;\n\nif (LOCAL_TRACE_LOGGING) {\n  debugCompiler = (context: CompilationContext, result: HandleResult) => {\n    let handle = extractHandle(result);\n    let { heap } = context.evaluation.program;\n    let start = heap.getaddr(handle);\n    let end = start + heap.sizeof(handle);\n\n    logOpcodeSlice(context, start, end);\n  };\n}\n","import type {\n  BlockMetadata,\n  BlockSymbolNames,\n  ClassicResolver,\n  Expressions,\n  Nullable,\n  Owner,\n  ProgramConstants,\n  ResolutionTimeConstants,\n  ResolveComponentOp,\n  ResolveComponentOrHelperOp,\n  ResolveHelperOp,\n  ResolveModifierOp,\n  ResolveOptionalComponentOrHelperOp,\n  SexpOpcode,\n} from '@glimmer/interfaces';\nimport { debugToString, expect, localAssert, unwrap } from '@glimmer/debug-util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nfunction isGetLikeTuple(opcode: Expressions.Expression): opcode is Expressions.TupleExpression {\n  return Array.isArray(opcode) && opcode.length === 2;\n}\n\nfunction makeResolutionTypeVerifier(typeToVerify: SexpOpcode) {\n  return (\n    opcode: Expressions.Expression\n  ): opcode is Expressions.GetFree | Expressions.GetLexicalSymbol => {\n    if (!isGetLikeTuple(opcode)) return false;\n\n    let type = opcode[0];\n\n    return (\n      type === SexpOpcodes.GetStrictKeyword ||\n      type === SexpOpcodes.GetLexicalSymbol ||\n      type === typeToVerify\n    );\n  };\n}\n\nexport const isGetFreeComponent = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentHead);\n\nexport const isGetFreeModifier = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsModifierHead);\n\nexport const isGetFreeHelper = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsHelperHead);\n\nexport const isGetFreeComponentOrHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsComponentOrHelperHead\n);\n\ninterface ResolvedBlockMetadata extends BlockMetadata {\n  owner: Owner;\n  symbols: BlockSymbolNames & {\n    upvars: string[];\n  };\n}\n\nfunction assertResolverInvariants(meta: BlockMetadata): ResolvedBlockMetadata {\n  if (import.meta.env.DEV) {\n    if (!meta.symbols.upvars) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no free vars were found'\n      );\n    }\n\n    if (!meta.owner) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from'\n      );\n    }\n  }\n\n  return meta as unknown as ResolvedBlockMetadata;\n}\n\n/**\n * <Foo/>\n * <Foo></Foo>\n * <Foo @arg={{true}} />\n */\nexport function resolveComponent(\n  resolver: Nullable<ClassicResolver>,\n  constants: ProgramConstants,\n  meta: BlockMetadata,\n  [, expr, then]: ResolveComponentOp\n): void {\n  localAssert(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode');\n\n  let type = expr[0];\n\n  if (import.meta.env.DEV && expr[0] === SexpOpcodes.GetStrictKeyword) {\n    localAssert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n    throw new Error(\n      `Attempted to resolve a component in a strict mode template, but that value was not in scope: ${\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        meta.symbols.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let {\n      scopeValues,\n      owner,\n      symbols: { lexical },\n    } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(\n      constants.component(\n        definition as object,\n        expect(owner, 'BUG: expected owner when resolving component definition'),\n        false,\n        lexical?.at(expr[1])\n      )\n    );\n  } else {\n    let {\n      symbols: { upvars },\n      owner,\n    } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver?.lookupComponent?.(name, owner) ?? null;\n\n    if (import.meta.env.DEV && (typeof definition !== 'object' || definition === null)) {\n      localAssert(\n        !meta.isStrictMode,\n        'Strict mode errors should already be handled at compile time'\n      );\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    then(constants.resolvedComponent(definition!, name));\n  }\n}\n\n/**\n * (helper)\n * (helper arg)\n */\nexport function resolveHelper(\n  resolver: Nullable<ClassicResolver>,\n  constants: ProgramConstants,\n  meta: BlockMetadata,\n  [, expr, then]: ResolveHelperOp\n): void {\n  localAssert(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.helper(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    then(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'helper')\n    );\n  } else {\n    let {\n      symbols: { upvars },\n      owner,\n    } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let helper = resolver?.lookupHelper?.(name, owner) ?? null;\n\n    if (import.meta.env.DEV && helper === null) {\n      localAssert(\n        !meta.isStrictMode,\n        'Strict mode errors should already be handled at compile time'\n      );\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a helper, but nothing was found.`\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    then(constants.helper(helper!, name));\n  }\n}\n\n/**\n * <div {{modifier}}/>\n * <div {{modifier arg}}/>\n * <Foo {{modifier}}/>\n */\nexport function resolveModifier(\n  resolver: Nullable<ClassicResolver>,\n  constants: ProgramConstants,\n  meta: BlockMetadata,\n  [, expr, then]: ResolveModifierOp\n): void {\n  localAssert(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let {\n      scopeValues,\n      symbols: { lexical },\n    } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.modifier(definition as object, lexical?.at(expr[1]) ?? undefined));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    let {\n      symbols: { upvars },\n    } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver?.lookupBuiltInModifier?.(name) ?? null;\n\n    if (import.meta.env.DEV && modifier === null) {\n      localAssert(\n        !meta.isStrictMode,\n        'Strict mode errors should already be handled at compile time'\n      );\n\n      throw new Error(\n        `Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    then(constants.modifier(modifier!, name));\n  } else {\n    let {\n      symbols: { upvars },\n      owner,\n    } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver?.lookupModifier?.(name, owner) ?? null;\n\n    if (import.meta.env.DEV && modifier === null) {\n      localAssert(\n        !meta.isStrictMode,\n        'Strict mode errors should already be handled at compile time'\n      );\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a modifier, but nothing was found.`\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    then(constants.modifier(modifier!));\n  }\n}\n\n/**\n * {{component-or-helper arg}}\n */\nexport function resolveComponentOrHelper(\n  resolver: Nullable<ClassicResolver>,\n  constants: ProgramConstants,\n  meta: BlockMetadata,\n  [, expr, { ifComponent, ifHelper }]: ResolveComponentOrHelperOp\n): void {\n  localAssert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve a component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let {\n      scopeValues,\n      owner,\n      symbols: { lexical },\n    } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    let component = constants.component(\n      definition as object,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true,\n      lexical?.at(expr[1])\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition as object, null, true);\n\n    if (import.meta.env.DEV && helper === null) {\n      localAssert(\n        !meta.isStrictMode,\n        'Strict mode errors should already be handled at compile time'\n      );\n\n      throw new Error(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        `Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n\n    ifHelper(expect(helper, 'BUG: helper must exist'));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(\n        expr as Expressions.GetStrictFree,\n        resolver,\n        meta,\n        constants,\n        'component or helper'\n      )\n    );\n  } else {\n    let {\n      symbols: { upvars },\n      owner,\n    } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver?.lookupComponent?.(name, owner) ?? null;\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n    } else {\n      let helper = resolver?.lookupHelper?.(name, owner) ?? null;\n\n      if (import.meta.env.DEV && helper === null) {\n        localAssert(\n          !meta.isStrictMode,\n          'Strict mode errors should already be handled at compile time'\n        );\n\n        throw new Error(\n          `Attempted to resolve \\`${name}\\`, which was expected to be a component or helper, but nothing was found.`\n        );\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      ifHelper(constants.helper(helper!, name));\n    }\n  }\n}\n\n/**\n * {{maybeHelperOrComponent}}\n */\nexport function resolveOptionalComponentOrHelper(\n  resolver: Nullable<ClassicResolver>,\n  constants: ProgramConstants,\n  meta: BlockMetadata,\n  [, expr, { ifComponent, ifHelper, ifValue }]: ResolveOptionalComponentOrHelperOp\n): void {\n  localAssert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve an optional component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let {\n      scopeValues,\n      owner,\n      symbols: { lexical },\n    } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    if (\n      typeof definition !== 'function' &&\n      (typeof definition !== 'object' || definition === null)\n    ) {\n      // The value is not an object, so it can't be a component or helper.\n      ifValue(constants.value(definition));\n      return;\n    }\n\n    let component = constants.component(\n      definition,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true,\n      lexical?.at(expr[1])\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition, null, true);\n\n    if (helper !== null) {\n      ifHelper(helper);\n      return;\n    }\n\n    ifValue(constants.value(definition));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'value')\n    );\n  } else {\n    let {\n      symbols: { upvars },\n      owner,\n    } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver?.lookupComponent?.(name, owner) ?? null;\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n      return;\n    }\n\n    let helper = resolver?.lookupHelper?.(name, owner) ?? null;\n\n    if (helper !== null) {\n      ifHelper(constants.helper(helper, name));\n    }\n  }\n}\n\nfunction lookupBuiltInHelper(\n  expr: Expressions.GetStrictFree,\n  resolver: Nullable<ClassicResolver>,\n  meta: BlockMetadata,\n  constants: ResolutionTimeConstants,\n  type: string\n): number {\n  let {\n    symbols: { upvars },\n  } = assertResolverInvariants(meta);\n\n  let name = unwrap(upvars[expr[1]]);\n  let helper = resolver?.lookupBuiltInHelper?.(name) ?? null;\n\n  if (import.meta.env.DEV && helper === null) {\n    localAssert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n    // Keyword helper did not exist, which means that we're attempting to use a\n    // value of some kind that is not in scope\n    throw new Error(\n      `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        meta.symbols.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return constants.helper(helper!, name);\n}\n","import type {\n  HighLevelEnd,\n  HighLevelLabel,\n  HighLevelResolveComponent,\n  HighLevelResolveComponentOrHelper,\n  HighLevelResolveHelper,\n  HighLevelResolveLocal,\n  HighLevelResolveModifier,\n  HighLevelResolveOptionalComponentOrHelper,\n  HighLevelResolveTemplateLocal,\n  HighLevelStart,\n  HighLevelStartLabels,\n  HighLevelStopLabels,\n} from '@glimmer/interfaces';\n\nexport const HighLevelResolutionOpcodes = {\n  Modifier: 1003 satisfies HighLevelResolveModifier,\n  Component: 1004 satisfies HighLevelResolveComponent,\n  Helper: 1005 satisfies HighLevelResolveHelper,\n  ComponentOrHelper: 1007 satisfies HighLevelResolveComponentOrHelper,\n  OptionalComponentOrHelper: 1008 satisfies HighLevelResolveOptionalComponentOrHelper,\n  Local: 1010 satisfies HighLevelResolveLocal,\n  TemplateLocal: 1011 satisfies HighLevelResolveTemplateLocal,\n} as const;\n\nexport const HighLevelBuilderOpcodes = {\n  Label: 1000 satisfies HighLevelLabel,\n  StartLabels: 1001 satisfies HighLevelStartLabels,\n  StopLabels: 1002 satisfies HighLevelStopLabels,\n  Start: 1000 satisfies HighLevelStart,\n  End: 1002 satisfies HighLevelEnd,\n} as const;\n","import type {\n  BlockOperand,\n  BlockOperandType,\n  CompilableTemplate,\n  DebugSymbolsOperand,\n  DebugSymbolsOperandType,\n  IsStrictModeOperand,\n  IsStrictModeOperandType,\n  LabelOperand,\n  LabelOperandType,\n  LayoutOperand,\n  LayoutOperandType,\n  NonSmallIntOperand,\n  NonSmallIntOperandType,\n  SerializedBlock,\n  SerializedInlineBlock,\n  StdLibOperand,\n  StdLibOperandType,\n  SymbolTable,\n  SymbolTableOperand,\n  SymbolTableOperandType,\n} from '@glimmer/interfaces';\nimport { isSmallInt } from '@glimmer/constants';\nimport { localAssert } from '@glimmer/debug-util';\n\nexport const HighLevelOperands = {\n  Label: 1 satisfies LabelOperandType,\n  IsStrictMode: 2 satisfies IsStrictModeOperandType,\n  DebugSymbols: 3 satisfies DebugSymbolsOperandType,\n  Block: 4 satisfies BlockOperandType,\n  StdLib: 5 satisfies StdLibOperandType,\n  NonSmallInt: 6 satisfies NonSmallIntOperandType,\n  SymbolTable: 7 satisfies SymbolTableOperandType,\n  Layout: 8 satisfies LayoutOperandType,\n} as const;\n\nexport function labelOperand(value: string): LabelOperand {\n  return { type: HighLevelOperands.Label, value };\n}\n\nexport function debugSymbolsOperand(\n  locals: Record<string, number>,\n  upvars: Record<string, number>,\n  lexical: Record<string, number>\n): DebugSymbolsOperand {\n  return { type: HighLevelOperands.DebugSymbols, value: { locals, upvars, lexical } };\n}\n\nexport function isStrictMode(): IsStrictModeOperand {\n  return { type: HighLevelOperands.IsStrictMode, value: undefined };\n}\n\nexport function blockOperand(value: SerializedInlineBlock | SerializedBlock): BlockOperand {\n  return { type: HighLevelOperands.Block, value };\n}\n\nexport function stdlibOperand(\n  value:\n    | 'main'\n    | 'trusting-append'\n    | 'cautious-append'\n    | 'trusting-non-dynamic-append'\n    | 'cautious-non-dynamic-append'\n): StdLibOperand {\n  return { type: HighLevelOperands.StdLib, value };\n}\n\nexport function nonSmallIntOperand(value: number): NonSmallIntOperand {\n  localAssert(\n    !isSmallInt(value),\n    'Attempted to make a operand for an int that was not a small int, you should encode this as an immediate'\n  );\n  return { type: HighLevelOperands.NonSmallInt, value };\n}\n\nexport function symbolTableOperand(value: SymbolTable): SymbolTableOperand {\n  return { type: HighLevelOperands.SymbolTable, value };\n}\n\nexport function layoutOperand(value: CompilableTemplate): LayoutOperand {\n  return { type: HighLevelOperands.Layout, value };\n}\n","import type {\n  BlockMetadata,\n  BuilderOp,\n  BuilderOpcode,\n  CompileTimeConstants,\n  Dict,\n  Encoder,\n  EncoderError,\n  EvaluationContext,\n  HandleResult,\n  HighLevelOp,\n  InstructionEncoder,\n  Operand,\n  ProgramHeap,\n  SingleBuilderOperand,\n  STDLib,\n} from '@glimmer/interfaces';\nimport { encodeHandle, isMachineOp, VM_PRIMITIVE_OP, VM_RETURN_OP } from '@glimmer/constants';\nimport { expect, isPresentArray, localAssert } from '@glimmer/debug-util';\nimport { InstructionEncoderImpl } from '@glimmer/encoder';\nimport { dict, Stack } from '@glimmer/util';\nimport { ARG_SHIFT, MACHINE_MASK, TYPE_SIZE } from '@glimmer/vm';\n\nimport { compilableBlock } from '../compilable-template';\nimport {\n  resolveComponent,\n  resolveComponentOrHelper,\n  resolveHelper,\n  resolveModifier,\n  resolveOptionalComponentOrHelper,\n} from './helpers/resolution';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from './opcodes';\nimport { HighLevelOperands } from './operands';\n\nexport class Labels {\n  labels: Dict<number> = dict();\n  targets: Array<{ at: number; target: string }> = [];\n\n  label(name: string, index: number) {\n    this.labels[name] = index;\n  }\n\n  target(at: number, target: string) {\n    this.targets.push({ at, target });\n  }\n\n  patch(heap: ProgramHeap): void {\n    let { targets, labels } = this;\n\n    for (const { at, target } of targets) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      let address = labels[target]! - at;\n\n      localAssert(\n        heap.getbyaddr(at) === -1,\n        'Expected heap to contain a placeholder, but it did not'\n      );\n\n      heap.setbyaddr(at, address);\n    }\n  }\n}\n\nexport function encodeOp(\n  encoder: Encoder,\n  context: EvaluationContext,\n  meta: BlockMetadata,\n  op: BuilderOp | HighLevelOp\n): void {\n  let {\n    program: { constants },\n    resolver,\n  } = context;\n\n  if (isBuilderOpcode(op[0])) {\n    let [type, ...operands] = op;\n    encoder.push(constants, type, ...(operands as SingleBuilderOperand[]));\n  } else {\n    switch (op[0]) {\n      case HighLevelBuilderOpcodes.Label:\n        return encoder.label(op[1]);\n      case HighLevelBuilderOpcodes.StartLabels:\n        return encoder.startLabels();\n      case HighLevelBuilderOpcodes.StopLabels:\n        return encoder.stopLabels();\n      case HighLevelResolutionOpcodes.Component:\n        return resolveComponent(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Modifier:\n        return resolveModifier(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Helper:\n        return resolveHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.ComponentOrHelper:\n        return resolveComponentOrHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.OptionalComponentOrHelper:\n        return resolveOptionalComponentOrHelper(resolver, constants, meta, op);\n\n      case HighLevelResolutionOpcodes.Local: {\n        let [, freeVar, andThen] = op;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        let name = expect(\n          meta.symbols.upvars,\n          'BUG: attempted to resolve value but no upvars found'\n        )[freeVar]!;\n\n        andThen(name, meta.moduleName);\n\n        break;\n      }\n\n      case HighLevelResolutionOpcodes.TemplateLocal: {\n        let [, valueIndex, then] = op;\n        let value = expect(\n          meta.scopeValues,\n          'BUG: Attempted to get a template local, but template does not have any'\n        )[valueIndex];\n\n        then(constants.value(value));\n\n        break;\n      }\n\n      default:\n        throw new Error(`Unexpected high level opcode ${op[0]}`);\n    }\n  }\n}\n\nexport class EncoderImpl implements Encoder {\n  private labelsStack = new Stack<Labels>();\n  private encoder: InstructionEncoder = new InstructionEncoderImpl([]);\n  private errors: EncoderError[] = [];\n  private handle: number;\n\n  constructor(\n    private heap: ProgramHeap,\n    private meta: BlockMetadata,\n    private stdlib?: STDLib\n  ) {\n    this.handle = heap.malloc();\n  }\n\n  error(error: EncoderError): void {\n    this.encoder.encode(VM_PRIMITIVE_OP, 0);\n    this.errors.push(error);\n  }\n\n  commit(size: number): HandleResult {\n    let handle = this.handle;\n\n    this.heap.pushMachine(VM_RETURN_OP);\n    this.heap.finishMalloc(handle, size);\n\n    if (isPresentArray(this.errors)) {\n      return { errors: this.errors, handle };\n    } else {\n      return handle;\n    }\n  }\n\n  push(\n    constants: CompileTimeConstants,\n    type: BuilderOpcode,\n    ...args: SingleBuilderOperand[]\n  ): void {\n    let { heap } = this;\n\n    if (import.meta.env.DEV && (type as number) > TYPE_SIZE) {\n      throw new Error(`Opcode type over 8-bits. Got ${type}.`);\n    }\n\n    let machine = isMachineOp(type) ? MACHINE_MASK : 0;\n    let first = type | machine | (args.length << ARG_SHIFT);\n\n    heap.pushRaw(first);\n\n    for (let i = 0; i < args.length; i++) {\n      let op = args[i];\n      heap.pushRaw(this.operand(constants, op));\n    }\n  }\n\n  private operand(constants: CompileTimeConstants, operand: SingleBuilderOperand): Operand {\n    if (typeof operand === 'number') {\n      return operand;\n    }\n\n    if (typeof operand === 'object' && operand !== null) {\n      if (Array.isArray(operand)) {\n        return encodeHandle(constants.array(operand));\n      } else {\n        switch (operand.type) {\n          case HighLevelOperands.Label:\n            this.currentLabels.target(this.heap.offset, operand.value);\n            return -1;\n\n          case HighLevelOperands.IsStrictMode:\n            return encodeHandle(constants.value(this.meta.isStrictMode));\n\n          case HighLevelOperands.DebugSymbols:\n            return encodeHandle(constants.value(operand.value));\n\n          case HighLevelOperands.Block:\n            return encodeHandle(constants.value(compilableBlock(operand.value, this.meta)));\n\n          case HighLevelOperands.StdLib:\n            return expect(\n              this.stdlib,\n              'attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?'\n            )[operand.value];\n\n          case HighLevelOperands.NonSmallInt:\n          case HighLevelOperands.SymbolTable:\n          case HighLevelOperands.Layout:\n            return constants.value(operand.value);\n        }\n      }\n    }\n\n    return encodeHandle(constants.value(operand));\n  }\n\n  private get currentLabels(): Labels {\n    return expect(this.labelsStack.current, 'bug: not in a label stack');\n  }\n\n  label(name: string) {\n    this.currentLabels.label(name, this.heap.offset + 1);\n  }\n\n  startLabels() {\n    this.labelsStack.push(new Labels());\n  }\n\n  stopLabels() {\n    let label = expect(this.labelsStack.pop(), 'unbalanced push and pop labels');\n    label.patch(this.heap);\n  }\n}\n\nfunction isBuilderOpcode(op: number): op is BuilderOpcode {\n  return op < HighLevelBuilderOpcodes.Start;\n}\n","import type {\n  VmMachineInvokeStatic,\n  VmMachineInvokeVirtual,\n  VmMachineJump,\n  VmMachineOp,\n  VmMachinePopFrame,\n  VmMachinePushFrame,\n  VmMachineReturn,\n  VmMachineReturnTo,\n  VmMachineSize,\n} from '@glimmer/interfaces';\n\nexport const VM_PUSH_FRAME_OP = 0 satisfies VmMachinePushFrame;\nexport const VM_POP_FRAME_OP = 1 satisfies VmMachinePopFrame;\nexport const VM_INVOKE_VIRTUAL_OP = 2 satisfies VmMachineInvokeVirtual;\nexport const VM_INVOKE_STATIC_OP = 3 satisfies VmMachineInvokeStatic;\nexport const VM_JUMP_OP = 4 satisfies VmMachineJump;\nexport const VM_RETURN_OP = 5 satisfies VmMachineReturn;\nexport const VM_RETURN_TO_OP = 6 satisfies VmMachineReturnTo;\nexport const VM_MACHINE_SIZE = 7 satisfies VmMachineSize;\n\nexport function isMachineOp(value: number): value is VmMachineOp {\n  return value >= 0 && value <= 15;\n}\n","import type { Nullable, Present, PresentArray } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nexport function isPresent<T>(value: T): value is Present<T> {\n  return value !== null && value !== undefined;\n}\n\nexport function assertPresent<T extends string>(value: T): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message: string): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message?: string): asserts value is Present<T> {\n  if (LOCAL_DEBUG && !isPresent(value)) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    throw new Error(`Expected present, got ${typeof value === 'string' ? value : message!}`);\n  }\n}\n\nexport function isPresentArray<T>(list?: readonly T[]): list is PresentArray<T> {\n  return list ? list.length > 0 : false;\n}\n\nexport function ifPresent<T, U, V>(\n  list: T[],\n  ifPresent: (input: PresentArray<T>) => U,\n  otherwise: () => V\n): U | V {\n  if (isPresentArray(list)) {\n    return ifPresent(list);\n  } else {\n    return otherwise();\n  }\n}\n\nexport function arrayToOption<T>(list: T[]): Nullable<PresentArray<T>> {\n  if (isPresentArray(list)) {\n    return list;\n  } else {\n    return null;\n  }\n}\n\nexport function assertPresentArray<T>(\n  list: T[],\n  message = `unexpected empty list`\n): asserts list is PresentArray<T> {\n  if (LOCAL_DEBUG && !isPresentArray(list)) {\n    throw new Error(message);\n  }\n}\n\nexport function asPresentArray<T>(list: T[], message = `unexpected empty list`): PresentArray<T> {\n  assertPresentArray(list, message);\n  return list;\n}\n\nexport function getLast<T>(list: PresentArray<T>): T;\nexport function getLast<T>(list: T[]): T | undefined;\nexport function getLast<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[list.length - 1] as T);\n}\n\nexport function getFirst<T>(list: PresentArray<T>): T;\nexport function getFirst<T>(list: T[]): T | undefined;\nexport function getFirst<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[0] as T);\n}\n\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T>,\n  mapper: (input: T) => U\n): PresentArray<U>;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null {\n  if (list === null) {\n    return null;\n  }\n  let out: U[] = [];\n\n  for (let item of list) {\n    out.push(mapper(item));\n  }\n\n  return out as PresentArray<U>;\n}\n","import type {\n  BlockMetadata,\n  BlockSymbolTable,\n  BuilderOp,\n  CompilableBlock,\n  CompilableProgram,\n  CompilableTemplate,\n  EvaluationContext,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  SerializedBlock,\n  SerializedInlineBlock,\n  Statement,\n  SymbolTable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { IS_COMPILABLE_TEMPLATE } from '@glimmer/constants';\nimport { LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\nimport { EMPTY_ARRAY } from '@glimmer/util';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { meta } from './opcode-builder/helpers/shared';\nimport { STATEMENTS } from './syntax/statements';\n\nexport const PLACEHOLDER_HANDLE = -1;\n\nclass CompilableTemplateImpl<S extends SymbolTable> implements CompilableTemplate<S> {\n  static {\n    if (LOCAL_TRACE_LOGGING) {\n      Reflect.set(this.prototype, IS_COMPILABLE_TEMPLATE, true);\n    }\n  }\n\n  compiled: Nullable<HandleResult> = null;\n\n  constructor(\n    readonly statements: WireFormat.Statement[],\n    readonly meta: BlockMetadata,\n    // Part of CompilableTemplate\n    readonly symbolTable: S,\n    // Used for debugging\n    readonly moduleName = 'plain block'\n  ) {}\n\n  // Part of CompilableTemplate\n  compile(context: EvaluationContext): HandleResult {\n    return maybeCompile(this, context);\n  }\n}\n\nexport function compilable(layout: LayoutWithContext, moduleName: string): CompilableProgram {\n  let [statements, symbols] = layout.block;\n  return new CompilableTemplateImpl(\n    statements,\n    meta(layout),\n    {\n      symbols,\n    },\n    moduleName\n  );\n}\n\nfunction maybeCompile(\n  compilable: CompilableTemplateImpl<SymbolTable>,\n  context: EvaluationContext\n): HandleResult {\n  if (compilable.compiled !== null) return compilable.compiled;\n\n  compilable.compiled = PLACEHOLDER_HANDLE;\n\n  let { statements, meta } = compilable;\n\n  let result = compileStatements(statements, meta, context);\n  compilable.compiled = result;\n\n  return result;\n}\n\nexport function compileStatements(\n  statements: Statement[],\n  meta: BlockMetadata,\n  syntaxContext: EvaluationContext\n): HandleResult {\n  let sCompiler = STATEMENTS;\n  let context = templateCompilationContext(syntaxContext, meta);\n\n  let { encoder, evaluation } = context;\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, evaluation, meta, op as BuilderOp | HighLevelOp);\n  }\n\n  for (const statement of statements) {\n    sCompiler.compile(pushOp, statement);\n  }\n\n  let handle = context.encoder.commit(meta.size);\n\n  if (LOCAL_TRACE_LOGGING) {\n    debugCompiler(context, handle);\n  }\n\n  return handle;\n}\n\nexport function compilableBlock(\n  block: SerializedInlineBlock | SerializedBlock,\n  containing: BlockMetadata\n): CompilableBlock {\n  return new CompilableTemplateImpl<BlockSymbolTable>(block[0], containing, {\n    parameters: block[1] || (EMPTY_ARRAY as number[]),\n  });\n}\n","import type { BlockMetadata, CompilationContext, EvaluationContext } from '@glimmer/interfaces';\n\nimport { EncoderImpl } from './encoder';\n\nexport function templateCompilationContext(\n  evaluation: EvaluationContext,\n  meta: BlockMetadata\n): CompilationContext {\n  let encoder = new EncoderImpl(evaluation.program.heap, meta, evaluation.stdlib);\n\n  return {\n    evaluation,\n    encoder,\n    meta,\n  };\n}\n","import type { BuilderOp, HighLevelOp, SexpOpcode, SexpOpcodeMap } from '@glimmer/interfaces';\nimport { localAssert, unwrap } from '@glimmer/debug-util';\n\nexport type PushExpressionOp = (...op: BuilderOp | HighLevelOp) => void;\n\ndeclare const STATEMENT: unique symbol;\n\nexport type HighLevelStatementOp = [{ [STATEMENT]: undefined }];\n\nexport type PushStatementOp = (...op: BuilderOp | HighLevelOp | HighLevelStatementOp) => void;\n\nexport type CompilerFunction<PushOp extends PushExpressionOp, TSexp> = (\n  op: PushOp,\n  sexp: TSexp\n) => void;\n\nexport class Compilers<PushOp extends PushExpressionOp, TSexpOpcodes extends SexpOpcode> {\n  private names: {\n    [name: number]: number;\n  } = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private funcs: CompilerFunction<PushOp, any>[] = [];\n\n  add<TSexpOpcode extends TSexpOpcodes>(\n    name: TSexpOpcode,\n    func: CompilerFunction<PushOp, SexpOpcodeMap[TSexpOpcode]>\n  ): void {\n    this.names[name] = this.funcs.push(func) - 1;\n  }\n\n  compile(op: PushOp, sexp: SexpOpcodeMap[TSexpOpcodes]): void {\n    let name = sexp[0];\n    let index = unwrap(this.names[name]);\n    let func = this.funcs[index];\n    localAssert(!!func, `expected an implementation for ${sexp[0]}`);\n\n    func(op, sexp);\n  }\n}\n","import type { ExpressionSexpOpcode } from '@glimmer/interfaces';\nimport {\n  VM_COMPILE_BLOCK_OP,\n  VM_CONCAT_OP,\n  VM_CONSTANT_REFERENCE_OP,\n  VM_FETCH_OP,\n  VM_GET_DYNAMIC_VAR_OP,\n  VM_GET_PROPERTY_OP,\n  VM_GET_VARIABLE_OP,\n  VM_HAS_BLOCK_OP,\n  VM_HAS_BLOCK_PARAMS_OP,\n  VM_IF_INLINE_OP,\n  VM_LOG_OP,\n  VM_NOT_OP,\n  VM_POP_FRAME_OP,\n  VM_PUSH_FRAME_OP,\n  VM_SPREAD_BLOCK_OP,\n} from '@glimmer/constants';\nimport { $v0 } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushExpressionOp } from './compilers';\n\nimport { expr } from '../opcode-builder/helpers/expr';\nimport { isGetFreeHelper } from '../opcode-builder/helpers/resolution';\nimport { SimpleArgs } from '../opcode-builder/helpers/shared';\nimport { Call, CallDynamic, Curry, PushPrimitiveReference } from '../opcode-builder/helpers/vm';\nimport { HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { Compilers } from './compilers';\n\nexport const EXPRESSIONS = new Compilers<PushExpressionOp, ExpressionSexpOpcode>();\n\nEXPRESSIONS.add(SexpOpcodes.Concat, (op, [, parts]) => {\n  for (let part of parts) {\n    expr(op, part);\n  }\n\n  op(VM_CONCAT_OP, parts.length);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Call, (op, [, expression, positional, named]) => {\n  if (isGetFreeHelper(expression)) {\n    op(HighLevelResolutionOpcodes.Helper, expression, (handle: number) => {\n      Call(op, handle, positional, named);\n    });\n  } else {\n    expr(op, expression);\n    CallDynamic(op, positional, named);\n  }\n});\n\nEXPRESSIONS.add(SexpOpcodes.Curry, (op, [, expr, type, positional, named]) => {\n  Curry(op, type, expr, positional, named);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetSymbol, (op, [, sym, path]) => {\n  op(VM_GET_VARIABLE_OP, sym);\n  withPath(op, path);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetLexicalSymbol, (op, [, sym, path]) => {\n  op(HighLevelResolutionOpcodes.TemplateLocal, sym, (handle: number) => {\n    op(VM_CONSTANT_REFERENCE_OP, handle);\n    withPath(op, path);\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetStrictKeyword, (op, expr) => {\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.Helper, expr, (handle: number) => {\n      Call(op, handle, null, null);\n    });\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsHelperHead, (op, expr) => {\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.Helper, expr, (handle: number) => {\n      Call(op, handle, null, null);\n    });\n  });\n});\n\nfunction withPath(op: PushExpressionOp, path?: string[]) {\n  if (path === undefined || path.length === 0) return;\n\n  for (let i = 0; i < path.length; i++) {\n    op(VM_GET_PROPERTY_OP, path[i]);\n  }\n}\n\nEXPRESSIONS.add(SexpOpcodes.Undefined, (op) => PushPrimitiveReference(op, undefined));\nEXPRESSIONS.add(SexpOpcodes.HasBlock, (op, [, block]) => {\n  expr(op, block);\n  op(VM_HAS_BLOCK_OP);\n});\n\nEXPRESSIONS.add(SexpOpcodes.HasBlockParams, (op, [, block]) => {\n  expr(op, block);\n  op(VM_SPREAD_BLOCK_OP);\n  op(VM_COMPILE_BLOCK_OP);\n  op(VM_HAS_BLOCK_PARAMS_OP);\n});\n\nEXPRESSIONS.add(SexpOpcodes.IfInline, (op, [, condition, truthy, falsy]) => {\n  // Push in reverse order\n  expr(op, falsy);\n  expr(op, truthy);\n  expr(op, condition);\n  op(VM_IF_INLINE_OP);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Not, (op, [, value]) => {\n  expr(op, value);\n  op(VM_NOT_OP);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetDynamicVar, (op, [, expression]) => {\n  expr(op, expression);\n  op(VM_GET_DYNAMIC_VAR_OP);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Log, (op, [, positional]) => {\n  op(VM_PUSH_FRAME_OP);\n  SimpleArgs(op, positional, null, false);\n  op(VM_LOG_OP);\n  op(VM_POP_FRAME_OP);\n  op(VM_FETCH_OP, $v0);\n});\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { VM_PRIMITIVE_REFERENCE_OP } from '@glimmer/constants';\n\nimport type { PushExpressionOp } from '../../syntax/compilers';\n\nimport { EXPRESSIONS } from '../../syntax/expressions';\nimport { PushPrimitive } from './vm';\n\nexport function expr(op: PushExpressionOp, expression: WireFormat.Expression): void {\n  if (Array.isArray(expression)) {\n    EXPRESSIONS.compile(op, expression);\n  } else {\n    PushPrimitive(op, expression);\n    op(VM_PRIMITIVE_REFERENCE_OP);\n  }\n}\n","import type { CurriedType, NonSmallIntOperand, Nullable, WireFormat } from '@glimmer/interfaces';\nimport {\n  encodeImmediate,\n  isSmallInt,\n  VM_BIND_DYNAMIC_SCOPE_OP,\n  VM_CAPTURE_ARGS_OP,\n  VM_CURRY_OP,\n  VM_DUP_OP,\n  VM_DYNAMIC_HELPER_OP,\n  VM_FETCH_OP,\n  VM_HELPER_OP,\n  VM_POP_DYNAMIC_SCOPE_OP,\n  VM_POP_FRAME_OP,\n  VM_POP_OP,\n  VM_PRIMITIVE_OP,\n  VM_PRIMITIVE_REFERENCE_OP,\n  VM_PUSH_DYNAMIC_SCOPE_OP,\n  VM_PUSH_FRAME_OP,\n} from '@glimmer/constants';\nimport { $fp, $v0 } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { isStrictMode, nonSmallIntOperand } from '../operands';\nimport { expr } from './expr';\nimport { SimpleArgs } from './shared';\n\nexport type Primitive = undefined | null | boolean | number | string;\n\nexport interface CompileHelper {\n  handle: number;\n  positional: Nullable<WireFormat.Core.Params>;\n  named: WireFormat.Core.Hash;\n}\n\n/**\n * Push a reference onto the stack corresponding to a statically known primitive\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitiveReference(op: PushExpressionOp, value: Primitive): void {\n  PushPrimitive(op, value);\n  op(VM_PRIMITIVE_REFERENCE_OP);\n}\n\n/**\n * Push an encoded representation of a JavaScript primitive on the stack\n *\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitive(op: PushExpressionOp, primitive: Primitive): void {\n  let p: Primitive | NonSmallIntOperand = primitive;\n\n  if (typeof p === 'number') {\n    p = isSmallInt(p) ? encodeImmediate(p) : nonSmallIntOperand(p);\n  }\n\n  op(VM_PRIMITIVE_OP, p);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a statically known handle\n *\n * @param op The op creation function\n * @param handle A handle\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function Call(\n  op: PushExpressionOp,\n  handle: number,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(VM_PUSH_FRAME_OP);\n  SimpleArgs(op, positional, named, false);\n  op(VM_HELPER_OP, handle);\n  op(VM_POP_FRAME_OP);\n  op(VM_FETCH_OP, $v0);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a dynamically loaded definition\n *\n * @param op The op creation function\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function CallDynamic(\n  op: PushExpressionOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  append?: () => void\n): void {\n  op(VM_PUSH_FRAME_OP);\n  SimpleArgs(op, positional, named, false);\n  op(VM_DUP_OP, $fp, 1);\n  op(VM_DYNAMIC_HELPER_OP);\n  if (append) {\n    op(VM_FETCH_OP, $v0);\n    append();\n    op(VM_POP_FRAME_OP);\n    op(VM_POP_OP, 1);\n  } else {\n    op(VM_POP_FRAME_OP);\n    op(VM_POP_OP, 1);\n    op(VM_FETCH_OP, $v0);\n  }\n}\n\n/**\n * Evaluate statements in the context of new dynamic scope entries. Move entries from the\n * stack into named entries in the dynamic scope, then evaluate the statements, then pop\n * the dynamic scope\n *\n * @param names a list of dynamic scope names\n * @param block a function that returns a list of statements to evaluate\n */\nexport function DynamicScope(op: PushStatementOp, names: string[], block: () => void): void {\n  op(VM_PUSH_DYNAMIC_SCOPE_OP);\n  op(VM_BIND_DYNAMIC_SCOPE_OP, names);\n  block();\n  op(VM_POP_DYNAMIC_SCOPE_OP);\n}\n\nexport function Curry(\n  op: PushExpressionOp,\n  type: CurriedType,\n  definition: WireFormat.Expression,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(VM_PUSH_FRAME_OP);\n  SimpleArgs(op, positional, named, false);\n  op(VM_CAPTURE_ARGS_OP);\n  expr(op, definition);\n  op(VM_CURRY_OP, type, isStrictMode());\n  op(VM_POP_FRAME_OP);\n  op(VM_FETCH_OP, $v0);\n}\n","import type { Nullable, WireFormat } from '@glimmer/interfaces';\nimport {\n  VM_CHILD_SCOPE_OP,\n  VM_COMPILE_BLOCK_OP,\n  VM_CONSTANT_OP,\n  VM_DUP_OP,\n  VM_GET_BLOCK_OP,\n  VM_INVOKE_VIRTUAL_OP,\n  VM_INVOKE_YIELD_OP,\n  VM_POP_FRAME_OP,\n  VM_POP_SCOPE_OP,\n  VM_PUSH_BLOCK_SCOPE_OP,\n  VM_PUSH_FRAME_OP,\n  VM_PUSH_SYMBOL_TABLE_OP,\n  VM_SET_VARIABLE_OP,\n  VM_SPREAD_BLOCK_OP,\n} from '@glimmer/constants';\nimport { $fp } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { blockOperand, symbolTableOperand } from '../operands';\nimport { SimpleArgs } from './shared';\nimport { PushPrimitive } from './vm';\n\n/**\n * Yield to a block located at a particular symbol location.\n *\n * @param to the symbol containing the block to yield to\n * @param params optional block parameters to yield to the block\n */\nexport function YieldBlock(\n  op: PushStatementOp,\n  to: number,\n  positional: Nullable<WireFormat.Core.Params>\n): void {\n  SimpleArgs(op, positional, null, true);\n  op(VM_GET_BLOCK_OP, to);\n  op(VM_SPREAD_BLOCK_OP);\n  op(VM_COMPILE_BLOCK_OP);\n  op(VM_INVOKE_YIELD_OP);\n  op(VM_POP_SCOPE_OP);\n  op(VM_POP_FRAME_OP);\n}\n\n/**\n * Push an (optional) yieldable block onto the stack. The yieldable block must be known\n * statically at compile time.\n *\n * @param block An optional Compilable block\n */\nexport function PushYieldableBlock(\n  op: PushStatementOp,\n  block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  PushSymbolTable(op, block && block[1]);\n  op(VM_PUSH_BLOCK_SCOPE_OP);\n  PushCompilable(op, block);\n}\n\n/**\n * Invoke a block that is known statically at compile time.\n *\n * @param block a Compilable block\n */\nexport function InvokeStaticBlock(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock\n): void {\n  op(VM_PUSH_FRAME_OP);\n  PushCompilable(op, block);\n  op(VM_COMPILE_BLOCK_OP);\n  op(VM_INVOKE_VIRTUAL_OP);\n  op(VM_POP_FRAME_OP);\n}\n\n/**\n * Invoke a static block, preserving some number of stack entries for use in\n * updating.\n *\n * @param block A compilable block\n * @param callerCount A number of stack entries to preserve\n */\nexport function InvokeStaticBlockWithStack(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock,\n  callerCount: number\n): void {\n  let parameters = block[1];\n  let calleeCount = parameters.length;\n  let count = Math.min(callerCount, calleeCount);\n\n  if (count === 0) {\n    InvokeStaticBlock(op, block);\n    return;\n  }\n\n  op(VM_PUSH_FRAME_OP);\n\n  if (count) {\n    op(VM_CHILD_SCOPE_OP);\n\n    for (let i = 0; i < count; i++) {\n      op(VM_DUP_OP, $fp, callerCount - i);\n      op(VM_SET_VARIABLE_OP, parameters[i]);\n    }\n  }\n\n  PushCompilable(op, block);\n  op(VM_COMPILE_BLOCK_OP);\n  op(VM_INVOKE_VIRTUAL_OP);\n\n  if (count) {\n    op(VM_POP_SCOPE_OP);\n  }\n\n  op(VM_POP_FRAME_OP);\n}\n\nexport function PushSymbolTable(op: PushExpressionOp, parameters: number[] | null): void {\n  if (parameters !== null) {\n    op(VM_PUSH_SYMBOL_TABLE_OP, symbolTableOperand({ parameters }));\n  } else {\n    PushPrimitive(op, null);\n  }\n}\n\nexport function PushCompilable(\n  op: PushExpressionOp,\n  _block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  if (_block === null) {\n    PushPrimitive(op, null);\n  } else {\n    op(VM_CONSTANT_OP, blockOperand(_block));\n  }\n}\n","import type {\n  BlockMetadata,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { VM_PUSH_ARGS_OP, VM_PUSH_EMPTY_ARGS_OP } from '@glimmer/constants';\nimport { EMPTY_ARRAY, EMPTY_STRING_ARRAY } from '@glimmer/util';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { PushYieldableBlock } from './blocks';\nimport { expr } from './expr';\n\n/**\n * Compile arguments, pushing an Arguments object onto the stack.\n *\n * @param args.params\n * @param args.hash\n * @param args.blocks\n * @param args.atNames\n */\nexport function CompileArgs(\n  op: PushStatementOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  blocks: NamedBlocks,\n  atNames: boolean\n): void {\n  let blockNames: string[] = blocks.names;\n  for (const name of blockNames) {\n    PushYieldableBlock(op, blocks.get(name));\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  if (blocks.hasAny) {\n    flags |= 0b111;\n  }\n\n  let names = EMPTY_ARRAY as readonly string[];\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(VM_PUSH_ARGS_OP, names as string[], blockNames, flags);\n}\n\nexport function SimpleArgs(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>,\n  named: Nullable<WireFormat.Core.Hash>,\n  atNames: boolean\n): void {\n  if (positional === null && named === null) {\n    op(VM_PUSH_EMPTY_ARGS_OP);\n    return;\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  let names = EMPTY_STRING_ARRAY;\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(VM_PUSH_ARGS_OP, names, EMPTY_STRING_ARRAY, flags);\n}\n\n/**\n * Compile an optional list of positional arguments, which pushes each argument\n * onto the stack and returns the number of parameters compiled\n *\n * @param positional an optional list of positional arguments\n */\nexport function CompilePositional(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>\n): number {\n  if (positional === null) return 0;\n\n  for (let i = 0; i < positional.length; i++) {\n    expr(op, positional[i]);\n  }\n\n  return positional.length;\n}\n\nexport function meta(layout: LayoutWithContext): BlockMetadata {\n  let [, locals, upvars, lexicalSymbols] = layout.block;\n\n  return {\n    symbols: {\n      locals,\n      upvars,\n      lexical: lexicalSymbols,\n    },\n    scopeValues: layout.scope?.() ?? null,\n    isStrictMode: layout.isStrictMode,\n    moduleName: layout.moduleName,\n    owner: layout.owner,\n    size: locals.length,\n  };\n}\n","import type { NamedBlocks, Nullable, SerializedInlineBlock, WireFormat } from '@glimmer/interfaces';\nimport { unwrap } from '@glimmer/debug-util';\nimport { assign, dict, enumerate } from '@glimmer/util';\n\ninterface NamedBlocksDict {\n  [key: string]: Nullable<WireFormat.SerializedInlineBlock>;\n}\n\nexport class NamedBlocksImpl implements NamedBlocks {\n  public names: string[];\n\n  constructor(private blocks: Nullable<NamedBlocksDict>) {\n    this.names = blocks ? Object.keys(blocks) : [];\n  }\n\n  get(name: string): Nullable<SerializedInlineBlock> {\n    if (!this.blocks) return null;\n\n    return this.blocks[name] || null;\n  }\n\n  has(name: string): boolean {\n    let { blocks } = this;\n    return blocks !== null && name in blocks;\n  }\n\n  with(name: string, block: Nullable<SerializedInlineBlock>): NamedBlocks {\n    let { blocks } = this;\n\n    if (blocks) {\n      return new NamedBlocksImpl(assign({}, blocks, { [name]: block }));\n    } else {\n      return new NamedBlocksImpl({ [name]: block });\n    }\n  }\n\n  get hasAny(): boolean {\n    return this.blocks !== null;\n  }\n}\n\nexport const EMPTY_BLOCKS = new NamedBlocksImpl(null);\n\nexport function namedBlocks(blocks: WireFormat.Core.Blocks): NamedBlocks {\n  if (blocks === null) {\n    return EMPTY_BLOCKS;\n  }\n\n  let out: NamedBlocksDict = dict();\n\n  let [keys, values] = blocks;\n\n  for (const [i, key] of enumerate(keys)) {\n    out[key] = unwrap(values[i]);\n  }\n\n  return new NamedBlocksImpl(out);\n}\n","import {\n  VM_ENTER_OP,\n  VM_EXIT_OP,\n  VM_JUMP_EQ_OP,\n  VM_JUMP_OP,\n  VM_JUMP_UNLESS_OP,\n  VM_POP_FRAME_OP,\n  VM_POP_OP,\n  VM_PUSH_FRAME_OP,\n  VM_RETURN_OP,\n  VM_RETURN_TO_OP,\n} from '@glimmer/constants';\nimport { unwrap } from '@glimmer/debug-util';\n\nimport type { PushStatementOp } from '../../syntax/compilers';\n\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { labelOperand } from '../operands';\n\nexport type When = (match: number, callback: () => void) => void;\n\nexport function SwitchCases(\n  op: PushStatementOp,\n  bootstrap: () => void,\n  matcher: (when: When) => void\n): void {\n  // Setup the switch DSL\n  let clauses: Array<{ match: number; label: string; callback: () => void }> = [];\n\n  let count = 0;\n\n  function when(match: number, callback: () => void): void {\n    clauses.push({ match, callback, label: `CLAUSE${count++}` });\n  }\n\n  // Call the callback\n  matcher(when);\n\n  // Emit the opcodes for the switch\n  op(VM_ENTER_OP, 1);\n  bootstrap();\n  op(HighLevelBuilderOpcodes.StartLabels);\n\n  // First, emit the jump opcodes. We don't need a jump for the last\n  // opcode, since it bleeds directly into its clause.\n  for (let clause of clauses.slice(0, -1)) {\n    op(VM_JUMP_EQ_OP, labelOperand(clause.label), clause.match);\n  }\n\n  // Enumerate the clauses in reverse order. Earlier matches will\n  // require fewer checks.\n  for (let i = clauses.length - 1; i >= 0; i--) {\n    let clause = unwrap(clauses[i]);\n\n    op(HighLevelBuilderOpcodes.Label, clause.label);\n    op(VM_POP_OP, 1);\n    clause.callback();\n\n    // The first match is special: it is placed directly before the END\n    // label, so no additional jump is needed at the end of it.\n    if (i !== 0) {\n      op(VM_JUMP_OP, labelOperand('END'));\n    }\n  }\n\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(HighLevelBuilderOpcodes.StopLabels);\n  op(VM_EXIT_OP);\n}\n\n/**\n * A convenience for pushing some arguments on the stack and\n * running some code if the code needs to be re-executed during\n * updating execution if some of the arguments have changed.\n *\n * # Initial Execution\n *\n * The `args` function should push zero or more arguments onto\n * the stack and return the number of arguments pushed.\n *\n * The `body` function provides the instructions to execute both\n * during initial execution and during updating execution.\n *\n * Internally, this function starts by pushing a new frame, so\n * that the body can return and sets the return point ($ra) to\n * the ENDINITIAL label.\n *\n * It then executes the `args` function, which adds instructions\n * responsible for pushing the arguments for the block to the\n * stack. These arguments will be restored to the stack before\n * updating execution.\n *\n * Next, it adds the Enter opcode, which marks the current position\n * in the DOM, and remembers the current $pc (the next instruction)\n * as the first instruction to execute during updating execution.\n *\n * Next, it runs `body`, which adds the opcodes that should\n * execute both during initial execution and during updating execution.\n * If the `body` wishes to finish early, it should Jump to the\n * `FINALLY` label.\n *\n * Next, it adds the FINALLY label, followed by:\n *\n * - the Exit opcode, which finalizes the marked DOM started by the\n *   Enter opcode.\n * - the Return opcode, which returns to the current return point\n *   ($ra).\n *\n * Finally, it adds the ENDINITIAL label followed by the PopFrame\n * instruction, which restores $fp, $sp and $ra.\n *\n * # Updating Execution\n *\n * Updating execution for this `replayable` occurs if the `body` added an\n * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.\n *\n * If, during updating executon, the assertion fails, the initial VM is\n * restored, and the stored arguments are pushed onto the stack. The DOM\n * between the starting and ending markers is cleared, and the VM's cursor\n * is set to the area just cleared.\n *\n * The return point ($ra) is set to -1, the exit instruction.\n *\n * Finally, the $pc is set to to the instruction saved off by the\n * Enter opcode during initial execution, and execution proceeds as\n * usual.\n *\n * The only difference is that when a `Return` instruction is\n * encountered, the program jumps to -1 rather than the END label,\n * and the PopFrame opcode is not needed.\n */\nexport function Replayable(op: PushStatementOp, args: () => number, body: () => void): void {\n  // Start a new label frame, to give END and RETURN\n  // a unique meaning.\n\n  op(HighLevelBuilderOpcodes.StartLabels);\n  op(VM_PUSH_FRAME_OP);\n\n  // If the body invokes a block, its return will return to\n  // END. Otherwise, the return in RETURN will return to END.\n  op(VM_RETURN_TO_OP, labelOperand('ENDINITIAL'));\n\n  // Push the arguments onto the stack. The args() function\n  // tells us how many stack elements to retain for re-execution\n  // when updating.\n  let count = args();\n\n  // Start a new updating closure, remembering `count` elements\n  // from the stack. Everything after this point, and before END,\n  // will execute both initially and to update the block.\n  //\n  // The enter and exit opcodes also track the area of the DOM\n  // associated with this block. If an assertion inside the block\n  // fails (for example, the test value changes from true to false\n  // in an #if), the DOM is cleared and the program is re-executed,\n  // restoring `count` elements to the stack and executing the\n  // instructions between the enter and exit.\n  op(VM_ENTER_OP, count);\n\n  // Evaluate the body of the block. The body of the block may\n  // return, which will jump execution to END during initial\n  // execution, and exit the updating routine.\n  body();\n\n  // All execution paths in the body should run the FINALLY once\n  // they are done. It is executed both during initial execution\n  // and during updating execution.\n  op(HighLevelBuilderOpcodes.Label, 'FINALLY');\n\n  // Finalize the DOM.\n  op(VM_EXIT_OP);\n\n  // In initial execution, this is a noop: it returns to the\n  // immediately following opcode. In updating execution, this\n  // exits the updating routine.\n  op(VM_RETURN_OP);\n\n  // Cleanup code for the block. Runs on initial execution\n  // but not on updating.\n  op(HighLevelBuilderOpcodes.Label, 'ENDINITIAL');\n  op(VM_POP_FRAME_OP);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\n/**\n * A specialized version of the `replayable` convenience that allows the\n * caller to provide different code based upon whether the item at\n * the top of the stack is true or false.\n *\n * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.\n *\n * During the initial execution, a `return` will continue execution\n * in the cleanup code, which finalizes the current DOM block and pops\n * the current frame.\n *\n * During the updating execution, a `return` will exit the updating\n * routine, as it can reuse the DOM block and is always only a single\n * frame deep.\n */\nexport function ReplayableIf(\n  op: PushStatementOp,\n  args: () => number,\n  ifTrue: () => void,\n  ifFalse?: () => void\n): void {\n  return Replayable(op, args, () => {\n    // If the conditional is false, jump to the ELSE label.\n    op(VM_JUMP_UNLESS_OP, labelOperand('ELSE'));\n    // Otherwise, execute the code associated with the true branch.\n    ifTrue();\n    // We're done, so return. In the initial execution, this runs\n    // the cleanup code. In the updating VM, it exits the updating\n    // routine.\n    op(VM_JUMP_OP, labelOperand('FINALLY'));\n    op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n    // If the conditional is false, and code associatied ith the\n    // false branch was provided, execute it. If there was no code\n    // associated with the false branch, jumping to the else statement\n    // has no other behavior.\n    if (ifFalse !== undefined) {\n      ifFalse();\n    }\n  });\n}\n","import type {\n  CapabilityMask,\n  CompilableProgram,\n  CompileTimeComponent,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport type { SavedRegister } from '@glimmer/vm';\nimport {\n  VM_BEGIN_COMPONENT_TRANSACTION_OP,\n  VM_CLOSE_ELEMENT_OP,\n  VM_COMMIT_COMPONENT_TRANSACTION_OP,\n  VM_COMPILE_BLOCK_OP,\n  VM_CONSTANT_OP,\n  VM_CREATE_COMPONENT_OP,\n  VM_DID_CREATE_ELEMENT_OP,\n  VM_DID_RENDER_LAYOUT_OP,\n  VM_DUP_OP,\n  VM_FETCH_OP,\n  VM_FLUSH_ELEMENT_OP,\n  VM_GET_COMPONENT_LAYOUT_OP,\n  VM_GET_COMPONENT_SELF_OP,\n  VM_GET_COMPONENT_TAG_NAME_OP,\n  VM_INVOKE_COMPONENT_LAYOUT_OP,\n  VM_INVOKE_VIRTUAL_OP,\n  VM_JUMP_UNLESS_OP,\n  VM_LOAD_OP,\n  VM_OPEN_DYNAMIC_ELEMENT_OP,\n  VM_POP_DYNAMIC_SCOPE_OP,\n  VM_POP_FRAME_OP,\n  VM_POP_OP,\n  VM_POP_SCOPE_OP,\n  VM_POPULATE_LAYOUT_OP,\n  VM_PREPARE_ARGS_OP,\n  VM_PRIMITIVE_REFERENCE_OP,\n  VM_PUSH_ARGS_OP,\n  VM_PUSH_COMPONENT_DEFINITION_OP,\n  VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP,\n  VM_PUSH_DYNAMIC_SCOPE_OP,\n  VM_PUSH_EMPTY_ARGS_OP,\n  VM_PUSH_FRAME_OP,\n  VM_PUSH_SYMBOL_TABLE_OP,\n  VM_PUT_COMPONENT_OPERATIONS_OP,\n  VM_REGISTER_COMPONENT_DESTRUCTOR_OP,\n  VM_RESOLVE_CURRIED_COMPONENT_OP,\n  VM_RESOLVE_DYNAMIC_COMPONENT_OP,\n  VM_ROOT_SCOPE_OP,\n  VM_SET_BLOCK_OP,\n  VM_SET_BLOCKS_OP,\n  VM_SET_NAMED_VARIABLES_OP,\n  VM_SET_VARIABLE_OP,\n  VM_VIRTUAL_ROOT_SCOPE_OP,\n} from '@glimmer/constants';\nimport { unwrap } from '@glimmer/debug-util';\nimport { hasCapability } from '@glimmer/manager';\nimport { EMPTY_STRING_ARRAY, reverse } from '@glimmer/util';\nimport { $s0, $s1, $sp, InternalComponentCapabilities } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { namedBlocks } from '../../utils';\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { isStrictMode, labelOperand, layoutOperand, symbolTableOperand } from '../operands';\nimport { InvokeStaticBlock, PushYieldableBlock, YieldBlock } from './blocks';\nimport { Replayable } from './conditional';\nimport { expr } from './expr';\nimport { CompileArgs, CompilePositional } from './shared';\n\nexport const ATTRS_BLOCK = '&attrs';\n\ninterface AnyComponent {\n  elementBlock: Nullable<WireFormat.SerializedInlineBlock>;\n  positional: WireFormat.Core.Params;\n  named: WireFormat.Core.Hash;\n  blocks: NamedBlocks;\n}\n\n// {{component}}\nexport interface DynamicComponent extends AnyComponent {\n  definition: WireFormat.Expression;\n  atNames: boolean;\n  curried: boolean;\n}\n\n// <Component>\nexport interface StaticComponent extends AnyComponent {\n  capabilities: CapabilityMask;\n  layout: CompilableProgram;\n}\n\n// chokepoint\nexport interface Component extends AnyComponent {\n  // either we know the capabilities statically or we need to be conservative and assume\n  // that the component requires all capabilities\n  capabilities: CapabilityMask | true;\n\n  // are the arguments supplied as atNames?\n  atNames: boolean;\n\n  // do we have the layout statically or will we need to look it up at runtime?\n  layout?: CompilableProgram;\n}\n\nexport function InvokeComponent(\n  op: PushStatementOp,\n  component: CompileTimeComponent,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks\n): void {\n  let { compilable, capabilities, handle } = component;\n\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = namedBlocks(_blocks);\n\n  if (compilable) {\n    op(VM_PUSH_COMPONENT_DEFINITION_OP, handle);\n    InvokeStaticComponent(op, {\n      capabilities: capabilities,\n      layout: compilable,\n      elementBlock,\n      positional,\n      named,\n      blocks,\n    });\n  } else {\n    op(VM_PUSH_COMPONENT_DEFINITION_OP, handle);\n    InvokeNonStaticComponent(op, {\n      capabilities: capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n    });\n  }\n}\n\nexport function InvokeDynamicComponent(\n  op: PushStatementOp,\n  definition: WireFormat.Core.Expression,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks,\n  atNames: boolean,\n  curried: boolean\n): void {\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = namedBlocks(_blocks);\n\n  Replayable(\n    op,\n\n    () => {\n      expr(op, definition);\n      op(VM_DUP_OP, $sp, 0);\n      return 2;\n    },\n\n    () => {\n      op(VM_JUMP_UNLESS_OP, labelOperand('ELSE'));\n\n      if (curried) {\n        op(VM_RESOLVE_CURRIED_COMPONENT_OP);\n      } else {\n        op(VM_RESOLVE_DYNAMIC_COMPONENT_OP, isStrictMode());\n      }\n\n      op(VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP);\n      InvokeNonStaticComponent(op, {\n        capabilities: true,\n        elementBlock,\n        positional,\n        named,\n        atNames,\n        blocks,\n      });\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n    }\n  );\n}\n\nfunction InvokeStaticComponent(\n  op: PushStatementOp,\n  { capabilities, layout, elementBlock, positional, named, blocks }: StaticComponent\n): void {\n  let { symbolTable } = layout;\n\n  let bailOut = hasCapability(capabilities, InternalComponentCapabilities.prepareArgs);\n\n  if (bailOut) {\n    InvokeNonStaticComponent(op, {\n      capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n      layout,\n    });\n\n    return;\n  }\n\n  op(VM_FETCH_OP, $s0);\n  op(VM_DUP_OP, $sp, 1);\n  op(VM_LOAD_OP, $s0);\n  op(VM_PUSH_FRAME_OP);\n\n  // Setup arguments\n  let { symbols } = symbolTable;\n\n  // As we push values onto the stack, we store the symbols associated  with them\n  // so that we can set them on the scope later on with SetVariable and SetBlock\n  let blockSymbols: number[] = [];\n  let argSymbols: number[] = [];\n  let argNames: string[] = [];\n\n  // First we push the blocks onto the stack\n  let blockNames = blocks.names;\n\n  // Starting with the attrs block, if it exists and is referenced in the component\n  if (elementBlock !== null) {\n    let symbol = symbols.indexOf(ATTRS_BLOCK);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, elementBlock);\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Followed by the other blocks, if they exist and are referenced in the component.\n  // Also store the index of the associated symbol.\n  for (const name of blockNames) {\n    let symbol = symbols.indexOf(`&${name}`);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, blocks.get(name));\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Next up we have arguments. If the component has the `createArgs` capability,\n  // then it wants access to the arguments in JavaScript. We can't know whether\n  // or not an argument is used, so we have to give access to all of them.\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    // First we push positional arguments\n    let count = CompilePositional(op, positional);\n\n    // setup the flags with the count of positionals, and to indicate that atNames\n    // are used\n    let flags = count << 4;\n    flags |= 0b1000;\n\n    let names: string[] = EMPTY_STRING_ARRAY;\n\n    // Next, if named args exist, push them all. If they have an associated symbol\n    // in the invoked component (e.g. they are used within its template), we push\n    // that symbol. If not, we still push the expression as it may be used, and\n    // we store the symbol as -1 (this is used later).\n    if (named !== null) {\n      names = named[0];\n      let val = named[1];\n\n      for (let i = 0; i < val.length; i++) {\n        let symbol = symbols.indexOf(unwrap(names[i]));\n\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n      }\n    }\n\n    // Finally, push the VM arguments themselves. These args won't need access\n    // to blocks (they aren't accessible from userland anyways), so we push an\n    // empty array instead of the actual block names.\n    op(VM_PUSH_ARGS_OP, names, EMPTY_STRING_ARRAY, flags);\n\n    // And push an extra pop operation to remove the args before we begin setting\n    // variables on the local context\n    argSymbols.push(-1);\n  } else if (named !== null) {\n    // If the component does not have the `createArgs` capability, then the only\n    // expressions we need to push onto the stack are those that are actually\n    // referenced in the template of the invoked component (e.g. have symbols).\n    let names = named[0];\n    let val = named[1];\n\n    for (let i = 0; i < val.length; i++) {\n      let name = unwrap(names[i]);\n      let symbol = symbols.indexOf(name);\n\n      if (symbol !== -1) {\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n        argNames.push(name);\n      }\n    }\n  }\n\n  op(VM_BEGIN_COMPONENT_TRANSACTION_OP, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(VM_PUSH_DYNAMIC_SCOPE_OP);\n  }\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createInstance)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    op(VM_CREATE_COMPONENT_OP, (blocks.has('default') as any) | 0);\n  }\n\n  op(VM_REGISTER_COMPONENT_DESTRUCTOR_OP, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    op(VM_GET_COMPONENT_SELF_OP, $s0);\n  } else {\n    op(VM_GET_COMPONENT_SELF_OP, $s0, argNames);\n  }\n\n  // Setup the new root scope for the component\n  op(VM_ROOT_SCOPE_OP, symbols.length + 1, Object.keys(blocks).length > 0 ? 1 : 0);\n\n  // Pop the self reference off the stack and set it to the symbol for `this`\n  // in the new scope. This is why all subsequent symbols are increased by one.\n  op(VM_SET_VARIABLE_OP, 0);\n\n  // Going in reverse, now we pop the args/blocks off the stack, starting with\n  // arguments, and assign them to their symbols in the new scope.\n  for (const symbol of reverse(argSymbols)) {\n    // for (let i = argSymbols.length - 1; i >= 0; i--) {\n    //   let symbol = argSymbols[i];\n\n    if (symbol === -1) {\n      // The expression was not bound to a local symbol, it was only pushed to be\n      // used with VM args in the javascript side\n      op(VM_POP_OP, 1);\n    } else {\n      op(VM_SET_VARIABLE_OP, symbol + 1);\n    }\n  }\n\n  // if any positional params exist, pop them off the stack as well\n  if (positional !== null) {\n    op(VM_POP_OP, positional.length);\n  }\n\n  // Finish up by popping off and assigning blocks\n  for (const symbol of reverse(blockSymbols)) {\n    op(VM_SET_BLOCK_OP, symbol + 1);\n  }\n\n  op(VM_CONSTANT_OP, layoutOperand(layout));\n  op(VM_COMPILE_BLOCK_OP);\n  op(VM_INVOKE_VIRTUAL_OP);\n  op(VM_DID_RENDER_LAYOUT_OP, $s0);\n\n  op(VM_POP_FRAME_OP);\n  op(VM_POP_SCOPE_OP);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(VM_POP_DYNAMIC_SCOPE_OP);\n  }\n\n  op(VM_COMMIT_COMPONENT_TRANSACTION_OP);\n  op(VM_LOAD_OP, $s0);\n}\n\nexport function InvokeNonStaticComponent(\n  op: PushStatementOp,\n  { capabilities, elementBlock, positional, named, atNames, blocks: namedBlocks, layout }: Component\n): void {\n  let bindableBlocks = !!namedBlocks;\n  let bindableAtNames =\n    capabilities === true ||\n    hasCapability(capabilities, InternalComponentCapabilities.prepareArgs) ||\n    !!(named && named[0].length !== 0);\n\n  let blocks = namedBlocks.with('attrs', elementBlock);\n\n  op(VM_FETCH_OP, $s0);\n  op(VM_DUP_OP, $sp, 1);\n  op(VM_LOAD_OP, $s0);\n\n  op(VM_PUSH_FRAME_OP);\n  CompileArgs(op, positional, named, blocks, atNames);\n  op(VM_PREPARE_ARGS_OP, $s0);\n\n  invokePreparedComponent(op, blocks.has('default'), bindableBlocks, bindableAtNames, () => {\n    if (layout) {\n      op(VM_PUSH_SYMBOL_TABLE_OP, symbolTableOperand(layout.symbolTable));\n      op(VM_CONSTANT_OP, layoutOperand(layout));\n      op(VM_COMPILE_BLOCK_OP);\n    } else {\n      op(VM_GET_COMPONENT_LAYOUT_OP, $s0);\n    }\n\n    op(VM_POPULATE_LAYOUT_OP, $s0);\n  });\n\n  op(VM_LOAD_OP, $s0);\n}\n\nexport function WrappedComponent(\n  op: PushStatementOp,\n  layout: LayoutWithContext,\n  attrsBlockNumber: number\n): void {\n  op(HighLevelBuilderOpcodes.StartLabels);\n  WithSavedRegister(op, $s1, () => {\n    op(VM_GET_COMPONENT_TAG_NAME_OP, $s0);\n    op(VM_PRIMITIVE_REFERENCE_OP);\n    op(VM_DUP_OP, $sp, 0);\n  });\n  op(VM_JUMP_UNLESS_OP, labelOperand('BODY'));\n  op(VM_FETCH_OP, $s1);\n  op(VM_PUT_COMPONENT_OPERATIONS_OP);\n  op(VM_OPEN_DYNAMIC_ELEMENT_OP);\n  op(VM_DID_CREATE_ELEMENT_OP, $s0);\n  YieldBlock(op, attrsBlockNumber, null);\n  op(VM_FLUSH_ELEMENT_OP);\n  op(HighLevelBuilderOpcodes.Label, 'BODY');\n  InvokeStaticBlock(op, [layout.block[0], []]);\n  op(VM_FETCH_OP, $s1);\n  op(VM_JUMP_UNLESS_OP, labelOperand('END'));\n  op(VM_CLOSE_ELEMENT_OP);\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(VM_LOAD_OP, $s1);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\nexport function invokePreparedComponent(\n  op: PushStatementOp,\n  hasBlock: boolean,\n  bindableBlocks: boolean,\n  bindableAtNames: boolean,\n  populateLayout: Nullable<() => void> = null\n): void {\n  op(VM_BEGIN_COMPONENT_TRANSACTION_OP, $s0);\n  op(VM_PUSH_DYNAMIC_SCOPE_OP);\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  op(VM_CREATE_COMPONENT_OP, (hasBlock as any) | 0);\n\n  // this has to run after createComponent to allow\n  // for late-bound layouts, but a caller is free\n  // to populate the layout earlier if it wants to\n  // and do nothing here.\n  if (populateLayout) {\n    populateLayout();\n  }\n\n  op(VM_REGISTER_COMPONENT_DESTRUCTOR_OP, $s0);\n  op(VM_GET_COMPONENT_SELF_OP, $s0);\n\n  op(VM_VIRTUAL_ROOT_SCOPE_OP, $s0);\n  op(VM_SET_VARIABLE_OP, 0);\n\n  if (bindableAtNames) op(VM_SET_NAMED_VARIABLES_OP, $s0);\n  if (bindableBlocks) op(VM_SET_BLOCKS_OP, $s0);\n\n  op(VM_POP_OP, 1);\n  op(VM_INVOKE_COMPONENT_LAYOUT_OP, $s0);\n  op(VM_DID_RENDER_LAYOUT_OP, $s0);\n  op(VM_POP_FRAME_OP);\n\n  op(VM_POP_SCOPE_OP);\n  op(VM_POP_DYNAMIC_SCOPE_OP);\n  op(VM_COMMIT_COMPONENT_TRANSACTION_OP);\n}\n\nexport function InvokeBareComponent(op: PushStatementOp): void {\n  op(VM_FETCH_OP, $s0);\n  op(VM_DUP_OP, $sp, 1);\n  op(VM_LOAD_OP, $s0);\n\n  op(VM_PUSH_FRAME_OP);\n  op(VM_PUSH_EMPTY_ARGS_OP);\n  op(VM_PREPARE_ARGS_OP, $s0);\n  invokePreparedComponent(op, false, false, true, () => {\n    op(VM_GET_COMPONENT_LAYOUT_OP, $s0);\n    op(VM_POPULATE_LAYOUT_OP, $s0);\n  });\n  op(VM_LOAD_OP, $s0);\n}\n\nexport function WithSavedRegister(\n  op: PushExpressionOp,\n  register: SavedRegister,\n  block: () => void\n): void {\n  op(VM_FETCH_OP, register);\n  block();\n  op(VM_LOAD_OP, register);\n}\n","import type {\n  CompileTimeComponent,\n  StatementSexpOpcode,\n  WellKnownAttrName,\n  WellKnownTagName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport {\n  VM_CLOSE_ELEMENT_OP,\n  VM_COMMENT_OP,\n  VM_COMPONENT_ATTR_OP,\n  VM_CONSTANT_REFERENCE_OP,\n  VM_DEBUGGER_OP,\n  VM_DUP_OP,\n  VM_DYNAMIC_ATTR_OP,\n  VM_DYNAMIC_CONTENT_TYPE_OP,\n  VM_DYNAMIC_MODIFIER_OP,\n  VM_ENTER_LIST_OP,\n  VM_EXIT_LIST_OP,\n  VM_FLUSH_ELEMENT_OP,\n  VM_INVOKE_STATIC_OP,\n  VM_ITERATE_OP,\n  VM_JUMP_OP,\n  VM_MODIFIER_OP,\n  VM_OPEN_ELEMENT_OP,\n  VM_POP_FRAME_OP,\n  VM_POP_OP,\n  VM_POP_REMOTE_ELEMENT_OP,\n  VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP,\n  VM_PUSH_FRAME_OP,\n  VM_PUSH_REMOTE_ELEMENT_OP,\n  VM_PUT_COMPONENT_OPERATIONS_OP,\n  VM_RESOLVE_CURRIED_COMPONENT_OP,\n  VM_RETURN_TO_OP,\n  VM_STATIC_ATTR_OP,\n  VM_STATIC_COMPONENT_ATTR_OP,\n  VM_TEXT_OP,\n  VM_TO_BOOLEAN_OP,\n} from '@glimmer/constants';\nimport { $fp, $sp, ContentType } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushStatementOp } from './compilers';\n\nimport {\n  InvokeStaticBlock,\n  InvokeStaticBlockWithStack,\n  YieldBlock,\n} from '../opcode-builder/helpers/blocks';\nimport {\n  InvokeComponent,\n  InvokeDynamicComponent,\n  InvokeNonStaticComponent,\n} from '../opcode-builder/helpers/components';\nimport { Replayable, ReplayableIf, SwitchCases } from '../opcode-builder/helpers/conditional';\nimport { expr } from '../opcode-builder/helpers/expr';\nimport {\n  isGetFreeComponent,\n  isGetFreeComponentOrHelper,\n  isGetFreeModifier,\n} from '../opcode-builder/helpers/resolution';\nimport { CompilePositional, SimpleArgs } from '../opcode-builder/helpers/shared';\nimport {\n  Call,\n  CallDynamic,\n  DynamicScope,\n  PushPrimitiveReference,\n} from '../opcode-builder/helpers/vm';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { debugSymbolsOperand, labelOperand, stdlibOperand } from '../opcode-builder/operands';\nimport { namedBlocks } from '../utils';\nimport { Compilers } from './compilers';\n\nexport const STATEMENTS = new Compilers<PushStatementOp, StatementSexpOpcode>();\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n\nSTATEMENTS.add(SexpOpcodes.Comment, (op, sexp) => op(VM_COMMENT_OP, sexp[1]));\nSTATEMENTS.add(SexpOpcodes.CloseElement, (op) => op(VM_CLOSE_ELEMENT_OP));\nSTATEMENTS.add(SexpOpcodes.FlushElement, (op) => op(VM_FLUSH_ELEMENT_OP));\n\nSTATEMENTS.add(SexpOpcodes.Modifier, (op, [, expression, positional, named]) => {\n  if (isGetFreeModifier(expression)) {\n    op(HighLevelResolutionOpcodes.Modifier, expression, (handle: number) => {\n      op(VM_PUSH_FRAME_OP);\n      SimpleArgs(op, positional, named, false);\n      op(VM_MODIFIER_OP, handle);\n      op(VM_POP_FRAME_OP);\n    });\n  } else {\n    expr(op, expression);\n    op(VM_PUSH_FRAME_OP);\n    SimpleArgs(op, positional, named, false);\n    op(VM_DUP_OP, $fp, 1);\n    op(VM_DYNAMIC_MODIFIER_OP);\n    op(VM_POP_FRAME_OP);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticAttr, (op, [, name, value, namespace]) => {\n  op(VM_STATIC_ATTR_OP, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticComponentAttr, (op, [, name, value, namespace]) => {\n  op(VM_STATIC_COMPONENT_ATTR_OP, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.DynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(VM_DYNAMIC_ATTR_OP, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingDynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(VM_DYNAMIC_ATTR_OP, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.ComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(VM_COMPONENT_ATTR_OP, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(VM_COMPONENT_ATTR_OP, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElement, (op, [, tag]) => {\n  op(VM_OPEN_ELEMENT_OP, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElementWithSplat, (op, [, tag]) => {\n  op(VM_PUT_COMPONENT_OPERATIONS_OP);\n  op(VM_OPEN_ELEMENT_OP, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.Component, (op, [, expr, elementBlock, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, elementBlock, null, named, blocks);\n    });\n  } else {\n    // otherwise, the component name was an expression, so resolve the expression\n    // and invoke it as a dynamic component\n    InvokeDynamicComponent(op, expr, elementBlock, null, named, blocks, true, true);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Yield, (op, [, to, params]) => YieldBlock(op, to, params));\n\nSTATEMENTS.add(SexpOpcodes.AttrSplat, (op, [, to]) => YieldBlock(op, to, null));\n\nSTATEMENTS.add(SexpOpcodes.Debugger, (op, [, locals, upvars, lexical]) => {\n  op(VM_DEBUGGER_OP, debugSymbolsOperand(locals, upvars, lexical));\n});\n\nSTATEMENTS.add(SexpOpcodes.Append, (op, [, value]) => {\n  // Special case for static values\n  if (!Array.isArray(value)) {\n    op(VM_TEXT_OP, value === null || value === undefined ? '' : String(value));\n  } else if (isGetFreeComponentOrHelper(value)) {\n    op(HighLevelResolutionOpcodes.OptionalComponentOrHelper, value, {\n      ifComponent(component: CompileTimeComponent) {\n        InvokeComponent(op, component, null, null, null, null);\n      },\n\n      ifHelper(handle: number) {\n        op(VM_PUSH_FRAME_OP);\n        Call(op, handle, null, null);\n        op(VM_INVOKE_STATIC_OP, stdlibOperand('cautious-non-dynamic-append'));\n        op(VM_POP_FRAME_OP);\n      },\n\n      ifValue(handle: number) {\n        op(VM_PUSH_FRAME_OP);\n        op(VM_CONSTANT_REFERENCE_OP, handle);\n        op(VM_INVOKE_STATIC_OP, stdlibOperand('cautious-non-dynamic-append'));\n        op(VM_POP_FRAME_OP);\n      },\n    });\n  } else if (value[0] === SexpOpcodes.Call) {\n    let [, expression, positional, named] = value;\n\n    if (isGetFreeComponentOrHelper(expression)) {\n      op(HighLevelResolutionOpcodes.ComponentOrHelper, expression, {\n        ifComponent(component: CompileTimeComponent) {\n          InvokeComponent(op, component, null, positional, hashToArgs(named), null);\n        },\n        ifHelper(handle: number) {\n          op(VM_PUSH_FRAME_OP);\n          Call(op, handle, positional, named);\n          op(VM_INVOKE_STATIC_OP, stdlibOperand('cautious-non-dynamic-append'));\n          op(VM_POP_FRAME_OP);\n        },\n      });\n    } else {\n      SwitchCases(\n        op,\n        () => {\n          expr(op, expression);\n          op(VM_DYNAMIC_CONTENT_TYPE_OP);\n        },\n        (when) => {\n          when(ContentType.Component, () => {\n            op(VM_RESOLVE_CURRIED_COMPONENT_OP);\n            op(VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP);\n            InvokeNonStaticComponent(op, {\n              capabilities: true,\n              elementBlock: null,\n              positional,\n              named,\n              atNames: false,\n              blocks: namedBlocks(null),\n            });\n          });\n\n          when(ContentType.Helper, () => {\n            CallDynamic(op, positional, named, () => {\n              op(VM_INVOKE_STATIC_OP, stdlibOperand('cautious-non-dynamic-append'));\n            });\n          });\n        }\n      );\n    }\n  } else {\n    op(VM_PUSH_FRAME_OP);\n    expr(op, value);\n    op(VM_INVOKE_STATIC_OP, stdlibOperand('cautious-append'));\n    op(VM_POP_FRAME_OP);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingAppend, (op, [, value]) => {\n  if (!Array.isArray(value)) {\n    op(VM_TEXT_OP, value === null || value === undefined ? '' : String(value));\n  } else {\n    op(VM_PUSH_FRAME_OP);\n    expr(op, value);\n    op(VM_INVOKE_STATIC_OP, stdlibOperand('trusting-append'));\n    op(VM_POP_FRAME_OP);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Block, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InElement, (op, [, block, guid, destination, insertBefore]) => {\n  ReplayableIf(\n    op,\n\n    () => {\n      expr(op, guid);\n\n      if (insertBefore === undefined) {\n        PushPrimitiveReference(op, undefined);\n      } else {\n        expr(op, insertBefore);\n      }\n\n      expr(op, destination);\n      op(VM_DUP_OP, $sp, 0);\n\n      return 4;\n    },\n\n    () => {\n      op(VM_PUSH_REMOTE_ELEMENT_OP);\n      InvokeStaticBlock(op, block);\n      op(VM_POP_REMOTE_ELEMENT_OP);\n    }\n  );\n});\n\nSTATEMENTS.add(SexpOpcodes.If, (op, [, condition, block, inverse]) =>\n  ReplayableIf(\n    op,\n    () => {\n      expr(op, condition);\n      op(VM_TO_BOOLEAN_OP);\n\n      return 1;\n    },\n\n    () => {\n      InvokeStaticBlock(op, block);\n    },\n\n    inverse\n      ? () => {\n          InvokeStaticBlock(op, inverse);\n        }\n      : undefined\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Each, (op, [, value, key, block, inverse]) =>\n  Replayable(\n    op,\n\n    () => {\n      if (key) {\n        expr(op, key);\n      } else {\n        PushPrimitiveReference(op, null);\n      }\n\n      expr(op, value);\n\n      return 2;\n    },\n\n    () => {\n      op(VM_ENTER_LIST_OP, labelOperand('BODY'), labelOperand('ELSE'));\n      op(VM_PUSH_FRAME_OP);\n      op(VM_DUP_OP, $fp, 1);\n      op(VM_RETURN_TO_OP, labelOperand('ITER'));\n      op(HighLevelBuilderOpcodes.Label, 'ITER');\n      op(VM_ITERATE_OP, labelOperand('BREAK'));\n      op(HighLevelBuilderOpcodes.Label, 'BODY');\n      InvokeStaticBlockWithStack(op, block, 2);\n      op(VM_POP_OP, 2);\n      op(VM_JUMP_OP, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'BREAK');\n      op(VM_POP_FRAME_OP);\n      op(VM_EXIT_LIST_OP);\n      op(VM_JUMP_OP, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n      if (inverse) {\n        InvokeStaticBlock(op, inverse);\n      }\n    }\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Let, (op, [, positional, block]) => {\n  let count = CompilePositional(op, positional);\n  InvokeStaticBlockWithStack(op, block, count);\n});\n\nSTATEMENTS.add(SexpOpcodes.WithDynamicVars, (op, [, named, block]) => {\n  if (named) {\n    let [names, expressions] = named;\n\n    CompilePositional(op, expressions);\n    DynamicScope(op, names, () => {\n      InvokeStaticBlock(op, block);\n    });\n  } else {\n    InvokeStaticBlock(op, block);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InvokeComponent, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nfunction hashToArgs(hash: WireFormat.Core.Hash | null): WireFormat.Core.Hash | null {\n  if (hash === null) return null;\n  let names = hash[0].map((key) => `@${key}`);\n  return [names as [string, ...string[]], hash[1]];\n}\n","import type {\n  CompileTimeComponent,\n  InternalComponentCapabilities,\n  Nullable,\n} from '@glimmer/interfaces';\n\nexport const DEFAULT_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: true,\n  dynamicTag: true,\n  prepareArgs: true,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: true,\n  createCaller: false,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport const MINIMAL_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: false,\n  createCaller: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport interface ResolverDelegate<R = unknown> {\n  lookupHelper?(name: string, referrer: R): Nullable<number> | void;\n  lookupModifier?(name: string, referrer: R): Nullable<number> | void;\n  lookupComponent?(name: string, referrer: R): Nullable<CompileTimeComponent> | void;\n\n  // For debugging\n  resolve?(handle: number): R;\n}\n","export class StdLib {\n  constructor(\n    public main: number,\n    private trustingGuardedAppend: number,\n    private cautiousGuardedAppend: number,\n    private trustingNonDynamicAppend: number,\n    private cautiousNonDynamicAppend: number\n  ) {}\n\n  get 'trusting-append'() {\n    return this.trustingGuardedAppend;\n  }\n\n  get 'cautious-append'() {\n    return this.cautiousGuardedAppend;\n  }\n\n  get 'trusting-non-dynamic-append'() {\n    return this.trustingNonDynamicAppend;\n  }\n\n  get 'cautious-non-dynamic-append'() {\n    return this.cautiousNonDynamicAppend;\n  }\n\n  getAppend(trusting: boolean) {\n    return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;\n  }\n}\n","import type { BlockMetadata, BuilderOp, EvaluationContext, HighLevelOp } from '@glimmer/interfaces';\nimport {\n  VM_APPEND_DOCUMENT_FRAGMENT_OP,\n  VM_APPEND_HTML_OP,\n  VM_APPEND_NODE_OP,\n  VM_APPEND_SAFE_HTML_OP,\n  VM_APPEND_TEXT_OP,\n  VM_ASSERT_SAME_OP,\n  VM_CONTENT_TYPE_OP,\n  VM_INVOKE_STATIC_OP,\n  VM_MAIN_OP,\n  VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP,\n  VM_RESOLVE_CURRIED_COMPONENT_OP,\n} from '@glimmer/constants';\nimport { $s0, ContentType } from '@glimmer/vm';\n\nimport type { HighLevelStatementOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { encodeOp, EncoderImpl } from '../encoder';\nimport { StdLib } from '../stdlib';\nimport { InvokeBareComponent, invokePreparedComponent } from './components';\nimport { SwitchCases } from './conditional';\nimport { CallDynamic } from './vm';\n\nexport function main(op: PushStatementOp): void {\n  op(VM_MAIN_OP, $s0);\n  invokePreparedComponent(op, false, false, true);\n}\n\n/**\n * Append content to the DOM. This standard function triages content and does the\n * right thing based upon whether it's a string, safe string, component, fragment\n * or node.\n *\n * @param trusting whether to interpolate a string as raw HTML (corresponds to\n * triple curlies)\n */\nexport function StdAppend(\n  op: PushStatementOp,\n  trusting: boolean,\n  nonDynamicAppend: number | null\n): void {\n  SwitchCases(\n    op,\n    () => op(VM_CONTENT_TYPE_OP),\n    (when) => {\n      when(ContentType.String, () => {\n        if (trusting) {\n          op(VM_ASSERT_SAME_OP);\n          op(VM_APPEND_HTML_OP);\n        } else {\n          op(VM_APPEND_TEXT_OP);\n        }\n      });\n\n      if (typeof nonDynamicAppend === 'number') {\n        when(ContentType.Component, () => {\n          op(VM_RESOLVE_CURRIED_COMPONENT_OP);\n          op(VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP);\n          InvokeBareComponent(op);\n        });\n\n        when(ContentType.Helper, () => {\n          CallDynamic(op, null, null, () => {\n            op(VM_INVOKE_STATIC_OP, nonDynamicAppend);\n          });\n        });\n      } else {\n        // when non-dynamic, we can no longer call the value (potentially because we've already called it)\n        // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.\n        when(ContentType.Component, () => {\n          op(VM_APPEND_TEXT_OP);\n        });\n\n        when(ContentType.Helper, () => {\n          op(VM_APPEND_TEXT_OP);\n        });\n      }\n\n      when(ContentType.SafeString, () => {\n        op(VM_ASSERT_SAME_OP);\n        op(VM_APPEND_SAFE_HTML_OP);\n      });\n\n      when(ContentType.Fragment, () => {\n        op(VM_ASSERT_SAME_OP);\n        op(VM_APPEND_DOCUMENT_FRAGMENT_OP);\n      });\n\n      when(ContentType.Node, () => {\n        op(VM_ASSERT_SAME_OP);\n        op(VM_APPEND_NODE_OP);\n      });\n    }\n  );\n}\n\nexport function compileStd(context: EvaluationContext): StdLib {\n  let mainHandle = build(context, (op) => main(op));\n  let trustingGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, true, null));\n  let cautiousGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, false, null));\n\n  let trustingGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, true, trustingGuardedNonDynamicAppend)\n  );\n  let cautiousGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, false, cautiousGuardedNonDynamicAppend)\n  );\n\n  return new StdLib(\n    mainHandle,\n    trustingGuardedDynamicAppend,\n    cautiousGuardedDynamicAppend,\n    trustingGuardedNonDynamicAppend,\n    cautiousGuardedNonDynamicAppend\n  );\n}\n\nexport const STDLIB_META: BlockMetadata = {\n  symbols: {\n    locals: null,\n    upvars: null,\n  },\n  moduleName: 'stdlib',\n\n  // TODO: ??\n  scopeValues: null,\n  isStrictMode: true,\n  owner: null,\n  size: 0,\n};\n\nfunction build(evaluation: EvaluationContext, builder: (op: PushStatementOp) => void): number {\n  let encoder = new EncoderImpl(evaluation.program.heap, STDLIB_META);\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, evaluation, STDLIB_META, op as BuilderOp | HighLevelOp);\n  }\n\n  builder(pushOp);\n\n  let result = encoder.commit(0);\n\n  if (typeof result !== 'number') {\n    // This shouldn't be possible\n    throw new Error(`Unexpected errors compiling std`);\n  } else {\n    return result;\n  }\n}\n","import type {\n  ClassicResolver,\n  CreateRuntimeOp,\n  Environment,\n  EvaluationContext,\n  Nullable,\n  Program,\n  ProgramConstants,\n  ProgramHeap,\n  RuntimeArtifacts,\n  RuntimeOptions,\n  STDLib,\n} from '@glimmer/interfaces';\n\nimport { compileStd } from './opcode-builder/helpers/stdlib';\n\nexport class EvaluationContextImpl implements EvaluationContext {\n  readonly constants: ProgramConstants;\n  readonly heap: ProgramHeap;\n  readonly resolver: Nullable<ClassicResolver>;\n  readonly stdlib: STDLib;\n  readonly createOp: CreateRuntimeOp;\n  readonly env: Environment;\n  readonly program: Program;\n\n  constructor(\n    { constants, heap }: RuntimeArtifacts,\n    createOp: CreateRuntimeOp,\n    runtime: RuntimeOptions\n  ) {\n    this.constants = constants;\n    this.heap = heap;\n    this.resolver = runtime.resolver;\n    this.createOp = createOp;\n    this.env = runtime.env;\n    this.program = runtime.program;\n\n    this.stdlib = compileStd(this);\n  }\n}\n","import type {\n  BlockMetadata,\n  BuilderOp,\n  CompilableProgram,\n  EvaluationContext,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  ProgramSymbolTable,\n} from '@glimmer/interfaces';\nimport { LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { ATTRS_BLOCK, WrappedComponent } from './opcode-builder/helpers/components';\nimport { meta } from './opcode-builder/helpers/shared';\n\nexport class WrappedBuilder implements CompilableProgram {\n  public symbolTable: ProgramSymbolTable;\n  private compiled: Nullable<number> = null;\n  private attrsBlockNumber: number;\n  readonly meta: BlockMetadata;\n\n  constructor(\n    private readonly layout: LayoutWithContext,\n    public moduleName: string\n  ) {\n    let { block } = layout;\n    let [, symbols] = block;\n\n    symbols = symbols.slice();\n\n    // ensure ATTRS_BLOCK is always included (only once) in the list of symbols\n    let attrsBlockIndex = symbols.indexOf(ATTRS_BLOCK);\n    if (attrsBlockIndex === -1) {\n      this.attrsBlockNumber = symbols.push(ATTRS_BLOCK);\n    } else {\n      this.attrsBlockNumber = attrsBlockIndex + 1;\n    }\n\n    this.symbolTable = {\n      symbols,\n    };\n\n    this.meta = meta(layout);\n  }\n\n  compile(syntax: EvaluationContext): HandleResult {\n    if (this.compiled !== null) return this.compiled;\n\n    let m = meta(this.layout);\n    let context = templateCompilationContext(syntax, m);\n\n    let { encoder, evaluation } = context;\n\n    function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n      encodeOp(encoder, evaluation, m, op as BuilderOp | HighLevelOp);\n    }\n\n    WrappedComponent(pushOp, this.layout, this.attrsBlockNumber);\n\n    let handle = context.encoder.commit(m.size);\n\n    if (typeof handle !== 'number') {\n      return handle;\n    }\n\n    this.compiled = handle;\n\n    if (LOCAL_TRACE_LOGGING) {\n      debugCompiler(context, handle);\n    }\n\n    return handle;\n  }\n}\n","import type {\n  CompilableProgram,\n  Initializable,\n  LayoutWithContext,\n  Nullable,\n  Owner,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  Template,\n  TemplateFactory,\n  TemplateOk,\n} from '@glimmer/interfaces';\nimport { assign } from '@glimmer/util';\n\nimport { compilable } from './compilable-template';\nimport { WrappedBuilder } from './wrapped-component';\n\nlet clientId = 0;\n\nexport let templateCacheCounters = {\n  cacheHit: 0,\n  cacheMiss: 0,\n};\n\n// These interfaces are for backwards compatibility, some addons use these intimate APIs\nexport interface TemplateFactoryWithIdAndMeta extends TemplateFactory {\n  __id?: string;\n  __meta?: { moduleName: string };\n}\n\nexport interface TemplateWithIdAndReferrer extends TemplateOk {\n  id: string;\n  referrer: {\n    moduleName: string;\n    owner: Owner | null;\n  };\n}\n\n/**\n * Wraps a template js in a template module to change it into a factory\n * that handles lazy parsing the template and to create per env singletons\n * of the template.\n */\nexport default function templateFactory({\n  id: templateId,\n  moduleName,\n  block,\n  scope,\n  isStrictMode,\n}: SerializedTemplateWithLazyBlock): TemplateFactory {\n  // TODO(template-refactors): This should be removed in the near future, as it\n  // appears that id is unused. It is currently kept for backwards compat reasons.\n  let id = templateId || `client-${clientId++}`;\n\n  // TODO: This caches JSON serialized output once in case a template is\n  // compiled by multiple owners, but we haven't verified if this is actually\n  // helpful. We should benchmark this in the future.\n  let parsedBlock: Initializable<SerializedTemplateBlock>;\n\n  let ownerlessTemplate: Template | null = null;\n  let templateCache = new WeakMap<object, Template>();\n\n  let factory: TemplateFactoryWithIdAndMeta = (owner?: Owner) => {\n    if (parsedBlock === undefined) {\n      parsedBlock = JSON.parse(block) as SerializedTemplateBlock;\n    }\n\n    if (owner === undefined) {\n      if (ownerlessTemplate === null) {\n        templateCacheCounters.cacheMiss++;\n        ownerlessTemplate = new TemplateImpl({\n          id,\n          block: parsedBlock,\n          moduleName,\n          owner: null,\n          scope,\n          isStrictMode,\n        });\n      } else {\n        templateCacheCounters.cacheHit++;\n      }\n\n      return ownerlessTemplate;\n    }\n\n    let result = templateCache.get(owner);\n\n    if (result === undefined) {\n      templateCacheCounters.cacheMiss++;\n      result = new TemplateImpl({ id, block: parsedBlock, moduleName, owner, scope, isStrictMode });\n      templateCache.set(owner, result);\n    } else {\n      templateCacheCounters.cacheHit++;\n    }\n\n    return result;\n  };\n\n  factory.__id = id;\n  factory.__meta = { moduleName };\n\n  return factory;\n}\n\nclass TemplateImpl implements TemplateWithIdAndReferrer {\n  readonly result = 'ok';\n\n  private layout: Nullable<CompilableProgram> = null;\n  private wrappedLayout: Nullable<CompilableProgram> = null;\n\n  constructor(private parsedLayout: LayoutWithContext) {}\n\n  get moduleName() {\n    return this.parsedLayout.moduleName;\n  }\n\n  get id() {\n    return this.parsedLayout.id;\n  }\n\n  // TODO(template-refactors): This should be removed in the near future, it is\n  // only being exposed for backwards compatibility\n  get referrer() {\n    return {\n      moduleName: this.parsedLayout.moduleName,\n      owner: this.parsedLayout.owner,\n    };\n  }\n\n  asLayout(): CompilableProgram {\n    if (this.layout) return this.layout;\n    return (this.layout = compilable(assign({}, this.parsedLayout), this.moduleName));\n  }\n\n  asWrappedLayout(): CompilableProgram {\n    if (this.wrappedLayout) return this.wrappedLayout;\n    return (this.wrappedLayout = new WrappedBuilder(\n      assign({}, this.parsedLayout),\n      this.moduleName\n    ));\n  }\n}\n"],"names":["SIGN_BIT","encodeImmediate","num","encodeNegative","encodePositive","forEach","x","decodeImmediate","decodePositive","decodeNegative","VM_DUP_OP","VM_POP_OP","VM_LOAD_OP","VM_FETCH_OP","VM_COMPILE_BLOCK_OP","debugCompiler","makeResolutionTypeVerifier","typeToVerify","opcode","Array","isArray","length","isGetLikeTuple","type","SexpOpcodes","GetStrictKeyword","GetLexicalSymbol","isGetFreeComponent","GetFreeAsComponentHead","isGetFreeModifier","GetFreeAsModifierHead","isGetFreeHelper","GetFreeAsHelperHead","isGetFreeComponentOrHelper","GetFreeAsComponentOrHelperHead","lookupBuiltInHelper","expr","resolver","meta","constants","symbols","upvars","name","helper","HighLevelResolutionOpcodes","HighLevelBuilderOpcodes","labelOperand","value","stdlibOperand","symbolTableOperand","layoutOperand","Labels","label","index","this","labels","target","at","targets","push","patch","heap","address","getbyaddr","setbyaddr","dict","encodeOp","encoder","context","op","program","isBuilderOpcode","operands","startLabels","stopLabels","then","scopeValues","owner","lexical","definition","component","lookupComponent","resolvedComponent","resolveComponent","modifier","undefined","lookupBuiltInModifier","lookupModifier","resolveModifier","lookupHelper","resolveHelper","ifComponent","ifHelper","resolveComponentOrHelper","ifValue","resolveOptionalComponentOrHelper","freeVar","andThen","moduleName","valueIndex","Error","EncoderImpl","constructor","stdlib","labelsStack","Stack","InstructionEncoderImpl","errors","handle","malloc","error","encode","commit","size","pushMachine","finishMalloc","list","args","first","MACHINE_MASK","ARG_SHIFT","pushRaw","i","operand","array","currentLabels","offset","isStrictMode","block","containing","CompilableTemplateImpl","parameters","EMPTY_ARRAY","current","pop","templateCompilationContext","evaluation","Compilers","add","func","names","funcs","compile","sexp","EXPRESSIONS","withPath","path","expression","PushPrimitive","PushPrimitiveReference","primitive","p","nonSmallIntOperand","Call","positional","named","SimpleArgs","$v0","CallDynamic","append","$fp","Curry","YieldBlock","to","PushYieldableBlock","PushSymbolTable","PushCompilable","InvokeStaticBlock","InvokeStaticBlockWithStack","callerCount","calleeCount","count","Math","min","_block","atNames","flags","CompilePositional","EMPTY_STRING_ARRAY","val","layout","locals","lexicalSymbols","scope","Concat","parts","part","GetSymbol","sym","Undefined","HasBlock","VM_HAS_BLOCK_OP","HasBlockParams","VM_HAS_BLOCK_PARAMS_OP","IfInline","condition","truthy","falsy","VM_IF_INLINE_OP","Not","VM_NOT_OP","GetDynamicVar","VM_GET_DYNAMIC_VAR_OP","Log","NamedBlocksImpl","blocks","Object","keys","get","has","with","assign","hasAny","EMPTY_BLOCKS","namedBlocks","out","values","key","enumerate","SwitchCases","bootstrap","matcher","clauses","match","callback","clause","slice","Replayable","body","ReplayableIf","ifTrue","ifFalse","ATTRS_BLOCK","InvokeComponent","_elementBlock","_blocks","compilable","capabilities","elementBlock","symbolTable","hasCapability","InternalComponentCapabilities","prepareArgs","InvokeNonStaticComponent","$s0","$sp","blockSymbols","argSymbols","argNames","blockNames","symbol","indexOf","createArgs","dynamicScope","createInstance","reverse","InvokeStaticComponent","InvokeDynamicComponent","curried","bindableBlocks","bindableAtNames","CompileArgs","invokePreparedComponent","hasBlock","populateLayout","STATEMENTS","INFLATE_ATTR_TABLE","INFLATE_TAG_TABLE","inflateTagName","tagName","inflateAttrName","attrName","hashToArgs","hash","map","Comment","CloseElement","FlushElement","Modifier","VM_POP_FRAME_OP","StaticAttr","namespace","StaticComponentAttr","DynamicAttr","TrustingDynamicAttr","ComponentAttr","TrustingComponentAttr","OpenElement","tag","OpenElementWithSplat","Component","Yield","params","AttrSplat","Debugger","debugSymbolsOperand","Append","VM_DYNAMIC_CONTENT_TYPE_OP","when","ContentType","Helper","String","TrustingAppend","Block","InElement","guid","destination","insertBefore","VM_POP_REMOTE_ELEMENT_OP","If","inverse","Each","Let","WithDynamicVars","expressions","DynamicScope","statements","compiled","result","compileStatements","maybeCompile","syntaxContext","sCompiler","pushOp","statement","DEFAULT_CAPABILITIES","dynamicLayout","dynamicTag","attributeHook","elementHook","createCaller","updateHook","wrapped","willDestroy","hasSubOwner","MINIMAL_CAPABILITIES","StdLib","main","trustingGuardedAppend","cautiousGuardedAppend","trustingNonDynamicAppend","cautiousNonDynamicAppend","getAppend","trusting","StdAppend","nonDynamicAppend","InvokeBareComponent","VM_APPEND_TEXT_OP","SafeString","VM_APPEND_SAFE_HTML_OP","Fragment","VM_APPEND_DOCUMENT_FRAGMENT_OP","Node","VM_APPEND_NODE_OP","compileStd","mainHandle","build","trustingGuardedNonDynamicAppend","cautiousGuardedNonDynamicAppend","trustingGuardedDynamicAppend","cautiousGuardedDynamicAppend","STDLIB_META","builder","EvaluationContextImpl","createOp","runtime","env","WrappedBuilder","attrsBlockIndex","attrsBlockNumber","syntax","m","register","WithSavedRegister","$s1","clientId","templateCacheCounters","cacheHit","cacheMiss","templateFactory","id","templateId","parsedBlock","ownerlessTemplate","templateCache","WeakMap","factory","JSON","parse","TemplateImpl","set","__id","__meta","parsedLayout","wrappedLayout","referrer","asLayout","asWrappedLayout"],"mappings":"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"}