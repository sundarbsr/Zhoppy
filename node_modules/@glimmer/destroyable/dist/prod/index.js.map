{"version":3,"file":"index.js","sources":["../../index.ts"],"sourcesContent":["import type { Destroyable, Destructor } from '@glimmer/interfaces';\nimport { debugToString } from '@glimmer/debug-util';\nimport { scheduleDestroy, scheduleDestroyed } from '@glimmer/global-context';\n\nconst LIVE_STATE = 0;\nconst DESTROYING_STATE = 1;\nconst DESTROYED_STATE = 2;\ntype DestroyableState = 0 | 1 | 2;\n\ntype OneOrMany<T> = null | T | T[];\n\ninterface DestroyableMeta<T extends Destroyable> {\n  source?: T;\n  parents: OneOrMany<Destroyable>;\n  children: OneOrMany<Destroyable>;\n  eagerDestructors: OneOrMany<Destructor<T>>;\n  destructors: OneOrMany<Destructor<T>>;\n  state: DestroyableState;\n}\n\ninterface UndestroyedDestroyablesError extends Error {\n  destroyables: object[];\n}\n\nlet DESTROYABLE_META:\n  | Map<Destroyable, DestroyableMeta<Destroyable>>\n  | WeakMap<Destroyable, DestroyableMeta<Destroyable>> = new WeakMap();\n\nfunction push<T extends object>(collection: OneOrMany<T>, newItem: T): OneOrMany<T> {\n  if (collection === null) {\n    return newItem;\n  } else if (Array.isArray(collection)) {\n    collection.push(newItem);\n    return collection;\n  } else {\n    return [collection, newItem];\n  }\n}\n\nfunction iterate<T extends object>(collection: OneOrMany<T>, fn: (item: T) => void) {\n  if (Array.isArray(collection)) {\n    collection.forEach(fn);\n  } else if (collection !== null) {\n    fn(collection);\n  }\n}\n\nfunction remove<T extends object>(collection: OneOrMany<T>, item: T, message: string | false) {\n  if (import.meta.env.DEV) {\n    let collectionIsItem = collection === item;\n    let collectionContainsItem = Array.isArray(collection) && collection.indexOf(item) !== -1;\n\n    if (!collectionIsItem && !collectionContainsItem) {\n      throw new Error(String(message));\n    }\n  }\n\n  if (Array.isArray(collection) && collection.length > 1) {\n    let index = collection.indexOf(item);\n    collection.splice(index, 1);\n    return collection;\n  } else {\n    return null;\n  }\n}\n\nfunction getDestroyableMeta<T extends Destroyable>(destroyable: T): DestroyableMeta<T> {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  if (meta === undefined) {\n    meta = {\n      parents: null,\n      children: null,\n      eagerDestructors: null,\n      destructors: null,\n      state: LIVE_STATE,\n    };\n\n    if (import.meta.env.DEV) {\n      meta.source = destroyable as object;\n    }\n\n    DESTROYABLE_META.set(destroyable, meta);\n  }\n\n  return meta as unknown as DestroyableMeta<T>;\n}\n\nexport function associateDestroyableChild<T extends Destroyable>(parent: Destroyable, child: T): T {\n  if (import.meta.env.DEV && isDestroying(parent)) {\n    throw new Error(\n      'Attempted to associate a destroyable child with an object that is already destroying or destroyed'\n    );\n  }\n\n  let parentMeta = getDestroyableMeta(parent);\n  let childMeta = getDestroyableMeta(child);\n\n  parentMeta.children = push(parentMeta.children, child);\n  childMeta.parents = push(childMeta.parents, parent);\n\n  return child;\n}\n\nexport function registerDestructor<T extends Destroyable>(\n  destroyable: T,\n  destructor: Destructor<T>,\n  eager = false\n): Destructor<T> {\n  if (import.meta.env.DEV && isDestroying(destroyable)) {\n    throw new Error(\n      'Attempted to register a destructor with an object that is already destroying or destroyed'\n    );\n  }\n\n  let meta = getDestroyableMeta(destroyable);\n\n  let destructorsKey: 'eagerDestructors' | 'destructors' = eager\n    ? 'eagerDestructors'\n    : 'destructors';\n\n  meta[destructorsKey] = push(meta[destructorsKey], destructor);\n\n  return destructor;\n}\n\nexport function unregisterDestructor<T extends Destroyable>(\n  destroyable: T,\n  destructor: Destructor<T>,\n  eager = false\n): void {\n  if (import.meta.env.DEV && isDestroying(destroyable)) {\n    throw new Error(\n      'Attempted to unregister a destructor with an object that is already destroying or destroyed'\n    );\n  }\n\n  let meta = getDestroyableMeta(destroyable);\n\n  let destructorsKey: 'eagerDestructors' | 'destructors' = eager\n    ? 'eagerDestructors'\n    : 'destructors';\n\n  meta[destructorsKey] = remove(\n    meta[destructorsKey],\n    destructor,\n    import.meta.env.DEV &&\n      'attempted to remove a destructor that was not registered with the destroyable'\n  );\n}\n\n////////////\n\nexport function destroy(destroyable: Destroyable) {\n  let meta = getDestroyableMeta(destroyable);\n\n  if (meta.state >= DESTROYING_STATE) return;\n\n  let { parents, children, eagerDestructors, destructors } = meta;\n\n  meta.state = DESTROYING_STATE;\n\n  iterate(children, destroy);\n  iterate(eagerDestructors, (destructor) => {\n    destructor(destroyable);\n  });\n  iterate(destructors, (destructor) => {\n    scheduleDestroy(destroyable, destructor);\n  });\n\n  scheduleDestroyed(() => {\n    iterate(parents, (parent) => {\n      removeChildFromParent(destroyable, parent);\n    });\n\n    meta.state = DESTROYED_STATE;\n  });\n}\n\nfunction removeChildFromParent(child: Destroyable, parent: Destroyable) {\n  let parentMeta = getDestroyableMeta(parent);\n\n  if (parentMeta.state === LIVE_STATE) {\n    parentMeta.children = remove(\n      parentMeta.children,\n      child,\n      import.meta.env.DEV &&\n        \"attempted to remove child from parent, but the parent's children did not contain the child. This is likely a bug with destructors.\"\n    );\n  }\n}\n\nexport function destroyChildren(destroyable: Destroyable) {\n  let { children } = getDestroyableMeta(destroyable);\n\n  iterate(children, destroy);\n}\n\nexport function _hasDestroyableChildren(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.children !== null;\n}\n\nexport function isDestroying(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.state >= DESTROYING_STATE;\n}\n\nexport function isDestroyed(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.state >= DESTROYED_STATE;\n}\n\n////////////\n\nexport let enableDestroyableTracking: undefined | (() => void);\nexport let assertDestroyablesDestroyed: undefined | (() => void);\n\nif (import.meta.env.DEV) {\n  let isTesting = false;\n\n  enableDestroyableTracking = () => {\n    if (isTesting) {\n      // Reset destroyable meta just in case, before throwing the error\n      DESTROYABLE_META = new WeakMap();\n      throw new Error(\n        'Attempted to start destroyable testing, but you did not end the previous destroyable test. Did you forget to call `assertDestroyablesDestroyed()`'\n      );\n    }\n\n    isTesting = true;\n    DESTROYABLE_META = new Map();\n  };\n\n  assertDestroyablesDestroyed = () => {\n    if (!isTesting) {\n      throw new Error(\n        'Attempted to assert destroyables destroyed, but you did not start a destroyable test. Did you forget to call `enableDestroyableTracking()`'\n      );\n    }\n\n    isTesting = false;\n\n    let map = DESTROYABLE_META as Map<Destroyable, DestroyableMeta<Destroyable>>;\n    DESTROYABLE_META = new WeakMap();\n\n    let undestroyed: object[] = [];\n\n    map.forEach((meta) => {\n      if (meta.state !== DESTROYED_STATE) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        undestroyed.push(meta.source!);\n      }\n    });\n\n    if (undestroyed.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      let objectsToString = undestroyed.map(debugToString!).join('\\n    ');\n      let error = new Error(\n        `Some destroyables were not destroyed during this test:\\n    ${objectsToString}`\n      ) as UndestroyedDestroyablesError;\n\n      error.destroyables = undestroyed;\n\n      throw error;\n    }\n  };\n}\n"],"names":["enableDestroyableTracking","assertDestroyablesDestroyed","DESTROYABLE_META","WeakMap","push","collection","newItem","Array","isArray","iterate","fn","forEach","remove","item","length","index","indexOf","splice","getDestroyableMeta","destroyable","meta","get","undefined","parents","children","eagerDestructors","destructors","state","set","associateDestroyableChild","parent","child","parentMeta","childMeta","registerDestructor","destructor","eager","destructorsKey","unregisterDestructor","destroy","scheduleDestroy","scheduleDestroyed","removeChildFromParent","DESTROYED_STATE","destroyChildren","_hasDestroyableChildren","isDestroying","isDestroyed"],"mappings":"iFAwBA,IAkMWA,EACAC,EAnMPC,EAEqD,IAAIC,QAE7D,SAASC,EAAuBC,EAA0BC,GACxD,OAAmB,OAAfD,EACKC,EACEC,MAAMC,QAAQH,IACvBA,EAAWD,KAAKE,GACTD,GAEA,CAACA,EAAYC,EAExB,CAEA,SAASG,EAA0BJ,EAA0BK,GACvDH,MAAMC,QAAQH,GAChBA,EAAWM,QAAQD,GACK,OAAfL,GACTK,EAAGL,EAEP,CAEA,SAASO,EAAyBP,EAA0BQ,GAU1D,GAAIN,MAAMC,QAAQH,IAAeA,EAAWS,OAAS,EAAG,CACtD,IAAIC,EAAQV,EAAWW,QAAQH,GAE/B,OADAR,EAAWY,OAAOF,EAAO,GAClBV,EAEP,OAAO,IAEX,CAEA,SAASa,EAA0CC,GACjD,IAAIC,EAAOlB,EAAiBmB,IAAIF,GAkBhC,YAhBaG,IAATF,IACFA,EAAO,CACLG,QAAS,KACTC,SAAU,KACVC,iBAAkB,KAClBC,YAAa,KACbC,MAvEa,GA8EfzB,EAAiB0B,IAAIT,EAAaC,IAG7BA,CACT,CAEO,SAASS,EAAiDC,EAAqBC,GAOpF,IAAIC,EAAad,EAAmBY,GAChCG,EAAYf,EAAmBa,GAKnC,OAHAC,EAAWR,SAAWpB,EAAK4B,EAAWR,SAAUO,GAChDE,EAAUV,QAAUnB,EAAK6B,EAAUV,QAASO,GAErCC,CACT,CAEO,SAASG,EACdf,EACAgB,EACAC,GAAQ,GAQR,IAAIhB,EAAOF,EAAmBC,GAE1BkB,EAAqDD,EACrD,mBACA,cAIJ,OAFAhB,EAAKiB,GAAkBjC,EAAKgB,EAAKiB,GAAiBF,GAE3CA,CACT,CAEO,SAASG,EACdnB,EACAgB,EACAC,GAAQ,GAQR,IAAIhB,EAAOF,EAAmBC,GAE1BkB,EAAqDD,EACrD,mBACA,cAEJhB,EAAKiB,GAAkBzB,EACrBQ,EAAKiB,GACLF,EAIJ,CAIO,SAASI,EAAQpB,GACtB,IAAIC,EAAOF,EAAmBC,GAE9B,GAAIC,EAAKO,OAvJc,EAuJa,OAEpC,IAAIJ,QAAEA,EAAOC,SAAEA,EAAQC,iBAAEA,EAAgBC,YAAEA,GAAgBN,EAE3DA,EAAKO,MA3JkB,EA6JvBlB,EAAQe,EAAUe,GAClB9B,EAAQgB,GAAmBU,IACzBA,EAAWhB,EAAAA,IAEbV,EAAQiB,GAAcS,IACpBK,EAAgBrB,EAAagB,EAAAA,IAG/BM,GAAkB,KAChBhC,EAAQc,GAAUO,KAQtB,SAA+BC,EAAoBD,GACjD,IAAIE,EAAad,EAAmBY,GAhLnB,IAkLbE,EAAWL,QACbK,EAAWR,SAAWZ,EACpBoB,EAAWR,SACXO,GAKN,CAlBMW,CAAsBvB,EAAaW,EAAAA,IAGrCV,EAAKO,MAzKe,CAyKPgB,GAEjB,CAeO,SAASC,EAAgBzB,GAC9B,IAAIK,SAAEA,GAAaN,EAAmBC,GAEtCV,EAAQe,EAAUe,EACpB,CAEO,SAASM,EAAwB1B,GACtC,IAAIC,EAAOlB,EAAiBmB,IAAIF,GAEhC,YAAgBG,IAATF,GAA+C,OAAlBA,EAAKI,QAC3C,CAEO,SAASsB,EAAa3B,GAC3B,IAAIC,EAAOlB,EAAiBmB,IAAIF,GAEhC,YAAgBG,IAATF,GAA6BA,EAAKO,OA1MlB,CA2MzB,CAEO,SAASoB,EAAY5B,GAC1B,IAAIC,EAAOlB,EAAiBmB,IAAIF,GAEhC,YAAgBG,IAATF,GAA6BA,EAAKO,OA/MnB,CAgNxB"}