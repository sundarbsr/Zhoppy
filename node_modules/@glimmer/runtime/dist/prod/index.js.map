{"version":3,"file":"index.js","sources":["../../../constants/lib/curried.ts","../../../constants/lib/dom.ts","../../../debug-util/lib/simple-cast.ts","../../../debug-util/lib/template.ts","../../../constants/lib/immediate.ts","../../../debug/lib/stack-check.ts","../../lib/opcodes.ts","../../../constants/lib/syscall-ops.ts","../../lib/curried-value.ts","../../lib/scope.ts","../../lib/bounds.ts","../../lib/component/interfaces.ts","../../lib/debug-render-tree.ts","../../lib/dom/normalize.ts","../../lib/compiled/opcodes/vm.ts","../../lib/compiled/opcodes/dom.ts","../../lib/compiled/opcodes/component.ts","../../lib/component/resolve.ts","../../lib/references/class-list.ts","../../lib/compiled/opcodes/-debug-strip.ts","../../lib/vm/arguments.ts","../../lib/compiled/expressions/concat.ts","../../lib/compiled/opcodes/expressions.ts","../../lib/references/curry-value.ts","../../lib/vm/content/text.ts","../../lib/compiled/opcodes/content.ts","../../lib/compiled/opcodes/debugger.ts","../../lib/compiled/opcodes/lists.ts","../../lib/component/template-only.ts","../../lib/dom/operations.ts","../../lib/compat/svg-inner-html-fix.ts","../../lib/compat/text-node-merging-fix.ts","../../lib/dom/api.ts","../../lib/dom/helper.ts","../../lib/dom/props.ts","../../lib/environment.ts","../../lib/helpers/internal-helper.ts","../../lib/helpers/array.ts","../../lib/helpers/concat.ts","../../lib/helpers/fn.ts","../../../debug-util/lib/untouchable-this.ts","../../lib/helpers/get.ts","../../lib/helpers/hash.ts","../../lib/helpers/invoke.ts","../../lib/modifiers/on.ts","../../lib/vm/low-level.ts","../../../constants/lib/vm-ops.ts","../../lib/dom/sanitized-values.ts","../../lib/vm/attributes/dynamic.ts","../../lib/vm/element-builder.ts","../../lib/vm/update.ts","../../lib/vm/render-result.ts","../../lib/vm/stack.ts","../../lib/vm/append.ts","../../lib/render.ts","../../lib/vm/rehydrate-builder.ts"],"sourcesContent":["import type { CurriedComponent, CurriedHelper, CurriedModifier } from '@glimmer/interfaces';\n\nexport const CURRIED_COMPONENT = 0 satisfies CurriedComponent;\nexport const CURRIED_HELPER = 1 satisfies CurriedHelper;\nexport const CURRIED_MODIFIER = 2 satisfies CurriedModifier;\n","import type { InsertPosition, Namespace, NodeType } from '@glimmer/interfaces';\n\nexport const RAW_NODE = -1;\nexport const ELEMENT_NODE: NodeType.ELEMENT_NODE = 1;\nexport const TEXT_NODE: NodeType.TEXT_NODE = 3;\nexport const COMMENT_NODE: NodeType.COMMENT_NODE = 8;\nexport const DOCUMENT_NODE: NodeType.DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE: NodeType.DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE: NodeType.DOCUMENT_FRAGMENT_NODE = 11;\n\nexport const NS_HTML = 'http://www.w3.org/1999/xhtml' as Namespace.HTML;\nexport const NS_MATHML = 'http://www.w3.org/1998/Math/MathML' as Namespace.MathML;\nexport const NS_SVG = 'http://www.w3.org/2000/svg' as Namespace.SVG;\nexport const NS_XLINK = 'http://www.w3.org/1999/xlink' as Namespace.XLink;\nexport const NS_XML = 'http://www.w3.org/XML/1998/namespace' as Namespace.XML;\nexport const NS_XMLNS = 'http://www.w3.org/2000/xmlns/' as Namespace.XMLNS;\n\nexport const INSERT_BEFORE_BEGIN = 'beforebegin' as InsertPosition.beforebegin;\nexport const INSERT_AFTER_BEGIN = 'afterbegin' as InsertPosition.afterbegin;\nexport const INSERT_BEFORE_END = 'beforeend' as InsertPosition.beforeend;\nexport const INSERT_AFTER_END = 'afterend' as InsertPosition.afterend;\n","import type { Maybe, SimpleDocument, SimpleElement, SimpleNode } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nimport { unreachable } from './platform-utils';\n\ninterface GenericElementTags {\n  HTML: HTMLElement;\n  SVG: SVGElement;\n  ELEMENT: HTMLElement | SVGElement;\n}\n\ninterface GenericNodeTags {\n  NODE: Node;\n}\n\ntype GenericNodeTag = keyof GenericNodeTags;\n\ninterface BrowserElementTags extends HTMLElementTagNameMap, GenericElementTags {}\ntype BrowserElementTag = keyof BrowserElementTags;\n\ninterface BrowserTags extends BrowserElementTags, GenericNodeTags {}\ntype BrowserTag = keyof BrowserTags;\n\ntype NodeCheck<N extends Node> = (node: Node) => node is N;\ntype SugaryNodeCheck<K extends BrowserTag = BrowserTag> = NodeCheck<BrowserTags[K]> | K | K[];\ntype NodeForSugaryCheck<S extends SugaryNodeCheck> =\n  S extends NodeCheck<infer N>\n    ? N\n    : S extends keyof BrowserTags\n      ? BrowserTags[S]\n      : S extends (keyof BrowserTags)[]\n        ? BrowserTags[S[number]]\n        : never;\n\ntype BrowserNode = Element | Document | DocumentFragment | Text | Comment | Node;\n\nexport function castToSimple(doc: Document | SimpleDocument): SimpleDocument;\nexport function castToSimple(elem: Element | SimpleElement): SimpleElement;\nexport function castToSimple(node: Node | SimpleNode): SimpleNode;\nexport function castToSimple(\n  node: Document | Element | Node | SimpleDocument | SimpleElement | SimpleNode\n) {\n  if (isDocument(node)) {\n    return node as SimpleDocument;\n  } else if (isSimpleElement(node)) {\n    return node;\n  } else {\n    return node as SimpleNode;\n  }\n}\n\n// If passed a document, verify we're in the browser and return it as a Document\nexport function castToBrowser(doc: Document | SimpleDocument): Document;\n// If we don't know what this is, but the check requires it to be an element,\n// the cast will mandate that it's a browser element\nexport function castToBrowser<S extends SugaryNodeCheck<BrowserElementTag>>(\n  node: BrowserNode | SimpleNode,\n  check: S\n): NodeForSugaryCheck<S>;\n// Finally, if it's a more generic check, the cast will mandate that it's a\n// browser node and return a BrowserNodeUtils corresponding to the check\nexport function castToBrowser<S extends SugaryNodeCheck<GenericNodeTag>>(\n  element: BrowserNode | SimpleNode,\n  check: S\n): NodeForSugaryCheck<S>;\nexport function castToBrowser<K extends keyof HTMLElementTagNameMap>(\n  element: SimpleElement | Element,\n  check: K\n): HTMLElementTagNameMap[K];\nexport function castToBrowser<S extends SugaryNodeCheck>(\n  node: SimpleNode | BrowserNode | null | undefined,\n  sugaryCheck?: S\n): Document | NodeForSugaryCheck<S> | null {\n  if (!LOCAL_DEBUG) {\n    return node as Document | NodeForSugaryCheck<S> | null;\n  }\n\n  if (node === null || node === undefined) {\n    return null;\n  }\n\n  if (typeof document === 'undefined') {\n    throw new Error('Attempted to cast to a browser node in a non-browser context');\n  }\n\n  if (isDocument(node)) {\n    return node as Document;\n  }\n\n  if (node.ownerDocument !== document) {\n    throw new Error(\n      'Attempted to cast to a browser node with a node that was not created from this document'\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return checkBrowserNode<S>(node, sugaryCheck!);\n}\n\nfunction checkError(from: string, check: SugaryNodeCheck): Error {\n  return new Error(`cannot cast a ${from} into ${String(check)}`);\n}\n\nexport const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\n\nfunction isDocument(node: Node | SimpleNode | SimpleDocument): node is Document | SimpleDocument {\n  return node.nodeType === DOCUMENT_NODE;\n}\n\nexport function isSimpleElement(node: Maybe<SimpleNode | Node>): node is SimpleElement {\n  return node?.nodeType === ELEMENT_NODE;\n}\n\nexport function isElement(node: Maybe<Node | SimpleNode>): node is Element {\n  return node?.nodeType === ELEMENT_NODE && node instanceof Element;\n}\n\nexport function checkBrowserNode<S extends SugaryNodeCheck>(\n  node: Node | SimpleNode | null,\n  check: S\n): NodeForSugaryCheck<S> {\n  let isMatch = false;\n\n  if (node !== null) {\n    if (typeof check === 'string') {\n      isMatch = stringCheckNode(node, check);\n    } else if (Array.isArray(check)) {\n      isMatch = check.some((c) => stringCheckNode(node, c));\n    } else {\n      unreachable();\n    }\n  }\n\n  if (isMatch && node instanceof Node) {\n    return node as NodeForSugaryCheck<S>;\n  } else {\n    throw checkError(`SimpleElement(${node?.constructor.name ?? 'null'})`, check);\n  }\n}\n\nfunction stringCheckNode<S extends BrowserTag>(\n  node: Node | SimpleNode,\n  check: S\n): node is BrowserTags[S] {\n  switch (check) {\n    case 'NODE':\n      return true;\n    case 'HTML':\n      return node instanceof HTMLElement;\n    case 'SVG':\n      return node instanceof SVGElement;\n    case 'ELEMENT':\n      return node instanceof Element;\n    default:\n      if (check.toUpperCase() === check) {\n        throw new Error(`BUG: this code is missing handling for a generic node type`);\n      }\n      return node instanceof Element && node.tagName.toLowerCase() === check;\n  }\n}\n","import type { ErrHandle, HandleResult, OkHandle, Template, TemplateOk } from '@glimmer/interfaces';\n\nexport function unwrapHandle(handle: HandleResult): number {\n  if (typeof handle === 'number') {\n    return handle;\n  } else {\n    let error = handle.errors[0];\n    throw new Error(`Compile Error: ${error.problem} @ ${error.span.start}..${error.span.end}`);\n  }\n}\n\nexport function unwrapTemplate(template: Template): TemplateOk {\n  if (template.result === 'error') {\n    throw new Error(\n      `Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`\n    );\n  }\n\n  return template;\n}\n\nexport function extractHandle(handle: HandleResult): number {\n  if (typeof handle === 'number') {\n    return handle;\n  } else {\n    return handle.handle;\n  }\n}\n\nexport function isOkHandle(handle: HandleResult): handle is OkHandle {\n  return typeof handle === 'number';\n}\n\nexport function isErrHandle(handle: HandleResult): handle is ErrHandle {\n  return typeof handle === 'number';\n}\n","import { localAssert } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\n/*\n  Encoding notes\n\n  We use 30 bit integers for encoding, so that we don't ever encode a non-SMI\n  integer to push on the stack.\n\n  Handles are >= 0\n  Immediates are < 0\n\n  True, False, Undefined and Null are pushed as handles into the symbol table,\n  with well known handles (0, 1, 2, 3)\n\n  The negative space is divided into positives and negatives. Positives are\n  higher numbers (-1, -2, -3, etc), negatives are lower.\n\n  We only encode immediates for two reasons:\n\n  1. To transfer over the wire, so they're smaller in general\n  2. When pushing values onto the stack from the low level/inner VM, which may\n     be converted into WASM one day.\n\n  This allows the low-level VM to always use SMIs, and to minimize using JS\n  values via handles for things like the stack pointer and frame pointer.\n  Externally, most code pushes values as JS values, except when being pulled\n  from the append byte code where it was already encoded.\n\n  Logically, this is because the low level VM doesn't really care about these\n  higher level values. For instance, the result of a userland helper may be a\n  number, or a boolean, or undefined/null, but it's extra work to figure that\n  out and push it correctly, vs. just pushing the value as a JS value with a\n  handle.\n\n  Note: The details could change here in the future, this is just the current\n  strategy.\n*/\n\nexport const MAX_SMI = 2 ** 30 - 1;\nexport const MIN_SMI = ~MAX_SMI;\nexport const SIGN_BIT = ~(2 ** 29);\nexport const MAX_INT = ~SIGN_BIT - 1;\nexport const MIN_INT = ~MAX_INT;\n\nexport const FALSE_HANDLE = 0;\nexport const TRUE_HANDLE = 1;\nexport const NULL_HANDLE = 2;\nexport const UNDEFINED_HANDLE = 3;\n\nexport const ENCODED_FALSE_HANDLE = FALSE_HANDLE;\nexport const ENCODED_TRUE_HANDLE = TRUE_HANDLE;\nexport const ENCODED_NULL_HANDLE = NULL_HANDLE;\nexport const ENCODED_UNDEFINED_HANDLE = UNDEFINED_HANDLE;\n\nexport function isHandle(value: number) {\n  return value >= 0;\n}\n\nexport function isNonPrimitiveHandle(value: number) {\n  return value > ENCODED_UNDEFINED_HANDLE;\n}\n\nexport function constants(...values: unknown[]): unknown[] {\n  return [false, true, null, undefined, ...values];\n}\n\nexport function isSmallInt(value: number) {\n  return value % 1 === 0 && value <= MAX_INT && value >= MIN_INT;\n}\n\nexport function encodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= MIN_INT && num < 0, `Could not encode negative: ${num}`);\n  }\n\n  return num & SIGN_BIT;\n}\n\nexport function decodeNegative(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(\n      num % 1 === 0 && num < ~MAX_INT && num >= MIN_SMI,\n      `Could not decode negative: ${num}`\n    );\n  }\n\n  return num | ~SIGN_BIT;\n}\n\nexport function encodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= 0 && num <= MAX_INT, `Could not encode positive: ${num}`);\n  }\n\n  return ~num;\n}\n\nexport function decodePositive(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num <= 0 && num >= ~MAX_INT, `Could not decode positive: ${num}`);\n  }\n\n  return ~num;\n}\n\nexport function encodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num >= 0 && num <= MAX_SMI, `Could not encode handle: ${num}`);\n  }\n\n  return num;\n}\n\nexport function decodeHandle(num: number) {\n  if (LOCAL_DEBUG) {\n    localAssert(num % 1 === 0 && num <= MAX_SMI && num >= 0, `Could not decode handle: ${num}`);\n  }\n\n  return num;\n}\n\nexport function encodeImmediate(num: number) {\n  num |= 0;\n  return num < 0 ? encodeNegative(num) : encodePositive(num);\n}\n\nexport function decodeImmediate(num: number) {\n  num |= 0;\n  return num > SIGN_BIT ? decodePositive(num) : decodeNegative(num);\n}\n\n// Warm\n[1, 2, 3].forEach((x) => decodeHandle(encodeHandle(x)));\n[1, -1].forEach((x) => decodeImmediate(encodeImmediate(x)));\n","import type {\n  AnyFn,\n  BlockSymbolTable,\n  Dict,\n  Maybe,\n  Nullable,\n  ProgramSymbolTable,\n  SimpleDocumentFragment,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport type { MachineRegister, Register, SyscallRegister } from '@glimmer/vm';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { $fp, $pc, $ra, $s0, $s1, $sp, $t0, $t1, $v0 } from '@glimmer/vm';\n\nimport type { Primitive } from './dism/dism';\n\nexport interface Checker<T> {\n  type: T;\n\n  validate(value: unknown): value is T;\n  expected(): string;\n}\n\nclass NoopChecker<T> implements Checker<T> {\n  declare type: T;\n  validate(value: unknown): value is T {\n    return true;\n  }\n  expected(): string {\n    return '<noop>';\n  }\n}\n\nexport function wrap<T>(checker: () => Checker<T>): Checker<T> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker<T>();\n  }\n\n  class Wrapped {\n    declare type: T;\n\n    validate(value: unknown): value is T {\n      return checker().validate(value);\n    }\n\n    expected(): string {\n      return checker().expected();\n    }\n  }\n\n  return new Wrapped();\n}\n\nexport interface Constructor<T> extends AnyFn {\n  prototype: T;\n}\n\nclass TypeofChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(private expectedType: string) {}\n\n  validate(value: unknown): value is T {\n    return typeof value === this.expectedType;\n  }\n\n  expected(): string {\n    return `typeof ${this.expectedType}`;\n  }\n}\n\nclass PrimitiveChecker implements Checker<Primitive> {\n  declare type: Primitive;\n\n  validate(value: unknown): value is Primitive {\n    return (\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      typeof value === 'boolean' ||\n      value === undefined ||\n      value === null\n    );\n  }\n\n  expected(): string {\n    return `a primitive`;\n  }\n}\n\nclass NullChecker implements Checker<null> {\n  declare type: null;\n\n  validate(value: unknown): value is null {\n    return value === null;\n  }\n\n  expected(): string {\n    return `null`;\n  }\n}\n\nclass UndefinedChecker implements Checker<undefined> {\n  declare type: undefined;\n\n  validate(value: unknown): value is undefined {\n    return value === undefined;\n  }\n\n  expected(): string {\n    return `undefined`;\n  }\n}\n\nclass InstanceofChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(private Class: Constructor<T>) {}\n\n  validate(value: unknown): value is T {\n    return value ? value instanceof this.Class : false;\n  }\n\n  expected(): string {\n    return `an instance of ${this.Class.name}`;\n  }\n}\n\nclass OptionChecker<T> implements Checker<Nullable<T>> {\n  declare type: Nullable<T>;\n\n  constructor(\n    private checker: Checker<T>,\n    private emptyValue: null | undefined\n  ) {}\n\n  validate(value: unknown): value is Nullable<T> {\n    if (value === this.emptyValue) return true;\n    return this.checker.validate(value);\n  }\n\n  expected(): string {\n    return `${this.checker.expected()} or null`;\n  }\n}\n\nclass MaybeChecker<T> implements Checker<Maybe<T>> {\n  declare type: Maybe<T>;\n\n  constructor(private checker: Checker<T>) {}\n\n  validate(value: unknown): value is Maybe<T> {\n    if (value === null || value === undefined) return true;\n    return this.checker.validate(value);\n  }\n\n  expected(): string {\n    return `${this.checker.expected()} or null or undefined`;\n  }\n}\n\nclass OrChecker<T, U> implements Checker<T | U> {\n  declare type: T | U;\n\n  constructor(\n    private left: Checker<T>,\n    private right: Checker<U>\n  ) {}\n\n  validate(value: unknown): value is T | U {\n    return this.left.validate(value) || this.right.validate(value);\n  }\n\n  expected(): string {\n    return `${this.left.expected()} or ${this.right.expected()}`;\n  }\n}\n\nclass ExactValueChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(\n    private value: T,\n    private desc: string\n  ) {}\n\n  validate(obj: unknown): obj is T {\n    return obj === this.value;\n  }\n\n  expected(): string {\n    return this.desc;\n  }\n}\n\nclass PropertyChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(private checkers: Dict<Checker<unknown>>) {}\n\n  validate(obj: unknown): obj is T {\n    if (obj === null || typeof obj !== 'object') return false;\n\n    return Object.entries(this.checkers).every(([k, checker]) =>\n      k in obj ? checker.validate((obj as Dict)[k]) : false\n    );\n  }\n\n  expected(): string {\n    let pairs = Object.entries(this.checkers).map(([k, checker]) => {\n      return `${k}: ${checker.expected()}`;\n    });\n\n    return `{ ${pairs.join(',')} }`;\n  }\n}\n\nclass ArrayChecker<T> implements Checker<T[]> {\n  declare type: T[];\n\n  constructor(private checker: Checker<T>) {}\n\n  validate(obj: unknown): obj is T[] {\n    if (obj === null || obj === undefined) return false;\n    if (!Array.isArray(obj)) return false;\n\n    return obj.every((item) => this.checker.validate(item));\n  }\n\n  expected(): string {\n    return `Array<${this.checker.expected()}>`;\n  }\n}\n\nclass DictChecker<T> implements Checker<Dict<T>> {\n  declare type: Dict<T>;\n\n  constructor(private checker: Checker<T>) {}\n\n  validate(value: unknown): value is Dict<T> {\n    let isDict =\n      typeof value === 'object' && value !== null && Object.getPrototypeOf(value) === null;\n\n    if (!isDict) return false;\n\n    let { checker } = this;\n\n    for (let key in value as Dict) {\n      if (!checker.validate((value as Dict)[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  expected(): string {\n    return `a primitive`;\n  }\n}\n\nclass OpaqueChecker implements Checker<unknown> {\n  type: unknown;\n\n  validate(_obj: unknown): _obj is unknown {\n    return true;\n  }\n\n  expected(): string {\n    return `any`;\n  }\n}\n\nclass ObjectChecker implements Checker<unknown> {\n  declare type: object;\n\n  validate(obj: unknown): obj is object {\n    return typeof obj === 'function' || (typeof obj === 'object' && obj !== null);\n  }\n\n  expected(): string {\n    return `an object or function (valid WeakMap key)`;\n  }\n}\n\nexport interface SafeString {\n  toHTML(): string;\n}\n\nclass SafeStringChecker implements Checker<SafeString> {\n  declare type: SafeString;\n\n  validate(value: unknown): value is SafeString {\n    return (\n      typeof value === 'object' &&\n      value !== null &&\n      typeof (value as { toHTML?: unknown }).toHTML === 'function'\n    );\n  }\n\n  expected(): string {\n    return `SafeString`;\n  }\n}\n\nexport function CheckInstanceof<T>(Class: Constructor<T>): Checker<T>;\nexport function CheckInstanceof<T>(Class: Constructor<T>): Checker<T> | undefined {\n  if (LOCAL_DEBUG) {\n    return new InstanceofChecker<T>(Class);\n  }\n}\n\nexport const CheckRegister: Checker<Register> = new (class {\n  declare type: Register;\n  validate(value: unknown): value is Register {\n    switch (value) {\n      case $s0:\n      case $s1:\n      case $sp:\n      case $fp:\n      case $ra:\n      case $pc:\n      case $t0:\n      case $t1:\n      case $v0:\n        return true;\n      default:\n        return false;\n    }\n  }\n  expected(): string {\n    return `Register`;\n  }\n})();\n\nexport const CheckSyscallRegister: Checker<SyscallRegister> = new (class {\n  declare type: SyscallRegister;\n  validate(value: unknown): value is SyscallRegister {\n    switch (value) {\n      case $s0:\n      case $s1:\n      case $t0:\n      case $t1:\n      case $v0:\n        return true;\n      default:\n        return false;\n    }\n  }\n  expected(): string {\n    return `syscall register ($s0, $s1, $t0, $t1, $v0)`;\n  }\n})();\n\nexport const CheckMachineRegister: Checker<MachineRegister> = new (class {\n  declare type: MachineRegister;\n  validate(value: unknown): value is MachineRegister {\n    switch (value) {\n      case $sp:\n      case $fp:\n      case $ra:\n      case $pc:\n        return true;\n      default:\n        return false;\n    }\n  }\n  expected(): string {\n    return `machine register ($sp, $fp, $ra, $pc)`;\n  }\n})();\n\nexport function CheckNullable<T>(checker: Checker<T>): Checker<Nullable<T>>;\nexport function CheckNullable<T>(checker: Checker<T>): Checker<Nullable<T>> | undefined {\n  if (LOCAL_DEBUG) {\n    return new OptionChecker(checker, null);\n  }\n}\n\nexport function CheckMaybe<T>(checker: Checker<T>): Checker<Maybe<T>>;\nexport function CheckMaybe<T>(checker: Checker<T>): Checker<Maybe<T>> | undefined {\n  if (LOCAL_DEBUG) {\n    return new MaybeChecker(checker);\n  }\n}\n\nexport function CheckInterface<\n  I extends { [P in keyof O]: O[P]['type'] },\n  O extends Dict<Checker<unknown>>,\n>(obj: O): Checker<I>;\nexport function CheckInterface<\n  I extends { [P in keyof O]: O[P]['type'] },\n  O extends Dict<Checker<unknown>>,\n>(obj: O): Checker<I> | undefined {\n  if (LOCAL_DEBUG) {\n    return new PropertyChecker(obj);\n  }\n}\n\nexport function CheckArray<T>(obj: Checker<T>): Checker<T[]>;\nexport function CheckArray<T>(obj: Checker<T>): Checker<T[]> | undefined {\n  if (LOCAL_DEBUG) {\n    return new ArrayChecker(obj);\n  }\n}\n\nexport function CheckDict<T>(obj: Checker<T>): Checker<Dict<T>>;\nexport function CheckDict<T>(obj: Checker<T>): Checker<Dict<T>> | undefined {\n  if (LOCAL_DEBUG) {\n    return new DictChecker(obj);\n  }\n}\n\nfunction defaultMessage(value: unknown, expected: string): string {\n  return `Got ${value}, expected:\\n${expected}`;\n}\n\n/*@__PURE__*/\nexport function check<T>(\n  value: unknown,\n  checker: Checker<T>,\n  message?: (value: unknown, expected: string) => string\n): T;\nexport function check<T, U extends T>(value: T, checker: (value: T) => asserts value is U): U;\nexport function check<T>(\n  value: unknown,\n  checker: Checker<T> | ((value: unknown) => void),\n  message?: (value: unknown, expected: string) => string\n): T {\n  if (!LOCAL_DEBUG) {\n    return value as T;\n  }\n\n  if (typeof checker === 'function') {\n    checker(value);\n    return value as T;\n  }\n  if (checker.validate(value)) {\n    return value;\n  } else {\n    throw new Error((message ?? defaultMessage)(value, checker.expected()));\n  }\n}\n\nlet size = 0;\n\nexport function recordStackSize(sp: number) {\n  size = sp;\n}\n\nexport function expectStackChange(stack: { sp: number }, expected: number, name: string) {\n  if (LOCAL_DEBUG) {\n    return;\n  }\n\n  let actual = stack.sp - size;\n\n  if (actual === expected) return;\n\n  throw new Error(\n    `Expected stack to change by ${expected}, but it changed by ${actual} in ${name}`\n  );\n}\n\nexport const CheckPrimitive: Checker<Primitive> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new PrimitiveChecker();\nexport const CheckFunction: Checker<AnyFn> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<AnyFn>('function');\nexport const CheckNumber: Checker<number> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<number>('number');\nexport const CheckBoolean: Checker<boolean> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<boolean>('boolean');\nexport const CheckHandle: Checker<number> = LOCAL_DEBUG ? CheckNumber : new NoopChecker();\nexport const CheckString: Checker<string> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<string>('string');\nexport const CheckNull: Checker<null> = !LOCAL_DEBUG ? new NoopChecker() : new NullChecker();\nexport const CheckUndefined: Checker<undefined> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new UndefinedChecker();\nexport const CheckUnknown: Checker<unknown> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new OpaqueChecker();\nexport const CheckSafeString: Checker<SafeString> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new SafeStringChecker();\nexport const CheckObject: Checker<object> = !LOCAL_DEBUG ? new NoopChecker() : new ObjectChecker();\n\nexport function CheckOr<T, U>(left: Checker<T>, right: Checker<U>): Checker<T | U> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker<T | U>();\n  }\n  return new OrChecker(left, right);\n}\n\nexport function CheckValue<T>(value: T, desc = String(value)): Checker<T> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker<T>();\n  }\n  return new ExactValueChecker(value, desc);\n}\n\nexport const CheckBlockSymbolTable: Checker<BlockSymbolTable> = LOCAL_DEBUG\n  ? CheckInterface({\n      parameters: CheckArray(CheckNumber),\n    })\n  : new NoopChecker();\n\nexport const CheckProgramSymbolTable: Checker<ProgramSymbolTable> = LOCAL_DEBUG\n  ? CheckInterface({\n      symbols: CheckArray(CheckString),\n    })\n  : new NoopChecker();\n\nexport const CheckElement: Checker<SimpleElement> = LOCAL_DEBUG\n  ? CheckInterface({\n      nodeType: CheckValue(1),\n      tagName: CheckString,\n      nextSibling: CheckUnknown,\n    })\n  : new NoopChecker();\n\nexport const CheckDocumentFragment: Checker<SimpleDocumentFragment> = LOCAL_DEBUG\n  ? CheckInterface({\n      nodeType: CheckValue(11),\n      nextSibling: CheckUnknown,\n    })\n  : new NoopChecker();\n\nexport const CheckNode: Checker<SimpleNode> = LOCAL_DEBUG\n  ? CheckInterface({\n      nodeType: CheckNumber,\n      nextSibling: CheckUnknown,\n    })\n  : new NoopChecker();\n","import type { DebugOp, SomeDisassembledOperand } from '@glimmer/debug';\nimport type {\n  DebugVmSnapshot,\n  Dict,\n  Maybe,\n  Nullable,\n  Optional,\n  RuntimeOp,\n  SomeVmOp,\n  VmMachineOp,\n  VmOp,\n} from '@glimmer/interfaces';\nimport { VM_SYSCALL_SIZE } from '@glimmer/constants';\nimport {\n  DebugLogger,\n  debugOp,\n  describeOp,\n  describeOpcode,\n  frag,\n  opcodeMetadata,\n  recordStackSize,\n  VmSnapshot,\n} from '@glimmer/debug';\nimport { dev, localAssert, unwrap } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG, LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\nimport { $pc, $ra, $s0, $s1, $sp, $t0, $t1, $v0 } from '@glimmer/vm';\n\nimport type { LowLevelVM, VM } from './vm';\nimport type { Externs } from './vm/low-level';\n\nexport interface OpcodeJSON {\n  type: number | string;\n  guid?: Nullable<number>;\n  deopted?: boolean;\n  args?: string[];\n  details?: Dict<Nullable<string>>;\n  children?: OpcodeJSON[];\n}\n\nexport type Operand1 = number;\nexport type Operand2 = number;\nexport type Operand3 = number;\n\nexport type Syscall = (vm: VM, opcode: RuntimeOp) => void;\nexport type MachineOpcode = (vm: LowLevelVM, opcode: RuntimeOp) => void;\n\nexport type Evaluate =\n  | { syscall: true; evaluate: Syscall }\n  | { syscall: false; evaluate: MachineOpcode };\n\nexport type DebugState = {\n  opcode: {\n    type: VmMachineOp | VmOp;\n    isMachine: 0 | 1;\n    size: number;\n  };\n  closeGroup?: undefined | (() => void);\n  params?: Optional<Dict<SomeDisassembledOperand>>;\n  op?: Optional<DebugOp>;\n  debug: DebugVmSnapshot;\n  snapshot: VmSnapshot;\n};\n\nexport class AppendOpcodes {\n  // This code is intentionally putting unsafe `null`s into the array that it\n  // will intentionally overwrite before anyone can see them.\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  private evaluateOpcode: Evaluate[] = new Array(VM_SYSCALL_SIZE).fill(null);\n\n  declare debugBefore?: (vm: DebugVmSnapshot, opcode: RuntimeOp) => DebugState;\n  declare debugAfter?: (debug: DebugVmSnapshot, pre: DebugState) => void;\n\n  constructor() {\n    if (LOCAL_DEBUG) {\n      this.debugBefore = (debug: DebugVmSnapshot, opcode: RuntimeOp): DebugState => {\n        let opcodeSnapshot = {\n          type: opcode.type,\n          size: opcode.size,\n          isMachine: opcode.isMachine,\n        } as const;\n\n        let snapshot = new VmSnapshot(opcodeSnapshot, debug);\n        let params: Maybe<Dict<SomeDisassembledOperand>> = undefined;\n        let op: DebugOp | undefined = undefined;\n        let closeGroup: (() => void) | undefined;\n\n        if (LOCAL_TRACE_LOGGING) {\n          const logger = DebugLogger.configured();\n\n          let pos = debug.registers[$pc] - opcode.size;\n\n          op = debugOp(debug.context.program, opcode, debug.template);\n\n          closeGroup = logger\n            .group(frag`${pos}. ${describeOp(opcode, debug.context.program, debug.template)}`)\n            .expanded();\n\n          let debugParams = [];\n          for (let [name, param] of Object.entries(op.params)) {\n            const value = param.value;\n            if (value !== null && (typeof value === 'object' || typeof value === 'function')) {\n              debugParams.push(name, '=', value);\n            }\n          }\n          LOCAL_LOGGER.debug(...debugParams);\n        }\n\n        recordStackSize(debug.registers[$sp]);\n        return {\n          op,\n          closeGroup,\n          params,\n          opcode: opcodeSnapshot,\n          debug,\n          snapshot,\n        };\n      };\n\n      this.debugAfter = (postSnapshot: DebugVmSnapshot, pre: DebugState) => {\n        let post = new VmSnapshot(pre.opcode, postSnapshot);\n        let diff = pre.snapshot.diff(post);\n        let {\n          opcode: { type },\n        } = pre;\n\n        let sp = diff.registers[$sp];\n\n        let meta = opcodeMetadata(type);\n        let actualChange = sp.after - sp.before;\n        if (\n          meta &&\n          meta.check !== false &&\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          typeof meta.stackChange! === 'number' &&\n          meta.stackChange !== actualChange\n        ) {\n          throw new Error(\n            `Error in ${pre.op?.name}:\\n\\n${pre.debug.registers[$pc]}. ${\n              pre.op ? describeOpcode(pre.op.name, pre.params) : unwrap(opcodeMetadata(type)).name\n            }\\n\\nStack changed by ${actualChange}, expected ${meta.stackChange}`\n          );\n        }\n\n        if (LOCAL_TRACE_LOGGING) {\n          const logger = DebugLogger.configured();\n\n          logger.log(diff.registers[$pc].describe());\n          logger.log(diff.registers[$ra].describe());\n          logger.log(diff.registers[$s0].describe());\n          logger.log(diff.registers[$s1].describe());\n          logger.log(diff.registers[$t0].describe());\n          logger.log(diff.registers[$t1].describe());\n          logger.log(diff.registers[$v0].describe());\n          logger.log(diff.stack.describe());\n          logger.log(diff.destructors.describe());\n          logger.log(diff.scope.describe());\n\n          if (diff.constructing.didChange || diff.blocks.change) {\n            const done = logger.group(`tree construction`).expanded();\n            try {\n              logger.log(diff.constructing.describe());\n              logger.log(diff.blocks.describe());\n              logger.log(diff.cursors.describe());\n            } finally {\n              done();\n            }\n          }\n\n          pre.closeGroup?.();\n        }\n      };\n    }\n  }\n\n  add<Name extends VmOp>(name: Name, evaluate: Syscall): void;\n  add<Name extends VmMachineOp>(name: Name, evaluate: MachineOpcode, kind: 'machine'): void;\n  add<Name extends SomeVmOp>(\n    name: Name,\n    evaluate: Syscall | MachineOpcode,\n    kind = 'syscall'\n  ): void {\n    this.evaluateOpcode[name as number] = {\n      syscall: kind !== 'machine',\n      evaluate,\n    } as Evaluate;\n  }\n\n  evaluate(vm: VM, opcode: RuntimeOp, type: number) {\n    let operation = unwrap(this.evaluateOpcode[type]);\n\n    if (operation.syscall) {\n      localAssert(\n        !opcode.isMachine,\n        `BUG: Mismatch between operation.syscall (${operation.syscall}) and opcode.isMachine (${opcode.isMachine}) for ${opcode.type}`\n      );\n      operation.evaluate(vm, opcode);\n    } else {\n      localAssert(\n        opcode.isMachine,\n        `BUG: Mismatch between operation.syscall (${operation.syscall}) and opcode.isMachine (${opcode.isMachine}) for ${opcode.type}`\n      );\n      operation.evaluate(vm.lowlevel, opcode);\n    }\n  }\n}\n\nexport function externs(vm: VM): Externs | undefined {\n  return LOCAL_DEBUG\n    ? {\n        debugBefore: (opcode: RuntimeOp): DebugState => {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          return APPEND_OPCODES.debugBefore!(dev(vm.debug), opcode);\n        },\n\n        debugAfter: (state: DebugState): void => {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          APPEND_OPCODES.debugAfter!(dev(vm.debug), state);\n        },\n      }\n    : undefined;\n}\n\nexport const APPEND_OPCODES = new AppendOpcodes();\n","import type {\n  VmAppendDocumentFragment,\n  VmAppendHTML,\n  VmAppendNode,\n  VmAppendSafeHTML,\n  VmAppendText,\n  VmAssertSame,\n  VmBeginComponentTransaction,\n  VmBindDynamicScope,\n  VmCaptureArgs,\n  VmChildScope,\n  VmCloseElement,\n  VmComment,\n  VmCommitComponentTransaction,\n  VmCompileBlock,\n  VmComponentAttr,\n  VmConcat,\n  VmConstant,\n  VmConstantReference,\n  VmContentType,\n  VmCreateComponent,\n  VmCurry,\n  VmDebugger,\n  VmDidCreateElement,\n  VmDidRenderLayout,\n  VmDup,\n  VmDynamicAttr,\n  VmDynamicContentType,\n  VmDynamicHelper,\n  VmDynamicModifier,\n  VmEnter,\n  VmEnterList,\n  VmExit,\n  VmExitList,\n  VmFetch,\n  VmFlushElement,\n  VmGetBlock,\n  VmGetComponentLayout,\n  VmGetComponentSelf,\n  VmGetComponentTagName,\n  VmGetDynamicVar,\n  VmGetProperty,\n  VmGetVariable,\n  VmHasBlock,\n  VmHasBlockParams,\n  VmHelper,\n  VmIfInline,\n  VmInvokeComponentLayout,\n  VmInvokeYield,\n  VmIterate,\n  VmJumpEq,\n  VmJumpIf,\n  VmJumpUnless,\n  VmLoad,\n  VmLog,\n  VmMain,\n  VmModifier,\n  VmNot,\n  VmOp,\n  VmOpenDynamicElement,\n  VmOpenElement,\n  VmPop,\n  VmPopArgs,\n  VmPopDynamicScope,\n  VmPopRemoteElement,\n  VmPopScope,\n  VmPopulateLayout,\n  VmPrepareArgs,\n  VmPrimitive,\n  VmPrimitiveReference,\n  VmPushArgs,\n  VmPushBlockScope,\n  VmPushComponentDefinition,\n  VmPushDynamicComponentInstance,\n  VmPushDynamicScope,\n  VmPushEmptyArgs,\n  VmPushRemoteElement,\n  VmPushSymbolTable,\n  VmPutComponentOperations,\n  VmRegisterComponentDestructor,\n  VmReifyU32,\n  VmResolveCurriedComponent,\n  VmResolveDynamicComponent,\n  VmRootScope,\n  VmSetBlock,\n  VmSetBlocks,\n  VmSetNamedVariables,\n  VmSetVariable,\n  VmSize,\n  VmSpreadBlock,\n  VmStaticAttr,\n  VmStaticComponentAttr,\n  VmText,\n  VmToBoolean,\n  VmVirtualRootScope,\n} from '@glimmer/interfaces';\n\nexport const VM_HELPER_OP = 16 satisfies VmHelper;\nexport const VM_SET_NAMED_VARIABLES_OP = 17 satisfies VmSetNamedVariables;\nexport const VM_SET_BLOCKS_OP = 18 satisfies VmSetBlocks;\nexport const VM_SET_VARIABLE_OP = 19 satisfies VmSetVariable;\nexport const VM_SET_BLOCK_OP = 20 satisfies VmSetBlock;\nexport const VM_GET_VARIABLE_OP = 21 satisfies VmGetVariable;\nexport const VM_GET_PROPERTY_OP = 22 satisfies VmGetProperty;\nexport const VM_GET_BLOCK_OP = 23 satisfies VmGetBlock;\nexport const VM_SPREAD_BLOCK_OP = 24 satisfies VmSpreadBlock;\nexport const VM_HAS_BLOCK_OP = 25 satisfies VmHasBlock;\nexport const VM_HAS_BLOCK_PARAMS_OP = 26 satisfies VmHasBlockParams;\nexport const VM_CONCAT_OP = 27 satisfies VmConcat;\nexport const VM_CONSTANT_OP = 28 satisfies VmConstant;\nexport const VM_CONSTANT_REFERENCE_OP = 29 satisfies VmConstantReference;\nexport const VM_PRIMITIVE_OP = 30 satisfies VmPrimitive;\nexport const VM_PRIMITIVE_REFERENCE_OP = 31 satisfies VmPrimitiveReference;\nexport const VM_REIFY_U32_OP = 32 satisfies VmReifyU32;\nexport const VM_DUP_OP = 33 satisfies VmDup;\nexport const VM_POP_OP = 34 satisfies VmPop;\nexport const VM_LOAD_OP = 35 satisfies VmLoad;\nexport const VM_FETCH_OP = 36 satisfies VmFetch;\nexport const VM_ROOT_SCOPE_OP = 37 satisfies VmRootScope;\nexport const VM_VIRTUAL_ROOT_SCOPE_OP = 38 satisfies VmVirtualRootScope;\nexport const VM_CHILD_SCOPE_OP = 39 satisfies VmChildScope;\nexport const VM_POP_SCOPE_OP = 40 satisfies VmPopScope;\nexport const VM_TEXT_OP = 41 satisfies VmText;\nexport const VM_COMMENT_OP = 42 satisfies VmComment;\nexport const VM_APPEND_HTML_OP = 43 satisfies VmAppendHTML;\nexport const VM_APPEND_SAFE_HTML_OP = 44 satisfies VmAppendSafeHTML;\nexport const VM_APPEND_DOCUMENT_FRAGMENT_OP = 45 satisfies VmAppendDocumentFragment;\nexport const VM_APPEND_NODE_OP = 46 satisfies VmAppendNode;\nexport const VM_APPEND_TEXT_OP = 47 satisfies VmAppendText;\nexport const VM_OPEN_ELEMENT_OP = 48 satisfies VmOpenElement;\nexport const VM_OPEN_DYNAMIC_ELEMENT_OP = 49 satisfies VmOpenDynamicElement;\nexport const VM_PUSH_REMOTE_ELEMENT_OP = 50 satisfies VmPushRemoteElement;\nexport const VM_STATIC_ATTR_OP = 51 satisfies VmStaticAttr;\nexport const VM_DYNAMIC_ATTR_OP = 52 satisfies VmDynamicAttr;\nexport const VM_COMPONENT_ATTR_OP = 53 satisfies VmComponentAttr;\nexport const VM_FLUSH_ELEMENT_OP = 54 satisfies VmFlushElement;\nexport const VM_CLOSE_ELEMENT_OP = 55 satisfies VmCloseElement;\nexport const VM_POP_REMOTE_ELEMENT_OP = 56 satisfies VmPopRemoteElement;\nexport const VM_MODIFIER_OP = 57 satisfies VmModifier;\nexport const VM_BIND_DYNAMIC_SCOPE_OP = 58 satisfies VmBindDynamicScope;\nexport const VM_PUSH_DYNAMIC_SCOPE_OP = 59 satisfies VmPushDynamicScope;\nexport const VM_POP_DYNAMIC_SCOPE_OP = 60 satisfies VmPopDynamicScope;\nexport const VM_COMPILE_BLOCK_OP = 61 satisfies VmCompileBlock;\nexport const VM_PUSH_BLOCK_SCOPE_OP = 62 satisfies VmPushBlockScope;\nexport const VM_PUSH_SYMBOL_TABLE_OP = 63 satisfies VmPushSymbolTable;\nexport const VM_INVOKE_YIELD_OP = 64 satisfies VmInvokeYield;\nexport const VM_JUMP_IF_OP = 65 satisfies VmJumpIf;\nexport const VM_JUMP_UNLESS_OP = 66 satisfies VmJumpUnless;\nexport const VM_JUMP_EQ_OP = 67 satisfies VmJumpEq;\nexport const VM_ASSERT_SAME_OP = 68 satisfies VmAssertSame;\nexport const VM_ENTER_OP = 69 satisfies VmEnter;\nexport const VM_EXIT_OP = 70 satisfies VmExit;\nexport const VM_TO_BOOLEAN_OP = 71 satisfies VmToBoolean;\nexport const VM_ENTER_LIST_OP = 72 satisfies VmEnterList;\nexport const VM_EXIT_LIST_OP = 73 satisfies VmExitList;\nexport const VM_ITERATE_OP = 74 satisfies VmIterate;\nexport const VM_MAIN_OP = 75 satisfies VmMain;\nexport const VM_CONTENT_TYPE_OP = 76 satisfies VmContentType;\nexport const VM_CURRY_OP = 77 satisfies VmCurry;\nexport const VM_PUSH_COMPONENT_DEFINITION_OP = 78 satisfies VmPushComponentDefinition;\nexport const VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP = 79 satisfies VmPushDynamicComponentInstance;\nexport const VM_RESOLVE_DYNAMIC_COMPONENT_OP = 80 satisfies VmResolveDynamicComponent;\nexport const VM_RESOLVE_CURRIED_COMPONENT_OP = 81 satisfies VmResolveCurriedComponent;\nexport const VM_PUSH_ARGS_OP = 82 satisfies VmPushArgs;\nexport const VM_PUSH_EMPTY_ARGS_OP = 83 satisfies VmPushEmptyArgs;\nexport const VM_POP_ARGS_OP = 84 satisfies VmPopArgs;\nexport const VM_PREPARE_ARGS_OP = 85 satisfies VmPrepareArgs;\nexport const VM_CAPTURE_ARGS_OP = 86 satisfies VmCaptureArgs;\nexport const VM_CREATE_COMPONENT_OP = 87 satisfies VmCreateComponent;\nexport const VM_REGISTER_COMPONENT_DESTRUCTOR_OP = 88 satisfies VmRegisterComponentDestructor;\nexport const VM_PUT_COMPONENT_OPERATIONS_OP = 89 satisfies VmPutComponentOperations;\nexport const VM_GET_COMPONENT_SELF_OP = 90 satisfies VmGetComponentSelf;\nexport const VM_GET_COMPONENT_TAG_NAME_OP = 91 satisfies VmGetComponentTagName;\nexport const VM_GET_COMPONENT_LAYOUT_OP = 92 satisfies VmGetComponentLayout;\nexport const VM_POPULATE_LAYOUT_OP = 95 satisfies VmPopulateLayout;\nexport const VM_INVOKE_COMPONENT_LAYOUT_OP = 96 satisfies VmInvokeComponentLayout;\nexport const VM_BEGIN_COMPONENT_TRANSACTION_OP = 97 satisfies VmBeginComponentTransaction;\nexport const VM_COMMIT_COMPONENT_TRANSACTION_OP = 98 satisfies VmCommitComponentTransaction;\nexport const VM_DID_CREATE_ELEMENT_OP = 99 satisfies VmDidCreateElement;\nexport const VM_DID_RENDER_LAYOUT_OP = 100 satisfies VmDidRenderLayout;\nexport const VM_DEBUGGER_OP = 103 satisfies VmDebugger;\nexport const VM_STATIC_COMPONENT_ATTR_OP = 105 satisfies VmStaticComponentAttr;\nexport const VM_DYNAMIC_CONTENT_TYPE_OP = 106 satisfies VmDynamicContentType;\nexport const VM_DYNAMIC_HELPER_OP = 107 satisfies VmDynamicHelper;\nexport const VM_DYNAMIC_MODIFIER_OP = 108 satisfies VmDynamicModifier;\nexport const VM_IF_INLINE_OP = 109 satisfies VmIfInline;\nexport const VM_NOT_OP = 110 satisfies VmNot;\nexport const VM_GET_DYNAMIC_VAR_OP = 111 satisfies VmGetDynamicVar;\nexport const VM_LOG_OP = 112 satisfies VmLog;\nexport const VM_SYSCALL_SIZE = 113 satisfies VmSize;\n\nexport function isOp(value: number): value is VmOp {\n  return value >= 16;\n}\n","import type {\n  CapturedArguments,\n  CurriedComponent,\n  CurriedHelper,\n  CurriedModifier,\n  CurriedType,\n  Owner,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\n\nconst TYPE: unique symbol = Symbol('TYPE');\nconst INNER: unique symbol = Symbol('INNER');\nconst OWNER: unique symbol = Symbol('OWNER');\nconst ARGS: unique symbol = Symbol('ARGS');\nconst RESOLVED: unique symbol = Symbol('RESOLVED');\n\nconst CURRIED_VALUES = new WeakSet();\n\nexport function isCurriedValue(value: unknown): value is CurriedValue {\n  return CURRIED_VALUES.has(value as object);\n}\n\nexport function isCurriedType<T extends CurriedType>(\n  value: unknown,\n  type: T\n): value is CurriedValue<T> {\n  return isCurriedValue(value) && value[TYPE] === type;\n}\n\nexport class CurriedValue<T extends CurriedType = CurriedType> {\n  [TYPE]: T;\n  [INNER]: object | string | CurriedValue<T>;\n  [OWNER]: Owner;\n  [ARGS]: CapturedArguments | null;\n  [RESOLVED]: boolean;\n\n  /** @internal */\n  constructor(\n    type: T,\n    inner: object | string | CurriedValue<T>,\n    owner: Owner,\n    args: CapturedArguments | null,\n    resolved = false\n  ) {\n    CURRIED_VALUES.add(this);\n    this[TYPE] = type;\n    this[INNER] = inner;\n    this[OWNER] = owner;\n    this[ARGS] = args;\n    this[RESOLVED] = resolved;\n  }\n}\n\ninterface ResolvedCurriedValue<T> {\n  definition: T;\n  owner: Owner;\n  resolved: boolean;\n  positional: Reference[] | undefined;\n  named: Record<string, Reference>[] | undefined;\n}\n\nexport function resolveCurriedValue(\n  curriedValue: CurriedValue<CurriedComponent>\n): ResolvedCurriedValue<object | string>;\nexport function resolveCurriedValue(\n  curriedValue: CurriedValue<CurriedHelper> | CurriedValue<CurriedModifier>\n): ResolvedCurriedValue<object>;\nexport function resolveCurriedValue(\n  curriedValue: CurriedValue\n): ResolvedCurriedValue<object | string> {\n  let currentWrapper = curriedValue;\n  let positional: Reference[] | undefined;\n  let named: Record<string, Reference>[] | undefined;\n  let definition, owner, resolved;\n\n  while (true) {\n    let { [ARGS]: curriedArgs, [INNER]: inner } = currentWrapper;\n\n    if (curriedArgs !== null) {\n      let { named: curriedNamed, positional: curriedPositional } = curriedArgs;\n\n      if (curriedPositional.length > 0) {\n        positional =\n          positional === undefined ? curriedPositional : curriedPositional.concat(positional);\n      }\n\n      if (named === undefined) {\n        named = [];\n      }\n\n      named.unshift(curriedNamed);\n    }\n\n    if (!isCurriedValue(inner)) {\n      // Save off the owner that this helper was curried with. Later on,\n      // we'll fetch the value of this register and set it as the owner on the\n      // new root scope.\n      definition = inner;\n      owner = currentWrapper[OWNER];\n      resolved = currentWrapper[RESOLVED];\n      break;\n    }\n\n    currentWrapper = inner;\n  }\n\n  return { definition, owner, resolved, positional, named };\n}\n\nexport function curry<T extends CurriedType>(\n  type: T,\n  spec: object | string | CurriedValue<T>,\n  owner: Owner,\n  args: CapturedArguments | null,\n  resolved = false\n): CurriedValue<T> {\n  return new CurriedValue(type, spec, owner, args, resolved);\n}\n","import type {\n  Dict,\n  DynamicScope,\n  Nullable,\n  Owner,\n  Scope,\n  ScopeBlock,\n  ScopeSlot,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { unwrap } from '@glimmer/debug-util';\nimport { UNDEFINED_REFERENCE } from '@glimmer/reference';\nimport { assign } from '@glimmer/util';\n\nexport class DynamicScopeImpl implements DynamicScope {\n  private bucket: Dict<Reference>;\n\n  constructor(bucket?: Dict<Reference>) {\n    if (bucket) {\n      this.bucket = assign({}, bucket);\n    } else {\n      this.bucket = {};\n    }\n  }\n\n  get(key: string): Reference {\n    return unwrap(this.bucket[key]);\n  }\n\n  set(key: string, reference: Reference): Reference {\n    return (this.bucket[key] = reference);\n  }\n\n  child(): DynamicScopeImpl {\n    return new DynamicScopeImpl(this.bucket);\n  }\n}\n\nexport function isScopeReference(s: ScopeSlot): s is Reference {\n  if (s === null || Array.isArray(s)) return false;\n  return true;\n}\n\nexport interface ScopeOptions {\n  /** @default {UNDEFINED_REFERENCE} */\n  self: Reference;\n  /** @default {0} */\n  size?: number | undefined;\n}\n\nexport class ScopeImpl implements Scope {\n  static root(owner: Owner, { self, size = 0 }: ScopeOptions): Scope {\n    let refs = new Array<Reference>(size + 1).fill(UNDEFINED_REFERENCE);\n\n    return new ScopeImpl(owner, refs, null).init({ self });\n  }\n\n  static sized(owner: Owner, size = 0): Scope {\n    let refs = new Array<Reference>(size + 1).fill(UNDEFINED_REFERENCE);\n\n    return new ScopeImpl(owner, refs, null);\n  }\n\n  readonly owner: Owner;\n\n  private slots: ScopeSlot[];\n  private callerScope: Nullable<Scope>;\n\n  constructor(\n    owner: Owner,\n    // the 0th slot is `self`\n    slots: Array<ScopeSlot>,\n    // a single program can mix owners via curried components, and the state lives on root scopes\n    callerScope: Nullable<Scope>\n  ) {\n    this.owner = owner;\n    this.slots = slots;\n    this.callerScope = callerScope;\n  }\n\n  init({ self }: { self: Reference }): this {\n    this.slots[0] = self;\n    return this;\n  }\n\n  /**\n   * @debug\n   */\n  snapshot(): ScopeSlot[] {\n    return this.slots.slice();\n  }\n\n  getSelf(): Reference {\n    return this.get<Reference>(0);\n  }\n\n  getSymbol(symbol: number): Reference {\n    return this.get<Reference>(symbol);\n  }\n\n  getBlock(symbol: number): Nullable<ScopeBlock> {\n    let block = this.get(symbol);\n    return block === UNDEFINED_REFERENCE ? null : (block as ScopeBlock);\n  }\n\n  bind(symbol: number, value: ScopeSlot) {\n    this.set(symbol, value);\n  }\n\n  bindSelf(self: Reference) {\n    this.set<Reference>(0, self);\n  }\n\n  bindSymbol(symbol: number, value: Reference) {\n    this.set(symbol, value);\n  }\n\n  bindBlock(symbol: number, value: Nullable<ScopeBlock>) {\n    this.set<Nullable<ScopeBlock>>(symbol, value);\n  }\n\n  bindCallerScope(scope: Nullable<Scope>): void {\n    this.callerScope = scope;\n  }\n\n  getCallerScope(): Nullable<Scope> {\n    return this.callerScope;\n  }\n\n  child(): Scope {\n    return new ScopeImpl(this.owner, this.slots.slice(), this.callerScope);\n  }\n\n  private get<T extends ScopeSlot>(index: number): T {\n    if (index >= this.slots.length) {\n      throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    }\n\n    return this.slots[index] as T;\n  }\n\n  private set<T extends ScopeSlot>(index: number, value: T): void {\n    if (index >= this.slots.length) {\n      throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    }\n\n    this.slots[index] = value;\n  }\n}\n","import type { Bounds, Cursor, Nullable, SimpleElement, SimpleNode } from '@glimmer/interfaces';\nimport { expect, setLocalDebugType } from '@glimmer/debug-util';\n\nexport class CursorImpl implements Cursor {\n  constructor(\n    public element: SimpleElement,\n    public nextSibling: Nullable<SimpleNode>\n  ) {\n    setLocalDebugType('cursor', this);\n  }\n}\n\nexport type DestroyableBounds = Bounds;\n\nexport class ConcreteBounds implements Bounds {\n  constructor(\n    public parentNode: SimpleElement,\n    private first: SimpleNode,\n    private last: SimpleNode\n  ) {}\n\n  parentElement(): SimpleElement {\n    return this.parentNode;\n  }\n\n  firstNode(): SimpleNode {\n    return this.first;\n  }\n\n  lastNode(): SimpleNode {\n    return this.last;\n  }\n}\n\nexport function move(bounds: Bounds, reference: Nullable<SimpleNode>): Nullable<SimpleNode> {\n  let parent = bounds.parentElement();\n  let first = bounds.firstNode();\n  let last = bounds.lastNode();\n\n  let current: SimpleNode = first;\n\n  while (true) {\n    let next = current.nextSibling;\n\n    parent.insertBefore(current, reference);\n\n    if (current === last) {\n      return next;\n    }\n\n    current = expect(next, 'invalid bounds');\n  }\n}\n\nexport function clear(bounds: Bounds): Nullable<SimpleNode> {\n  let parent = bounds.parentElement();\n  let first = bounds.firstNode();\n  let last = bounds.lastNode();\n\n  let current: SimpleNode = first;\n\n  while (true) {\n    let next = current.nextSibling;\n\n    parent.removeChild(current);\n\n    if (current === last) {\n      return next;\n    }\n\n    current = expect(next, 'invalid bounds');\n  }\n}\n","import type {\n  ComponentDefinitionState,\n  ComponentInstanceState,\n  InternalComponentManager,\n  WithCustomDebugRenderTree,\n} from '@glimmer/interfaces';\n\n/** @internal */\nexport function hasCustomDebugRenderTreeLifecycle<\n  D extends ComponentDefinitionState,\n  I extends ComponentInstanceState,\n>(manager: InternalComponentManager<I, D>): manager is WithCustomDebugRenderTree<I, D> {\n  return 'getDebugCustomRenderTree' in manager;\n}\n","import type {\n  Bounds,\n  CapturedRenderNode,\n  ComponentDefinition,\n  DebugRenderTree,\n  Nullable,\n  RenderNode,\n} from '@glimmer/interfaces';\nimport { expect } from '@glimmer/debug-util';\nimport { assign, Stack } from '@glimmer/util';\n\nimport { reifyArgsDebug } from './vm/arguments';\n\ninterface InternalRenderNode<T extends object> extends RenderNode {\n  bounds: Nullable<Bounds>;\n  refs: Set<Ref<T>>;\n  parent?: InternalRenderNode<T>;\n}\n\nlet GUID = 0;\n\nexport class Ref<T extends object> {\n  readonly id: number = GUID++;\n  private value: Nullable<T>;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  get(): Nullable<T> {\n    return this.value;\n  }\n\n  release(): void {\n    if (import.meta.env.DEV && this.value === null) {\n      throw new Error('BUG: double release?');\n    }\n\n    this.value = null;\n  }\n\n  toString(): string {\n    let label = `Ref ${this.id}`;\n\n    if (this.value === null) {\n      return `${label} (released)`;\n    } else {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string\n        return `${label}: ${this.value}`;\n      } catch {\n        return label;\n      }\n    }\n  }\n}\n\nexport default class DebugRenderTreeImpl<TBucket extends object>\n  implements DebugRenderTree<TBucket>\n{\n  private stack = new Stack<TBucket>();\n\n  private refs = new WeakMap<TBucket, Ref<TBucket>>();\n  private roots = new Set<Ref<TBucket>>();\n  private nodes = new WeakMap<TBucket, InternalRenderNode<TBucket>>();\n\n  begin(): void {\n    this.reset();\n  }\n\n  create(state: TBucket, node: RenderNode): void {\n    let internalNode: InternalRenderNode<TBucket> = assign({}, node, {\n      bounds: null,\n      refs: new Set<Ref<TBucket>>(),\n    });\n    this.nodes.set(state, internalNode);\n    this.appendChild(internalNode, state);\n    this.enter(state);\n  }\n\n  update(state: TBucket): void {\n    this.enter(state);\n  }\n\n  didRender(state: TBucket, bounds: Bounds): void {\n    if (import.meta.env.DEV && this.stack.current !== state) {\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      throw new Error(`BUG: expecting ${this.stack.current}, got ${state}`);\n    }\n\n    this.nodeFor(state).bounds = bounds;\n    this.exit();\n  }\n\n  willDestroy(state: TBucket): void {\n    expect(this.refs.get(state), 'BUG: missing ref').release();\n  }\n\n  commit(): void {\n    this.reset();\n  }\n\n  capture(): CapturedRenderNode[] {\n    return this.captureRefs(this.roots);\n  }\n\n  private reset(): void {\n    if (this.stack.size !== 0) {\n      // We probably encountered an error during the rendering loop. This will\n      // likely trigger undefined behavior and memory leaks as the error left\n      // things in an inconsistent state. It is recommended that the user\n      // refresh the page.\n\n      // TODO: We could warn here? But this happens all the time in our tests?\n\n      // Clean up the root reference to prevent errors from happening if we\n      // attempt to capture the render tree (Ember Inspector may do this)\n      let root = expect(this.stack.toArray()[0], 'expected root state when resetting render tree');\n      let ref = this.refs.get(root);\n\n      if (ref !== undefined) {\n        this.roots.delete(ref);\n      }\n\n      while (!this.stack.isEmpty()) {\n        this.stack.pop();\n      }\n    }\n  }\n\n  private enter(state: TBucket): void {\n    this.stack.push(state);\n  }\n\n  private exit(): void {\n    if (import.meta.env.DEV && this.stack.size === 0) {\n      throw new Error('BUG: unbalanced pop');\n    }\n\n    this.stack.pop();\n  }\n\n  private nodeFor(state: TBucket): InternalRenderNode<TBucket> {\n    return expect(this.nodes.get(state), 'BUG: missing node');\n  }\n\n  private appendChild(node: InternalRenderNode<TBucket>, state: TBucket): void {\n    if (import.meta.env.DEV && this.refs.has(state)) {\n      throw new Error('BUG: child already appended');\n    }\n\n    let parent = this.stack.current;\n    let ref = new Ref(state);\n\n    this.refs.set(state, ref);\n\n    if (parent) {\n      let parentNode = this.nodeFor(parent);\n      parentNode.refs.add(ref);\n      node.parent = parentNode;\n    } else {\n      this.roots.add(ref);\n    }\n  }\n\n  private captureRefs(refs: Set<Ref<TBucket>>): CapturedRenderNode[] {\n    let captured: CapturedRenderNode[] = [];\n\n    refs.forEach((ref) => {\n      let state = ref.get();\n\n      if (state) {\n        captured.push(this.captureNode(`render-node:${ref.id}`, state));\n      } else {\n        refs.delete(ref);\n      }\n    });\n\n    return captured;\n  }\n\n  private captureNode(id: string, state: TBucket): CapturedRenderNode {\n    let node = this.nodeFor(state);\n    let { type, name, args, instance, refs } = node;\n    let template = this.captureTemplate(node);\n    let bounds = this.captureBounds(node);\n    let children = this.captureRefs(refs);\n    return { id, type, name, args: reifyArgsDebug(args), instance, template, bounds, children };\n  }\n\n  private captureTemplate({ template }: InternalRenderNode<TBucket>): Nullable<string> {\n    return template || null;\n  }\n\n  private captureBounds(node: InternalRenderNode<TBucket>): CapturedRenderNode['bounds'] {\n    let bounds = expect(node.bounds, 'BUG: missing bounds');\n    let parentElement = bounds.parentElement();\n    let firstNode = bounds.firstNode();\n    let lastNode = bounds.lastNode();\n    return { parentElement, firstNode, lastNode };\n  }\n}\n\nexport function getDebugName(\n  definition: ComponentDefinition,\n  manager = definition.manager\n): string {\n  return definition.resolvedName ?? definition.debugName ?? manager.getDebugName(definition.state);\n}\n","import type { Dict, Indexable, SimpleDocumentFragment, SimpleNode } from '@glimmer/interfaces';\n\nexport interface SafeString {\n  toHTML(): string;\n}\n\nexport type Insertion = CautiousInsertion | TrustingInsertion;\nexport type CautiousInsertion = string | SafeString | SimpleNode;\nexport type TrustingInsertion = string | SimpleNode;\n\nexport function normalizeStringValue(value: unknown): string {\n  if (isEmpty(value)) {\n    return '';\n  }\n  return String(value);\n}\n\nexport function normalizeTrustedValue(value: unknown): TrustingInsertion {\n  if (isEmpty(value)) {\n    return '';\n  }\n  if (isString(value)) {\n    return value;\n  }\n  if (isSafeString(value)) {\n    return value.toHTML();\n  }\n  if (isNode(value)) {\n    return value;\n  }\n  return String(value);\n}\n\nexport function shouldCoerce(\n  value: unknown\n): value is string | number | boolean | null | undefined {\n  return (\n    isString(value) || isEmpty(value) || typeof value === 'boolean' || typeof value === 'number'\n  );\n}\n\nexport function isEmpty(value: unknown): boolean {\n  return value === null || value === undefined || typeof (value as Dict).toString !== 'function';\n}\n\nexport function isIndexable(value: unknown): value is Indexable {\n  return value !== null && typeof value === 'object';\n}\n\nexport function isSafeString(value: unknown): value is SafeString {\n  return isIndexable(value) && typeof value['toHTML'] === 'function';\n}\n\nexport function isNode(value: unknown): value is SimpleNode {\n  return isIndexable(value) && typeof value['nodeType'] === 'number';\n}\n\nexport function isFragment(value: unknown): value is SimpleDocumentFragment {\n  return isIndexable(value) && value['nodeType'] === 11;\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n","import type { CompilableTemplate, Nullable, UpdatingOpcode } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport type { Revision, Tag } from '@glimmer/validator';\nimport {\n  decodeHandle,\n  decodeImmediate,\n  isHandle,\n  VM_ASSERT_SAME_OP,\n  VM_BIND_DYNAMIC_SCOPE_OP,\n  VM_CHILD_SCOPE_OP,\n  VM_COMPILE_BLOCK_OP,\n  VM_CONSTANT_OP,\n  VM_CONSTANT_REFERENCE_OP,\n  VM_DUP_OP,\n  VM_ENTER_OP,\n  VM_EXIT_OP,\n  VM_FETCH_OP,\n  VM_INVOKE_YIELD_OP,\n  VM_JUMP_EQ_OP,\n  VM_JUMP_IF_OP,\n  VM_JUMP_UNLESS_OP,\n  VM_LOAD_OP,\n  VM_POP_DYNAMIC_SCOPE_OP,\n  VM_POP_OP,\n  VM_POP_SCOPE_OP,\n  VM_PRIMITIVE_OP,\n  VM_PRIMITIVE_REFERENCE_OP,\n  VM_PUSH_BLOCK_SCOPE_OP,\n  VM_PUSH_DYNAMIC_SCOPE_OP,\n  VM_PUSH_SYMBOL_TABLE_OP,\n  VM_TO_BOOLEAN_OP,\n} from '@glimmer/constants';\nimport {\n  check,\n  CheckBlockSymbolTable,\n  CheckHandle,\n  CheckInstanceof,\n  CheckNullable,\n  CheckNumber,\n  CheckPrimitive,\n  CheckRegister,\n  CheckSyscallRegister,\n} from '@glimmer/debug';\nimport { expect, localAssert, unwrap } from '@glimmer/debug-util';\nimport { toBool } from '@glimmer/global-context';\nimport {\n  createComputeRef,\n  createConstRef,\n  createPrimitiveRef,\n  FALSE_REFERENCE,\n  isConstRef,\n  NULL_REFERENCE,\n  TRUE_REFERENCE,\n  UNDEFINED_REFERENCE,\n  valueForRef,\n} from '@glimmer/reference';\nimport {\n  beginTrackFrame,\n  CONSTANT_TAG,\n  consumeTag,\n  endTrackFrame,\n  INITIAL,\n  validateTag,\n  valueForTag,\n} from '@glimmer/validator';\n\nimport type { UpdatingVM } from '../../vm';\nimport type { VM } from '../../vm/append';\n\nimport { APPEND_OPCODES } from '../../opcodes';\nimport { VMArgumentsImpl } from '../../vm/arguments';\nimport { CheckReference, CheckScope } from './-debug-strip';\n\nAPPEND_OPCODES.add(VM_CHILD_SCOPE_OP, (vm) => vm.pushChildScope());\n\nAPPEND_OPCODES.add(VM_POP_SCOPE_OP, (vm) => vm.popScope());\n\nAPPEND_OPCODES.add(VM_PUSH_DYNAMIC_SCOPE_OP, (vm) => vm.pushDynamicScope());\n\nAPPEND_OPCODES.add(VM_POP_DYNAMIC_SCOPE_OP, (vm) => vm.popDynamicScope());\n\nAPPEND_OPCODES.add(VM_CONSTANT_OP, (vm, { op1: other }) => {\n  vm.stack.push(vm.constants.getValue(decodeHandle(other)));\n});\n\nAPPEND_OPCODES.add(VM_CONSTANT_REFERENCE_OP, (vm, { op1: other }) => {\n  vm.stack.push(createConstRef(vm.constants.getValue(decodeHandle(other)), false));\n});\n\nAPPEND_OPCODES.add(VM_PRIMITIVE_OP, (vm, { op1: primitive }) => {\n  let stack = vm.stack;\n\n  if (isHandle(primitive)) {\n    // it is a handle which does not already exist on the stack\n    let value = vm.constants.getValue(decodeHandle(primitive));\n    stack.push(value as object);\n  } else {\n    // is already an encoded immediate or primitive handle\n    stack.push(decodeImmediate(primitive));\n  }\n});\n\nAPPEND_OPCODES.add(VM_PRIMITIVE_REFERENCE_OP, (vm) => {\n  let stack = vm.stack;\n  let value = check(stack.pop(), CheckPrimitive);\n  let ref;\n\n  if (value === undefined) {\n    ref = UNDEFINED_REFERENCE;\n  } else if (value === null) {\n    ref = NULL_REFERENCE;\n  } else if (value === true) {\n    ref = TRUE_REFERENCE;\n  } else if (value === false) {\n    ref = FALSE_REFERENCE;\n  } else {\n    ref = createPrimitiveRef(value);\n  }\n\n  stack.push(ref);\n});\n\nAPPEND_OPCODES.add(VM_DUP_OP, (vm, { op1: register, op2: offset }) => {\n  let position = check(vm.fetchValue(check(register, CheckRegister)), CheckNumber) - offset;\n  vm.stack.dup(position);\n});\n\nAPPEND_OPCODES.add(VM_POP_OP, (vm, { op1: count }) => {\n  vm.stack.pop(count);\n});\n\nAPPEND_OPCODES.add(VM_LOAD_OP, (vm, { op1: register }) => {\n  vm.load(check(register, CheckSyscallRegister));\n});\n\nAPPEND_OPCODES.add(VM_FETCH_OP, (vm, { op1: register }) => {\n  vm.fetch(check(register, CheckSyscallRegister));\n});\n\nAPPEND_OPCODES.add(VM_BIND_DYNAMIC_SCOPE_OP, (vm, { op1: _names }) => {\n  let names = vm.constants.getArray<string>(_names);\n  vm.bindDynamicScope(names);\n});\n\nAPPEND_OPCODES.add(VM_ENTER_OP, (vm, { op1: args }) => {\n  vm.enter(args);\n});\n\nAPPEND_OPCODES.add(VM_EXIT_OP, (vm) => {\n  vm.exit();\n});\n\nAPPEND_OPCODES.add(VM_PUSH_SYMBOL_TABLE_OP, (vm, { op1: _table }) => {\n  let stack = vm.stack;\n  stack.push(vm.constants.getValue(_table));\n});\n\nAPPEND_OPCODES.add(VM_PUSH_BLOCK_SCOPE_OP, (vm) => {\n  let stack = vm.stack;\n  stack.push(vm.scope());\n});\n\nAPPEND_OPCODES.add(VM_COMPILE_BLOCK_OP, (vm: VM) => {\n  let stack = vm.stack;\n  let block = stack.pop<Nullable<CompilableTemplate> | 0>();\n\n  if (block) {\n    stack.push(vm.compile(block));\n  } else {\n    stack.push(null);\n  }\n});\n\nAPPEND_OPCODES.add(VM_INVOKE_YIELD_OP, (vm) => {\n  let { stack } = vm;\n\n  let handle = check(stack.pop(), CheckNullable(CheckHandle));\n  let scope = check(stack.pop(), CheckNullable(CheckScope));\n  let table = check(stack.pop(), CheckNullable(CheckBlockSymbolTable));\n\n  let args = check(stack.pop(), CheckInstanceof(VMArgumentsImpl));\n\n  if (table === null || handle === null) {\n    localAssert(\n      handle === null && table === null,\n      `Expected both handle and table to be null if either is null`\n    );\n    // To balance the pop{Frame,Scope}\n    vm.lowlevel.pushFrame();\n    vm.pushScope(scope ?? vm.scope());\n\n    return;\n  }\n\n  let invokingScope = expect(scope, 'BUG: expected scope');\n\n  // If necessary, create a child scope\n  {\n    let locals = table.parameters;\n    let localsCount = locals.length;\n\n    if (localsCount > 0) {\n      invokingScope = invokingScope.child();\n\n      for (let i = 0; i < localsCount; i++) {\n        invokingScope.bindSymbol(unwrap(locals[i]), args.at(i));\n      }\n    }\n  }\n\n  vm.lowlevel.pushFrame();\n  vm.pushScope(invokingScope);\n\n  vm.call(handle);\n});\n\nAPPEND_OPCODES.add(VM_JUMP_IF_OP, (vm, { op1: target }) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n  let value = Boolean(valueForRef(reference));\n\n  if (isConstRef(reference)) {\n    if (value) {\n      vm.lowlevel.goto(target);\n    }\n  } else {\n    if (value) {\n      vm.lowlevel.goto(target);\n    }\n\n    vm.updateWith(new Assert(reference));\n  }\n});\n\nAPPEND_OPCODES.add(VM_JUMP_UNLESS_OP, (vm, { op1: target }) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n  let value = Boolean(valueForRef(reference));\n\n  if (isConstRef(reference)) {\n    if (!value) {\n      vm.lowlevel.goto(target);\n    }\n  } else {\n    if (!value) {\n      vm.lowlevel.goto(target);\n    }\n\n    vm.updateWith(new Assert(reference));\n  }\n});\n\nAPPEND_OPCODES.add(VM_JUMP_EQ_OP, (vm, { op1: target, op2: comparison }) => {\n  let other = check(vm.stack.peek(), CheckNumber);\n\n  if (other === comparison) {\n    vm.lowlevel.goto(target);\n  }\n});\n\nAPPEND_OPCODES.add(VM_ASSERT_SAME_OP, (vm) => {\n  let reference = check(vm.stack.peek(), CheckReference);\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new Assert(reference));\n  }\n});\n\nAPPEND_OPCODES.add(VM_TO_BOOLEAN_OP, (vm) => {\n  let { stack } = vm;\n  let valueRef = check(stack.pop(), CheckReference);\n\n  stack.push(createComputeRef(() => toBool(valueForRef(valueRef))));\n});\n\nexport class Assert implements UpdatingOpcode {\n  private last: unknown;\n\n  constructor(private ref: Reference) {\n    this.last = valueForRef(ref);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { last, ref } = this;\n    let current = valueForRef(ref);\n\n    if (last !== current) {\n      vm.throw();\n    }\n  }\n}\n\nexport class AssertFilter<T, U> implements UpdatingOpcode {\n  private last: U;\n\n  constructor(\n    private ref: Reference<T>,\n    private filter: (from: T) => U\n  ) {\n    this.last = filter(valueForRef(ref));\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { last, ref, filter } = this;\n    let current = filter(valueForRef(ref));\n\n    if (last !== current) {\n      vm.throw();\n    }\n  }\n}\n\nexport class JumpIfNotModifiedOpcode implements UpdatingOpcode {\n  private tag: Tag = CONSTANT_TAG;\n  private lastRevision: Revision = INITIAL;\n  private target?: number;\n\n  finalize(tag: Tag, target: number) {\n    this.target = target;\n    this.didModify(tag);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { tag, target, lastRevision } = this;\n\n    if (!vm.alwaysRevalidate && validateTag(tag, lastRevision)) {\n      consumeTag(tag);\n      vm.goto(expect(target, 'VM BUG: Target must be set before attempting to jump'));\n    }\n  }\n\n  didModify(tag: Tag) {\n    this.tag = tag;\n    this.lastRevision = valueForTag(this.tag);\n    consumeTag(tag);\n  }\n}\n\nexport class BeginTrackFrameOpcode implements UpdatingOpcode {\n  constructor(private debugLabel?: string) {}\n\n  evaluate() {\n    beginTrackFrame(this.debugLabel);\n  }\n}\n\nexport class EndTrackFrameOpcode implements UpdatingOpcode {\n  constructor(private target: JumpIfNotModifiedOpcode) {}\n\n  evaluate() {\n    let tag = endTrackFrame();\n    this.target.didModify(tag);\n  }\n}\n","import type {\n  CapturedPositionalArguments,\n  Environment,\n  ModifierDefinition,\n  ModifierDefinitionState,\n  ModifierInstance,\n  Nullable,\n  Owner,\n  UpdatingOpcode,\n  UpdatingVM,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport type { Revision, Tag } from '@glimmer/validator';\nimport {\n  CURRIED_MODIFIER,\n  VM_CLOSE_ELEMENT_OP,\n  VM_COMMENT_OP,\n  VM_DYNAMIC_ATTR_OP,\n  VM_DYNAMIC_MODIFIER_OP,\n  VM_FLUSH_ELEMENT_OP,\n  VM_MODIFIER_OP,\n  VM_OPEN_DYNAMIC_ELEMENT_OP,\n  VM_OPEN_ELEMENT_OP,\n  VM_POP_REMOTE_ELEMENT_OP,\n  VM_PUSH_REMOTE_ELEMENT_OP,\n  VM_STATIC_ATTR_OP,\n  VM_TEXT_OP,\n} from '@glimmer/constants';\nimport {\n  check,\n  CheckElement,\n  CheckMaybe,\n  CheckNode,\n  CheckNullable,\n  CheckString,\n} from '@glimmer/debug';\nimport { debugToString, expect } from '@glimmer/debug-util';\nimport { associateDestroyableChild, destroy, registerDestructor } from '@glimmer/destroyable';\nimport { getInternalModifierManager } from '@glimmer/manager';\nimport { createComputeRef, isConstRef, valueForRef } from '@glimmer/reference';\nimport { isIndexable } from '@glimmer/util';\nimport { consumeTag, CURRENT_TAG, validateTag, valueForTag } from '@glimmer/validator';\nimport { $t0 } from '@glimmer/vm';\n\nimport type { CurriedValue } from '../../curried-value';\nimport type { DynamicAttribute } from '../../vm/attributes/dynamic';\n\nimport { isCurriedType, resolveCurriedValue } from '../../curried-value';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport { createCapturedArgs } from '../../vm/arguments';\nimport { CheckArguments, CheckOperations, CheckReference } from './-debug-strip';\nimport { Assert } from './vm';\n\nAPPEND_OPCODES.add(VM_TEXT_OP, (vm, { op1: text }) => {\n  vm.tree().appendText(vm.constants.getValue(text));\n});\n\nAPPEND_OPCODES.add(VM_COMMENT_OP, (vm, { op1: text }) => {\n  vm.tree().appendComment(vm.constants.getValue(text));\n});\n\nAPPEND_OPCODES.add(VM_OPEN_ELEMENT_OP, (vm, { op1: tag }) => {\n  vm.tree().openElement(vm.constants.getValue(tag));\n});\n\nAPPEND_OPCODES.add(VM_OPEN_DYNAMIC_ELEMENT_OP, (vm) => {\n  let tagName = check(valueForRef(check(vm.stack.pop(), CheckReference)), CheckString);\n  vm.tree().openElement(tagName);\n});\n\nAPPEND_OPCODES.add(VM_PUSH_REMOTE_ELEMENT_OP, (vm) => {\n  let elementRef = check(vm.stack.pop(), CheckReference);\n  let insertBeforeRef = check(vm.stack.pop(), CheckReference);\n  let guidRef = check(vm.stack.pop(), CheckReference);\n\n  let element = check(valueForRef(elementRef), CheckElement);\n  let insertBefore = check(valueForRef(insertBeforeRef), CheckMaybe(CheckNullable(CheckNode)));\n  let guid = valueForRef(guidRef) as string;\n\n  if (!isConstRef(elementRef)) {\n    vm.updateWith(new Assert(elementRef));\n  }\n\n  if (insertBefore !== undefined && !isConstRef(insertBeforeRef)) {\n    vm.updateWith(new Assert(insertBeforeRef));\n  }\n\n  let block = vm.tree().pushRemoteElement(element, guid, insertBefore);\n  vm.associateDestroyable(block);\n\n  if (vm.env.debugRenderTree !== undefined) {\n    // Note that there is nothing to update – when the args for an\n    // {{#in-element}} changes it gets torn down and a new one is\n    // re-created/rendered in its place (see the `Assert`s above)\n    let args = createCapturedArgs(\n      insertBefore === undefined ? {} : { insertBefore: insertBeforeRef },\n      [elementRef]\n    );\n\n    vm.env.debugRenderTree.create(block, {\n      type: 'keyword',\n      name: 'in-element',\n      args,\n      instance: null,\n    });\n\n    registerDestructor(block, () => {\n      vm.env.debugRenderTree?.willDestroy(block);\n    });\n  }\n});\n\nAPPEND_OPCODES.add(VM_POP_REMOTE_ELEMENT_OP, (vm) => {\n  let bounds = vm.tree().popRemoteElement();\n\n  if (vm.env.debugRenderTree !== undefined) {\n    // The RemoteBlock is also its bounds\n    vm.env.debugRenderTree.didRender(bounds, bounds);\n  }\n});\n\nAPPEND_OPCODES.add(VM_FLUSH_ELEMENT_OP, (vm) => {\n  let operations = check(vm.fetchValue($t0), CheckOperations);\n  let modifiers: Nullable<ModifierInstance[]> = null;\n\n  if (operations) {\n    modifiers = operations.flush(vm);\n    vm.loadValue($t0, null);\n  }\n\n  vm.tree().flushElement(modifiers);\n});\n\nAPPEND_OPCODES.add(VM_CLOSE_ELEMENT_OP, (vm) => {\n  let modifiers = vm.tree().closeElement();\n\n  if (modifiers !== null) {\n    modifiers.forEach((modifier) => {\n      vm.env.scheduleInstallModifier(modifier);\n      const d = modifier.manager.getDestroyable(modifier.state);\n\n      if (d !== null) {\n        vm.associateDestroyable(d);\n      }\n    });\n  }\n});\n\nAPPEND_OPCODES.add(VM_MODIFIER_OP, (vm, { op1: handle }) => {\n  if (!vm.env.isInteractive) {\n    return;\n  }\n\n  let owner = vm.getOwner();\n  let args = check(vm.stack.pop(), CheckArguments);\n  let definition = vm.constants.getValue<ModifierDefinition>(handle);\n\n  let { manager } = definition;\n\n  let { constructing } = vm.tree();\n\n  let capturedArgs = args.capture();\n  let state = manager.create(\n    owner,\n    expect(constructing, 'BUG: ElementModifier could not find the element it applies to'),\n    definition.state,\n    capturedArgs\n  );\n\n  let instance: ModifierInstance = {\n    manager,\n    state,\n    definition,\n  };\n\n  let operations = expect(\n    check(vm.fetchValue($t0), CheckOperations),\n    'BUG: ElementModifier could not find operations to append to'\n  );\n\n  operations.addModifier(vm, instance, capturedArgs);\n\n  let tag = manager.getTag(state);\n\n  if (tag !== null) {\n    consumeTag(tag);\n    return vm.updateWith(new UpdateModifierOpcode(tag, instance));\n  }\n});\n\nAPPEND_OPCODES.add(VM_DYNAMIC_MODIFIER_OP, (vm) => {\n  if (!vm.env.isInteractive) {\n    return;\n  }\n\n  let { stack } = vm;\n  let ref = check(stack.pop(), CheckReference);\n  let args = check(stack.pop(), CheckArguments).capture();\n  let { positional: outerPositional, named: outerNamed } = args;\n\n  let { constructing } = vm.tree();\n  let initialOwner = vm.getOwner();\n\n  let instanceRef = createComputeRef(() => {\n    let value = valueForRef(ref);\n    let owner: Owner;\n\n    if (!isIndexable(value)) {\n      return;\n    }\n\n    let hostDefinition: CurriedValue | ModifierDefinitionState;\n\n    if (isCurriedType(value, CURRIED_MODIFIER)) {\n      let {\n        definition: resolvedDefinition,\n        owner: curriedOwner,\n        positional,\n        named,\n      } = resolveCurriedValue(value);\n\n      hostDefinition = resolvedDefinition;\n      owner = curriedOwner;\n\n      if (positional !== undefined) {\n        args.positional = positional.concat(outerPositional) as CapturedPositionalArguments;\n      }\n\n      if (named !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        args.named = Object.assign({}, ...named, outerNamed);\n      }\n    } else {\n      hostDefinition = value;\n      owner = initialOwner;\n    }\n\n    let manager = getInternalModifierManager(hostDefinition, true);\n\n    if (manager === null) {\n      if (import.meta.env.DEV) {\n        throw new Error(\n          `Expected a dynamic modifier definition, but received an object or function that did not have a modifier manager associated with it. The dynamic invocation was \\`{{${\n            ref.debugLabel\n          }}}\\`, and the incorrect definition is the value at the path \\`${\n            ref.debugLabel\n          }\\`, which was: ${debugToString?.(hostDefinition)}`\n        );\n      } else {\n        throw new Error('BUG: modifier manager expected');\n      }\n    }\n\n    let definition = {\n      resolvedName: null,\n      manager,\n      state: hostDefinition,\n    };\n\n    let state = manager.create(\n      owner,\n      expect(constructing, 'BUG: ElementModifier could not find the element it applies to'),\n      definition.state,\n      args\n    );\n\n    return {\n      manager,\n      state,\n      definition,\n    };\n  });\n\n  let instance = valueForRef(instanceRef);\n  let tag = null;\n\n  if (instance !== undefined) {\n    let operations = expect(\n      check(vm.fetchValue($t0), CheckOperations),\n      'BUG: ElementModifier could not find operations to append to'\n    );\n\n    operations.addModifier(vm, instance, args);\n\n    tag = instance.manager.getTag(instance.state);\n\n    if (tag !== null) {\n      consumeTag(tag);\n    }\n  }\n\n  if (!isConstRef(ref) || tag) {\n    return vm.updateWith(new UpdateDynamicModifierOpcode(tag, instance, instanceRef));\n  }\n});\n\nexport class UpdateModifierOpcode implements UpdatingOpcode {\n  private lastUpdated: Revision;\n\n  constructor(\n    private tag: Tag,\n    private modifier: ModifierInstance\n  ) {\n    this.lastUpdated = valueForTag(tag);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { modifier, tag, lastUpdated } = this;\n\n    consumeTag(tag);\n\n    if (!validateTag(tag, lastUpdated)) {\n      vm.env.scheduleUpdateModifier(modifier);\n      this.lastUpdated = valueForTag(tag);\n    }\n  }\n}\n\nexport class UpdateDynamicModifierOpcode implements UpdatingOpcode {\n  private lastUpdated: Revision;\n\n  constructor(\n    private tag: Tag | null,\n    private instance: ModifierInstance | undefined,\n    private instanceRef: Reference<ModifierInstance | undefined>\n  ) {\n    this.lastUpdated = valueForTag(tag ?? CURRENT_TAG);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { tag, lastUpdated, instance, instanceRef } = this;\n\n    let newInstance = valueForRef(instanceRef);\n\n    if (newInstance !== instance) {\n      if (instance !== undefined) {\n        let destroyable = instance.manager.getDestroyable(instance.state);\n\n        if (destroyable !== null) {\n          destroy(destroyable);\n        }\n      }\n\n      if (newInstance !== undefined) {\n        let { manager, state } = newInstance;\n        let destroyable = manager.getDestroyable(state);\n\n        if (destroyable !== null) {\n          associateDestroyableChild(this, destroyable);\n        }\n\n        tag = manager.getTag(state);\n\n        if (tag !== null) {\n          this.lastUpdated = valueForTag(tag);\n        }\n\n        this.tag = tag;\n        vm.env.scheduleInstallModifier(newInstance);\n      }\n\n      this.instance = newInstance;\n    } else if (tag !== null && !validateTag(tag, lastUpdated)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      vm.env.scheduleUpdateModifier(instance!);\n      this.lastUpdated = valueForTag(tag);\n    }\n\n    if (tag !== null) {\n      consumeTag(tag);\n    }\n  }\n}\n\nAPPEND_OPCODES.add(VM_STATIC_ATTR_OP, (vm, { op1: _name, op2: _value, op3: _namespace }) => {\n  let name = vm.constants.getValue<string>(_name);\n  let value = vm.constants.getValue<string>(_value);\n  let namespace = _namespace ? vm.constants.getValue<string>(_namespace) : null;\n\n  vm.tree().setStaticAttribute(name, value, namespace);\n});\n\nAPPEND_OPCODES.add(VM_DYNAMIC_ATTR_OP, (vm, { op1: _name, op2: _trusting, op3: _namespace }) => {\n  let name = vm.constants.getValue<string>(_name);\n  let trusting = vm.constants.getValue<boolean>(_trusting);\n  let reference = check(vm.stack.pop(), CheckReference);\n  let value = valueForRef(reference);\n  let namespace = _namespace ? vm.constants.getValue<string>(_namespace) : null;\n\n  let attribute = vm.tree().setDynamicAttribute(name, value, trusting, namespace);\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute, vm.env));\n  }\n});\n\nexport class UpdateDynamicAttributeOpcode implements UpdatingOpcode {\n  private updateRef: Reference;\n\n  constructor(reference: Reference, attribute: DynamicAttribute, env: Environment) {\n    let initialized = false;\n\n    this.updateRef = createComputeRef(() => {\n      let value = valueForRef(reference);\n\n      if (initialized) {\n        attribute.update(value, env);\n      } else {\n        initialized = true;\n      }\n    });\n\n    valueForRef(this.updateRef);\n  }\n\n  evaluate() {\n    valueForRef(this.updateRef);\n  }\n}\n","import type {\n  Bounds,\n  CapabilityMask,\n  CapturedArguments,\n  CompilableProgram,\n  ComponentDefinition,\n  ComponentDefinitionState,\n  ComponentInstance,\n  ComponentInstanceState,\n  ComponentInstanceWithCreate,\n  Dict,\n  DynamicScope,\n  ElementOperations,\n  InternalComponentManager,\n  ModifierInstance,\n  Nullable,\n  Owner,\n  ProgramSymbolTable,\n  Recast,\n  ScopeSlot,\n  UpdatingOpcode,\n  VMArguments,\n  WithDynamicTagName,\n  WithElementHook,\n  WithUpdateHook,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport {\n  CURRIED_COMPONENT,\n  VM_BEGIN_COMPONENT_TRANSACTION_OP,\n  VM_CAPTURE_ARGS_OP,\n  VM_COMMIT_COMPONENT_TRANSACTION_OP,\n  VM_COMPONENT_ATTR_OP,\n  VM_CREATE_COMPONENT_OP,\n  VM_DID_CREATE_ELEMENT_OP,\n  VM_DID_RENDER_LAYOUT_OP,\n  VM_GET_COMPONENT_LAYOUT_OP,\n  VM_GET_COMPONENT_SELF_OP,\n  VM_GET_COMPONENT_TAG_NAME_OP,\n  VM_INVOKE_COMPONENT_LAYOUT_OP,\n  VM_MAIN_OP,\n  VM_POPULATE_LAYOUT_OP,\n  VM_PREPARE_ARGS_OP,\n  VM_PUSH_ARGS_OP,\n  VM_PUSH_COMPONENT_DEFINITION_OP,\n  VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP,\n  VM_PUSH_EMPTY_ARGS_OP,\n  VM_PUT_COMPONENT_OPERATIONS_OP,\n  VM_REGISTER_COMPONENT_DESTRUCTOR_OP,\n  VM_RESOLVE_CURRIED_COMPONENT_OP,\n  VM_RESOLVE_DYNAMIC_COMPONENT_OP,\n  VM_SET_BLOCKS_OP,\n  VM_SET_NAMED_VARIABLES_OP,\n  VM_STATIC_COMPONENT_ATTR_OP,\n  VM_VIRTUAL_ROOT_SCOPE_OP,\n} from '@glimmer/constants';\nimport {\n  check,\n  CheckFunction,\n  CheckHandle,\n  CheckInstanceof,\n  CheckInterface,\n  CheckOr,\n  CheckProgramSymbolTable,\n  CheckRegister,\n  CheckString,\n  CheckSyscallRegister,\n} from '@glimmer/debug';\nimport { debugToString, expect, localAssert, unwrap, unwrapTemplate } from '@glimmer/debug-util';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { managerHasCapability } from '@glimmer/manager';\nimport { isConstRef, valueForRef } from '@glimmer/reference';\nimport { assign, dict, EMPTY_STRING_ARRAY, enumerate } from '@glimmer/util';\nimport { $s0, $t0, $t1, InternalComponentCapabilities } from '@glimmer/vm';\n\nimport type { CurriedValue } from '../../curried-value';\nimport type { UpdatingVM } from '../../vm';\nimport type { VM } from '../../vm/append';\nimport type { BlockArgumentsImpl } from '../../vm/arguments';\n\nimport { ConcreteBounds } from '../../bounds';\nimport { hasCustomDebugRenderTreeLifecycle } from '../../component/interfaces';\nimport { resolveComponent } from '../../component/resolve';\nimport { isCurriedType, isCurriedValue, resolveCurriedValue } from '../../curried-value';\nimport { getDebugName } from '../../debug-render-tree';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport createClassListRef from '../../references/class-list';\nimport { EMPTY_ARGS, VMArgumentsImpl } from '../../vm/arguments';\nimport {\n  CheckArguments,\n  CheckComponentDefinition,\n  CheckComponentInstance,\n  CheckCurriedComponentDefinition,\n  CheckFinishedComponentInstance,\n  CheckInvocation,\n  CheckReference,\n} from './-debug-strip';\nimport { UpdateDynamicAttributeOpcode } from './dom';\n\n/**\n * The VM creates a new ComponentInstance data structure for every component\n * invocation it encounters.\n *\n * Similar to how a ComponentDefinition contains state about all components of a\n * particular type, a ComponentInstance contains state specific to a particular\n * instance of a component type. It also contains a pointer back to its\n * component type's ComponentDefinition.\n */\n\nexport interface InitialComponentInstance {\n  definition: ComponentDefinition;\n  manager: Nullable<InternalComponentManager>;\n  capabilities: Nullable<CapabilityMask>;\n  state: null;\n  handle: Nullable<number>;\n  table: Nullable<ProgramSymbolTable>;\n  lookup: Nullable<Dict<ScopeSlot>>;\n}\n\nexport interface PopulatedComponentInstance {\n  definition: ComponentDefinition;\n  manager: InternalComponentManager;\n  capabilities: CapabilityMask;\n  state: null;\n  handle: number;\n  table: Nullable<ProgramSymbolTable>;\n  lookup: Nullable<Dict<ScopeSlot>>;\n}\n\nexport interface PartialComponentDefinition {\n  state: Nullable<ComponentDefinitionState>;\n  manager: InternalComponentManager;\n}\n\nAPPEND_OPCODES.add(VM_PUSH_COMPONENT_DEFINITION_OP, (vm, { op1: handle }) => {\n  let definition = vm.constants.getValue<ComponentDefinition>(handle);\n  localAssert(!!definition, `Missing component for ${handle}`);\n\n  let { manager, capabilities } = definition;\n\n  let instance: InitialComponentInstance = {\n    definition,\n    manager,\n    capabilities,\n    state: null,\n    handle: null,\n    table: null,\n    lookup: null,\n  };\n\n  vm.stack.push(instance);\n});\n\nAPPEND_OPCODES.add(VM_RESOLVE_DYNAMIC_COMPONENT_OP, (vm, { op1: _isStrict }) => {\n  let stack = vm.stack;\n  let component = check(\n    valueForRef(check(stack.pop(), CheckReference)),\n    CheckOr(CheckString, CheckCurriedComponentDefinition)\n  );\n  let constants = vm.constants;\n  let owner = vm.getOwner();\n  let isStrict = constants.getValue<boolean>(_isStrict);\n\n  vm.loadValue($t1, null); // Clear the temp register\n\n  let definition: ComponentDefinition | CurriedValue;\n\n  if (typeof component === 'string') {\n    if (import.meta.env.DEV && isStrict) {\n      throw new Error(\n        `Attempted to resolve a dynamic component with a string definition, \\`${component}\\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`\n      );\n    }\n\n    let resolvedDefinition = resolveComponent(vm.context.resolver, constants, component, owner);\n\n    definition = expect(resolvedDefinition, `Could not find a component named \"${component}\"`);\n  } else if (isCurriedValue(component)) {\n    definition = component;\n  } else {\n    definition = constants.component(component, owner);\n  }\n\n  stack.push(definition);\n});\n\nAPPEND_OPCODES.add(VM_RESOLVE_CURRIED_COMPONENT_OP, (vm) => {\n  let stack = vm.stack;\n  let ref = check(stack.pop(), CheckReference);\n  let value = valueForRef(ref);\n  let constants = vm.constants;\n\n  let definition: CurriedValue | ComponentDefinition | null;\n\n  if (\n    import.meta.env.DEV &&\n    !(typeof value === 'function' || (typeof value === 'object' && value !== null))\n  ) {\n    throw new Error(\n      `Expected a component definition, but received ${value}. You may have accidentally done <${ref.debugLabel}>, where \"${ref.debugLabel}\" was a string instead of a curried component definition. You must either use the component definition directly, or use the {{component}} helper to create a curried component definition when invoking dynamically.`\n    );\n  }\n\n  if (isCurriedValue(value)) {\n    definition = value;\n  } else {\n    definition = constants.component(value as object, vm.getOwner(), true);\n\n    if (import.meta.env.DEV && definition === null) {\n      throw new Error(\n        `Expected a dynamic component definition, but received an object or function that did not have a component manager associated with it. The dynamic invocation was \\`<${\n          ref.debugLabel\n        }>\\` or \\`{{${\n          ref.debugLabel\n        }}}\\`, and the incorrect definition is the value at the path \\`${\n          ref.debugLabel\n        }\\`, which was: ${debugToString?.(value) ?? value}`\n      );\n    }\n  }\n\n  stack.push(definition);\n});\n\nAPPEND_OPCODES.add(VM_PUSH_DYNAMIC_COMPONENT_INSTANCE_OP, (vm) => {\n  let { stack } = vm;\n  let definition = stack.pop<ComponentDefinition>();\n\n  let capabilities, manager;\n\n  if (isCurriedValue(definition)) {\n    manager = capabilities = null;\n  } else {\n    manager = definition.manager;\n    capabilities = definition.capabilities;\n  }\n\n  stack.push({ definition, capabilities, manager, state: null, handle: null, table: null });\n});\n\nAPPEND_OPCODES.add(VM_PUSH_ARGS_OP, (vm, { op1: _names, op2: _blockNames, op3: flags }) => {\n  let stack = vm.stack;\n  let names = vm.constants.getArray<string>(_names);\n\n  let positionalCount = flags >> 4;\n  let atNames = flags & 0b1000;\n  let blockNames = flags & 0b0111 ? vm.constants.getArray<string>(_blockNames) : EMPTY_STRING_ARRAY;\n\n  vm.args.setup(stack, names, blockNames, positionalCount, !!atNames);\n  stack.push(vm.args);\n});\n\nAPPEND_OPCODES.add(VM_PUSH_EMPTY_ARGS_OP, (vm) => {\n  let { stack } = vm;\n\n  stack.push(vm.args.empty(stack));\n});\n\nAPPEND_OPCODES.add(VM_CAPTURE_ARGS_OP, (vm) => {\n  let stack = vm.stack;\n\n  let args = check(stack.pop(), CheckInstanceof(VMArgumentsImpl));\n  let capturedArgs = args.capture();\n  stack.push(capturedArgs);\n});\n\nAPPEND_OPCODES.add(VM_PREPARE_ARGS_OP, (vm, { op1: register }) => {\n  let stack = vm.stack;\n  let instance = vm.fetchValue<ComponentInstance>(check(register, CheckRegister));\n  let args = check(stack.pop(), CheckInstanceof(VMArgumentsImpl));\n\n  let { definition } = instance;\n\n  if (isCurriedType(definition, CURRIED_COMPONENT)) {\n    localAssert(\n      !definition.manager,\n      \"If the component definition was curried, we don't yet have a manager\"\n    );\n\n    let constants = vm.constants;\n\n    let {\n      definition: resolvedDefinition,\n      owner,\n      resolved,\n      positional,\n      named,\n    } = resolveCurriedValue(definition);\n\n    if (resolved) {\n      definition = resolvedDefinition as ComponentDefinition;\n    } else if (typeof resolvedDefinition === 'string') {\n      let resolvedValue = vm.context.resolver?.lookupComponent?.(resolvedDefinition, owner) ?? null;\n\n      definition = constants.resolvedComponent(\n        expect(resolvedValue, 'BUG: expected resolved component'),\n        resolvedDefinition\n      );\n    } else {\n      definition = constants.component(resolvedDefinition, owner);\n    }\n\n    if (named !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      args.named.merge(assign({}, ...named));\n    }\n\n    if (positional !== undefined) {\n      args.realloc(positional.length);\n      args.positional.prepend(positional);\n    }\n\n    let { manager } = definition;\n\n    instance.definition = definition;\n    instance.manager = manager;\n    instance.capabilities = definition.capabilities;\n\n    // Save off the owner that this component was curried with. Later on,\n    // we'll fetch the value of this register and set it as the owner on the\n    // new root scope.\n    vm.loadValue($t1, owner);\n  }\n\n  let { manager, state } = definition;\n  let capabilities = instance.capabilities;\n\n  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.prepareArgs)) {\n    stack.push(args);\n    return;\n  }\n\n  let blocks = args.blocks.values;\n  let blockNames = args.blocks.names;\n  let preparedArgs = manager.prepareArgs(state, args);\n\n  if (preparedArgs) {\n    args.clear();\n\n    for (let i = 0; i < blocks.length; i++) {\n      stack.push(blocks[i]);\n    }\n\n    let { positional, named } = preparedArgs;\n\n    let positionalCount = positional.length;\n\n    for (let i = 0; i < positionalCount; i++) {\n      stack.push(positional[i]);\n    }\n\n    let names = Object.keys(named);\n\n    for (let i = 0; i < names.length; i++) {\n      stack.push(named[unwrap(names[i])]);\n    }\n\n    args.setup(stack, names, blockNames, positionalCount, false);\n  }\n\n  stack.push(args);\n});\n\nAPPEND_OPCODES.add(VM_CREATE_COMPONENT_OP, (vm, { op1: flags }) => {\n  let instance = check(vm.fetchValue($s0), CheckComponentInstance);\n  let { definition, manager, capabilities } = instance;\n\n  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance)) {\n    // TODO: Closure and Main components are always invoked dynamically, so this\n    // opcode may run even if this capability is not enabled. In the future we\n    // should handle this in a better way.\n    return;\n  }\n\n  let dynamicScope: Nullable<DynamicScope> = null;\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicScope)) {\n    dynamicScope = vm.dynamicScope();\n  }\n\n  let hasDefaultBlock = flags & 1;\n  let args: Nullable<VMArguments> = null;\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.createArgs)) {\n    args = check(vm.stack.peek(), CheckArguments);\n  }\n\n  let self: Nullable<Reference> = null;\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.createCaller)) {\n    self = vm.getSelf();\n  }\n\n  let state = manager.create(\n    vm.getOwner(),\n    definition.state,\n    args,\n    vm.env,\n    dynamicScope,\n    self,\n    !!hasDefaultBlock\n  );\n\n  // We want to reuse the `state` POJO here, because we know that the opcodes\n  // only transition at exactly one place.\n  instance.state = state;\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.updateHook)) {\n    vm.updateWith(new UpdateComponentOpcode(state, manager, dynamicScope));\n  }\n});\n\nAPPEND_OPCODES.add(VM_REGISTER_COMPONENT_DESTRUCTOR_OP, (vm, { op1: register }) => {\n  let { manager, state, capabilities } = check(\n    vm.fetchValue(check(register, CheckRegister)),\n    CheckComponentInstance\n  );\n\n  let d = manager.getDestroyable(state);\n\n  if (\n    import.meta.env.DEV &&\n    !managerHasCapability(manager, capabilities, InternalComponentCapabilities.willDestroy) &&\n    d !== null &&\n    (typeof 'willDestroy') in d\n  ) {\n    throw new Error(\n      'BUG: Destructor has willDestroy, but the willDestroy capability was not enabled for this component. Pre-destruction hooks must be explicitly opted into'\n    );\n  }\n\n  if (d) vm.associateDestroyable(d);\n});\n\nAPPEND_OPCODES.add(VM_BEGIN_COMPONENT_TRANSACTION_OP, (vm, { op1: register }) => {\n  let name;\n\n  if (import.meta.env.DEV) {\n    let { definition, manager } = check(\n      vm.fetchValue(check(register, CheckRegister)),\n      CheckComponentInstance\n    );\n\n    name = getDebugName(definition, manager);\n  }\n\n  vm.beginCacheGroup(name);\n  vm.tree().pushAppendingBlock();\n});\n\nAPPEND_OPCODES.add(VM_PUT_COMPONENT_OPERATIONS_OP, (vm) => {\n  vm.loadValue($t0, new ComponentElementOperations());\n});\n\nAPPEND_OPCODES.add(VM_COMPONENT_ATTR_OP, (vm, { op1: _name, op2: _trusting, op3: _namespace }) => {\n  let name = vm.constants.getValue<string>(_name);\n  let trusting = vm.constants.getValue<boolean>(_trusting);\n  let reference = check(vm.stack.pop(), CheckReference);\n  let namespace = _namespace ? vm.constants.getValue<string>(_namespace) : null;\n\n  check(vm.fetchValue($t0), CheckInstanceof(ComponentElementOperations)).setAttribute(\n    name,\n    reference,\n    trusting,\n    namespace\n  );\n});\n\nAPPEND_OPCODES.add(\n  VM_STATIC_COMPONENT_ATTR_OP,\n  (vm, { op1: _name, op2: _value, op3: _namespace }) => {\n    let name = vm.constants.getValue<string>(_name);\n    let value = vm.constants.getValue<string>(_value);\n    let namespace = _namespace ? vm.constants.getValue<string>(_namespace) : null;\n\n    check(vm.fetchValue($t0), CheckInstanceof(ComponentElementOperations)).setStaticAttribute(\n      name,\n      value,\n      namespace\n    );\n  }\n);\n\ntype DeferredAttribute = {\n  value: string | Reference;\n  namespace: Nullable<string>;\n  trusting?: boolean;\n};\n\nexport class ComponentElementOperations implements ElementOperations {\n  private attributes = dict<DeferredAttribute>();\n  private classes: (string | Reference)[] = [];\n  private modifiers: ModifierInstance[] = [];\n\n  setAttribute(name: string, value: Reference, trusting: boolean, namespace: Nullable<string>) {\n    let deferred = { value, namespace, trusting };\n\n    if (name === 'class') {\n      this.classes.push(value);\n    }\n\n    this.attributes[name] = deferred;\n  }\n\n  setStaticAttribute(name: string, value: string, namespace: Nullable<string>): void {\n    let deferred = { value, namespace };\n\n    if (name === 'class') {\n      this.classes.push(value);\n    }\n\n    this.attributes[name] = deferred;\n  }\n\n  addModifier(vm: VM, modifier: ModifierInstance, capturedArgs: CapturedArguments): void {\n    this.modifiers.push(modifier);\n\n    if (vm.env.debugRenderTree !== undefined) {\n      const { manager, definition, state } = modifier;\n\n      // TODO: we need a stable object for the debugRenderTree as the key, add support for\n      // the case where the state is a primitive, or if in practice we always have/require\n      // an object, then change the internal types to reflect that\n      if (state === null || (typeof state !== 'object' && typeof state !== 'function')) {\n        return;\n      }\n\n      let { element, constructing } = vm.tree();\n      let name = definition.resolvedName ?? manager.getDebugName(definition.state);\n      let instance = manager.getDebugInstance(state);\n\n      localAssert(constructing, `Expected a constructing element in addModifier`);\n\n      let bounds = new ConcreteBounds(element, constructing, constructing);\n\n      vm.env.debugRenderTree.create(state, {\n        type: 'modifier',\n        name,\n        args: capturedArgs,\n        instance,\n      });\n\n      vm.env.debugRenderTree.didRender(state, bounds);\n\n      // For tearing down the debugRenderTree\n      vm.associateDestroyable(state);\n\n      vm.updateWith(new DebugRenderTreeUpdateOpcode(state));\n      vm.updateWith(new DebugRenderTreeDidRenderOpcode(state, bounds));\n\n      registerDestructor(state, () => {\n        vm.env.debugRenderTree?.willDestroy(state);\n      });\n    }\n  }\n\n  flush(vm: VM): ModifierInstance[] {\n    let type: DeferredAttribute | undefined;\n    let attributes = this.attributes;\n\n    for (let name in this.attributes) {\n      if (name === 'type') {\n        type = attributes[name];\n        continue;\n      }\n\n      let attr = unwrap(this.attributes[name]);\n      if (name === 'class') {\n        setDeferredAttr(vm, 'class', mergeClasses(this.classes), attr.namespace, attr.trusting);\n      } else {\n        setDeferredAttr(vm, name, attr.value, attr.namespace, attr.trusting);\n      }\n    }\n\n    if (type !== undefined) {\n      setDeferredAttr(vm, 'type', type.value, type.namespace, type.trusting);\n    }\n\n    return this.modifiers;\n  }\n}\n\nfunction mergeClasses(classes: (string | Reference)[]): string | Reference {\n  if (classes.length === 0) {\n    return '';\n  }\n  if (classes.length === 1) {\n    return unwrap(classes[0]);\n  }\n  if (allStringClasses(classes)) {\n    return classes.join(' ');\n  }\n\n  return createClassListRef(classes as Reference[]);\n}\n\nfunction allStringClasses(classes: (string | Reference)[]): classes is string[] {\n  return classes.every((c) => typeof c === 'string');\n}\n\nfunction setDeferredAttr(\n  vm: VM,\n  name: string,\n  value: string | Reference,\n  namespace: Nullable<string>,\n  trusting = false\n) {\n  if (typeof value === 'string') {\n    vm.tree().setStaticAttribute(name, value, namespace);\n  } else {\n    let attribute = vm.tree().setDynamicAttribute(name, valueForRef(value), trusting, namespace);\n    if (!isConstRef(value)) {\n      vm.updateWith(new UpdateDynamicAttributeOpcode(value, attribute, vm.env));\n    }\n  }\n}\n\nAPPEND_OPCODES.add(VM_DID_CREATE_ELEMENT_OP, (vm, { op1: register }) => {\n  let { definition, state } = check(\n    vm.fetchValue(check(register, CheckRegister)),\n    CheckComponentInstance\n  );\n  let { manager } = definition;\n\n  let operations = check(vm.fetchValue($t0), CheckInstanceof(ComponentElementOperations));\n\n  (manager as WithElementHook<unknown>).didCreateElement(\n    state,\n    expect(vm.tree().constructing, `Expected a constructing element in DidCreateOpcode`),\n    operations\n  );\n});\n\nAPPEND_OPCODES.add(VM_GET_COMPONENT_SELF_OP, (vm, { op1: register, op2: _names }) => {\n  let instance = check(vm.fetchValue(check(register, CheckRegister)), CheckComponentInstance);\n  let { definition, state } = instance;\n  let { manager } = definition;\n  let selfRef = manager.getSelf(state);\n\n  if (vm.env.debugRenderTree !== undefined) {\n    let instance = check(vm.fetchValue(check(register, CheckRegister)), CheckComponentInstance);\n    let { definition, manager } = instance;\n\n    let args: CapturedArguments;\n\n    if (vm.stack.peek() === vm.args) {\n      args = vm.args.capture();\n    } else {\n      let names = vm.constants.getArray<string>(_names);\n      vm.args.setup(vm.stack, names, [], 0, true);\n      args = vm.args.capture();\n    }\n\n    let moduleName: string;\n    let compilable: CompilableProgram | null = definition.compilable;\n\n    if (compilable === null) {\n      localAssert(\n        managerHasCapability(\n          manager,\n          instance.capabilities,\n          InternalComponentCapabilities.dynamicLayout\n        ),\n        'BUG: No template was found for this component, and the component did not have the dynamic layout capability'\n      );\n\n      let resolver = vm.context.resolver;\n      compilable = resolver === null ? null : manager.getDynamicLayout(state, resolver);\n\n      if (compilable !== null) {\n        moduleName = compilable.moduleName;\n      } else {\n        moduleName = '__default__.hbs';\n      }\n    } else {\n      moduleName = compilable.moduleName;\n    }\n\n    // For tearing down the debugRenderTree\n    vm.associateDestroyable(instance);\n\n    if (hasCustomDebugRenderTreeLifecycle(manager)) {\n      let nodes = manager.getDebugCustomRenderTree(\n        instance.definition.state,\n        instance.state,\n        args,\n        moduleName\n      );\n\n      nodes.forEach((node) => {\n        let { bucket } = node;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        vm.env.debugRenderTree!.create(bucket, node);\n\n        registerDestructor(instance, () => {\n          vm.env.debugRenderTree?.willDestroy(bucket);\n        });\n\n        vm.updateWith(new DebugRenderTreeUpdateOpcode(bucket));\n      });\n    } else {\n      let name = getDebugName(definition, manager);\n\n      vm.env.debugRenderTree.create(instance, {\n        type: 'component',\n        name,\n        args,\n        template: moduleName,\n        instance: valueForRef(selfRef),\n      });\n\n      registerDestructor(instance, () => {\n        vm.env.debugRenderTree?.willDestroy(instance);\n      });\n\n      vm.updateWith(new DebugRenderTreeUpdateOpcode(instance));\n    }\n  }\n\n  vm.stack.push(selfRef);\n});\n\nAPPEND_OPCODES.add(VM_GET_COMPONENT_TAG_NAME_OP, (vm, { op1: register }) => {\n  let { definition, state } = check(\n    vm.fetchValue(check(register, CheckRegister)),\n    CheckComponentInstance\n  );\n  let { manager } = definition;\n\n  let tagName = (\n    manager as Recast<InternalComponentManager, WithDynamicTagName<unknown>>\n  ).getTagName(state);\n\n  // User provided value from JS, so we don't bother to encode\n  vm.stack.push(tagName);\n});\n\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(VM_GET_COMPONENT_LAYOUT_OP, (vm, { op1: register }) => {\n  let instance = check(vm.fetchValue(check(register, CheckRegister)), CheckComponentInstance);\n\n  let { manager, definition } = instance;\n  let { stack } = vm;\n\n  let { compilable } = definition;\n\n  if (compilable === null) {\n    let { capabilities } = instance;\n\n    localAssert(\n      managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout),\n      'BUG: No template was found for this component, and the component did not have the dynamic layout capability'\n    );\n\n    let resolver = vm.context.resolver;\n    compilable = resolver === null ? null : manager.getDynamicLayout(instance.state, resolver);\n\n    if (compilable === null) {\n      if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped)) {\n        compilable = unwrapTemplate(vm.constants.defaultTemplate).asWrappedLayout();\n      } else {\n        compilable = unwrapTemplate(vm.constants.defaultTemplate).asLayout();\n      }\n    }\n  }\n\n  let handle = compilable.compile(vm.context);\n\n  stack.push(compilable.symbolTable);\n  stack.push(handle);\n});\n\nAPPEND_OPCODES.add(VM_MAIN_OP, (vm, { op1: register }) => {\n  let definition = check(vm.stack.pop(), CheckComponentDefinition);\n  let invocation = check(vm.stack.pop(), CheckInvocation);\n\n  let { manager, capabilities } = definition;\n\n  let state: PopulatedComponentInstance = {\n    definition,\n    manager,\n    capabilities,\n    state: null,\n    handle: invocation.handle,\n    table: invocation.symbolTable,\n    lookup: null,\n  };\n\n  vm.loadValue(check(register, CheckSyscallRegister), state);\n});\n\nAPPEND_OPCODES.add(VM_POPULATE_LAYOUT_OP, (vm, { op1: register }) => {\n  let { stack } = vm;\n\n  // In import.meta.env.DEV handles could be ErrHandle objects\n  let handle = check(stack.pop(), CheckHandle);\n  let table = check(stack.pop(), CheckProgramSymbolTable);\n\n  let state = check(vm.fetchValue(check(register, CheckRegister)), CheckComponentInstance);\n\n  state.handle = handle;\n  state.table = table;\n});\n\nAPPEND_OPCODES.add(VM_VIRTUAL_ROOT_SCOPE_OP, (vm, { op1: register }) => {\n  let { table, manager, capabilities, state } = check(\n    vm.fetchValue(check(register, CheckRegister)),\n    CheckFinishedComponentInstance\n  );\n\n  let owner;\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.hasSubOwner)) {\n    owner = manager.getOwner(state);\n    vm.loadValue($t1, null); // Clear the temp register\n  } else {\n    // Check the temp register to see if an owner was resolved from currying\n    owner = vm.fetchValue<Owner | null>($t1);\n\n    if (owner === null) {\n      // If an owner wasn't found, default to using the current owner. This\n      // will happen for normal dynamic component invocation,\n      // e.g. <SomeClassicEmberComponent/>\n      owner = vm.getOwner();\n    } else {\n      // Else the owner was found, so clear the temp register. This will happen\n      // if we are loading a curried component, e.g. <@someCurriedComponent/>\n      vm.loadValue($t1, null);\n    }\n  }\n\n  vm.pushRootScope(table.symbols.length + 1, owner);\n});\n\nAPPEND_OPCODES.add(VM_SET_NAMED_VARIABLES_OP, (vm, { op1: register }) => {\n  let state = check(vm.fetchValue(check(register, CheckRegister)), CheckFinishedComponentInstance);\n  let scope = vm.scope();\n\n  let args = check(vm.stack.peek(), CheckArguments);\n  let callerNames = args.named.atNames;\n\n  for (let i = callerNames.length - 1; i >= 0; i--) {\n    let atName = unwrap(callerNames[i]);\n    let symbol = state.table.symbols.indexOf(atName);\n    let value = args.named.get(atName, true);\n\n    if (symbol !== -1) scope.bindSymbol(symbol + 1, value);\n    if (state.lookup) state.lookup[atName] = value;\n  }\n});\n\nfunction bindBlock(\n  symbolName: string,\n  blockName: string,\n  state: ComponentInstance,\n  blocks: BlockArgumentsImpl,\n  vm: VM\n) {\n  let symbol = state.table.symbols.indexOf(symbolName);\n  let block = blocks.get(blockName);\n\n  if (symbol !== -1) vm.scope().bindBlock(symbol + 1, block);\n  if (state.lookup) state.lookup[symbolName] = block;\n}\n\nAPPEND_OPCODES.add(VM_SET_BLOCKS_OP, (vm, { op1: register }) => {\n  let state = check(vm.fetchValue(check(register, CheckRegister)), CheckFinishedComponentInstance);\n  let { blocks } = check(vm.stack.peek(), CheckArguments);\n\n  for (const [i] of enumerate(blocks.names)) {\n    bindBlock(unwrap(blocks.symbolNames[i]), unwrap(blocks.names[i]), state, blocks, vm);\n  }\n});\n\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(VM_INVOKE_COMPONENT_LAYOUT_OP, (vm, { op1: register }) => {\n  let state = check(vm.fetchValue(check(register, CheckRegister)), CheckFinishedComponentInstance);\n\n  vm.call(state.handle);\n});\n\nAPPEND_OPCODES.add(VM_DID_RENDER_LAYOUT_OP, (vm, { op1: register }) => {\n  let instance = check(vm.fetchValue(check(register, CheckRegister)), CheckComponentInstance);\n  let { manager, state, capabilities } = instance;\n  let bounds = vm.tree().popBlock();\n\n  if (vm.env.debugRenderTree !== undefined) {\n    if (hasCustomDebugRenderTreeLifecycle(manager)) {\n      let nodes = manager.getDebugCustomRenderTree(instance.definition.state, state, EMPTY_ARGS);\n\n      nodes.reverse().forEach((node) => {\n        let { bucket } = node;\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        vm.env.debugRenderTree!.didRender(bucket, bounds);\n\n        vm.updateWith(new DebugRenderTreeDidRenderOpcode(bucket, bounds));\n      });\n    } else {\n      vm.env.debugRenderTree.didRender(instance, bounds);\n\n      vm.updateWith(new DebugRenderTreeDidRenderOpcode(instance, bounds));\n    }\n  }\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance)) {\n    let mgr = check(manager, CheckInterface({ didRenderLayout: CheckFunction }));\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call -- @fixme\n    mgr.didRenderLayout(state, bounds);\n\n    vm.env.didCreate(instance as ComponentInstanceWithCreate);\n    vm.updateWith(new DidUpdateLayoutOpcode(instance as ComponentInstanceWithCreate, bounds));\n  }\n});\n\nAPPEND_OPCODES.add(VM_COMMIT_COMPONENT_TRANSACTION_OP, (vm) => {\n  vm.commitCacheGroup();\n});\n\nexport class UpdateComponentOpcode implements UpdatingOpcode {\n  constructor(\n    private component: ComponentInstanceState,\n    private manager: WithUpdateHook,\n    private dynamicScope: Nullable<DynamicScope>\n  ) {}\n\n  evaluate(_vm: UpdatingVM) {\n    let { component, manager, dynamicScope } = this;\n\n    manager.update(component, dynamicScope);\n  }\n}\n\nexport class DidUpdateLayoutOpcode implements UpdatingOpcode {\n  constructor(\n    private component: ComponentInstanceWithCreate,\n    private bounds: Bounds\n  ) {}\n\n  evaluate(vm: UpdatingVM) {\n    let { component, bounds } = this;\n    let { manager, state } = component;\n\n    manager.didUpdateLayout(state, bounds);\n\n    vm.env.didUpdate(component);\n  }\n}\n\nclass DebugRenderTreeUpdateOpcode implements UpdatingOpcode {\n  constructor(private bucket: object) {}\n\n  evaluate(vm: UpdatingVM) {\n    vm.env.debugRenderTree?.update(this.bucket);\n  }\n}\n\nclass DebugRenderTreeDidRenderOpcode implements UpdatingOpcode {\n  constructor(\n    private bucket: object,\n    private bounds: Bounds\n  ) {}\n\n  evaluate(vm: UpdatingVM) {\n    vm.env.debugRenderTree?.didRender(this.bucket, this.bounds);\n  }\n}\n","import type {\n  ClassicResolver,\n  ComponentDefinition,\n  Nullable,\n  Owner,\n  ResolutionTimeConstants,\n} from '@glimmer/interfaces';\nimport { expect } from '@glimmer/debug-util';\n\nexport function resolveComponent(\n  resolver: Nullable<ClassicResolver>,\n  constants: ResolutionTimeConstants,\n  name: string,\n  owner: Owner | null\n): Nullable<ComponentDefinition> {\n  let definition =\n    resolver?.lookupComponent?.(\n      name,\n      expect(owner, 'BUG: expected owner when looking up component')\n    ) ?? null;\n\n  if (import.meta.env.DEV && !definition) {\n    throw new Error(\n      `Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return constants.resolvedComponent(definition!, name);\n}\n","import type { Reference } from '@glimmer/reference';\nimport { createComputeRef, valueForRef } from '@glimmer/reference';\n\nimport { normalizeStringValue } from '../dom/normalize';\n\nexport default function createClassListRef(list: Reference[]) {\n  return createComputeRef(() => {\n    let ret: string[] = [];\n\n    for (const ref of list) {\n      let value = normalizeStringValue(typeof ref === 'string' ? ref : valueForRef(ref));\n      if (value) ret.push(value);\n    }\n\n    return ret.length === 0 ? null : ret.join(' ');\n  });\n}\n","import type { Checker } from '@glimmer/debug';\nimport type {\n  CapabilityMask,\n  CapturedArguments,\n  CompilableBlock,\n  CompilableProgram,\n  ComponentDefinition,\n  ComponentInstance,\n  ElementOperations,\n  Helper,\n  InternalComponentManager,\n  Invocation,\n  Nullable,\n  Scope,\n  ScopeBlock,\n} from '@glimmer/interfaces';\nimport type { OpaqueIterator, Reference } from '@glimmer/reference';\nimport type { Tag } from '@glimmer/validator';\nimport {\n  CheckArray,\n  CheckBlockSymbolTable,\n  CheckDict,\n  CheckFunction,\n  CheckHandle,\n  CheckInstanceof,\n  CheckInterface,\n  CheckNullable,\n  CheckNumber,\n  CheckObject,\n  CheckOr,\n  CheckProgramSymbolTable,\n  CheckString,\n  CheckUnknown,\n  wrap,\n} from '@glimmer/debug';\nimport { REFERENCE, UNDEFINED_REFERENCE } from '@glimmer/reference';\nimport { COMPUTE } from '@glimmer/validator';\n\nimport { ScopeImpl } from '../../scope';\nimport { VMArgumentsImpl } from '../../vm/arguments';\nimport { ComponentElementOperations } from './component';\n\nexport const CheckTag: Checker<Tag> = CheckInterface({\n  [COMPUTE]: CheckFunction,\n});\n\nexport const CheckOperations: Checker<Nullable<ComponentElementOperations>> = wrap(() =>\n  CheckNullable(CheckInstanceof(ComponentElementOperations))\n);\n\nclass ReferenceChecker {\n  declare type: Reference;\n\n  validate(value: unknown): value is Reference {\n    return typeof value === 'object' && value !== null && REFERENCE in value;\n  }\n\n  expected(): string {\n    return `Reference`;\n  }\n}\n\nexport const CheckReference: Checker<Reference> = new ReferenceChecker();\n\nexport const CheckIterator: Checker<OpaqueIterator> = CheckInterface({\n  next: CheckFunction,\n  isEmpty: CheckFunction,\n});\n\nexport const CheckArguments: Checker<VMArgumentsImpl> = wrap(() =>\n  CheckInstanceof(VMArgumentsImpl)\n);\n\nexport const CheckHelper: Checker<Helper> = CheckFunction as Checker<Helper>;\n\nexport class UndefinedReferenceChecker implements Checker<Reference> {\n  declare type: Reference;\n\n  validate(value: unknown): value is Reference {\n    return value === UNDEFINED_REFERENCE;\n  }\n\n  expected(): string {\n    return `undefined`;\n  }\n}\n\nexport const CheckUndefinedReference = new UndefinedReferenceChecker();\n\nexport const CheckCapturedArguments: Checker<CapturedArguments> = CheckInterface({\n  positional: wrap(() => CheckArray(CheckReference)),\n  named: wrap(() => CheckDict(CheckReference)),\n});\n\nexport const CheckScope: Checker<Scope> = wrap(() => CheckInstanceof(ScopeImpl));\n\nexport const CheckComponentManager: Checker<InternalComponentManager> = CheckInterface({\n  getCapabilities: CheckFunction,\n});\n\nexport const CheckCapabilities: Checker<CapabilityMask> = CheckNumber as Checker<CapabilityMask>;\n\nexport const CheckComponentInstance: Checker<ComponentInstance> = CheckInterface({\n  definition: CheckUnknown,\n  state: CheckUnknown,\n  handle: CheckUnknown,\n  table: CheckUnknown,\n});\n\nexport const CheckCurriedComponentDefinition = CheckOr(CheckObject, CheckFunction);\n\nexport const CheckInvocation: Checker<Invocation> = CheckInterface({\n  handle: CheckNumber,\n  symbolTable: CheckProgramSymbolTable,\n});\n\nexport const CheckElementOperations: Checker<ElementOperations> = CheckInterface({\n  setAttribute: CheckFunction,\n});\n\nexport const CheckFinishedComponentInstance: Checker<ComponentInstance> = CheckInterface({\n  definition: CheckUnknown,\n  state: CheckUnknown,\n  handle: CheckHandle,\n  table: CheckProgramSymbolTable,\n});\n\nexport const CheckCompilableBlock: Checker<CompilableBlock> = CheckInterface({\n  compile: CheckFunction,\n  symbolTable: CheckBlockSymbolTable,\n});\n\nexport const CheckCompilableProgram: Checker<CompilableProgram> = CheckInterface({\n  compile: CheckFunction,\n  symbolTable: CheckProgramSymbolTable,\n});\n\nexport const CheckScopeBlock: Checker<ScopeBlock> = CheckInterface({\n  0: CheckCompilableBlock,\n  1: CheckScope,\n  2: CheckBlockSymbolTable,\n});\n\nexport const CheckComponentDefinition: Checker<ComponentDefinition> = CheckInterface({\n  resolvedName: CheckNullable(CheckString),\n  handle: CheckNumber,\n  state: CheckOr(CheckObject, CheckFunction),\n  manager: CheckComponentManager,\n  capabilities: CheckCapabilities,\n  compilable: CheckCompilableProgram,\n});\n","import type {\n  ArgumentError,\n  BlockArguments,\n  BlockSymbolTable,\n  BlockValue,\n  CapturedArguments,\n  CapturedBlockArguments,\n  CapturedNamedArguments,\n  CapturedPositionalArguments,\n  CompilableBlock,\n  Dict,\n  NamedArguments,\n  Nullable,\n  PositionalArguments,\n  Scope,\n  ScopeBlock,\n  VMArguments,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport type { Tag } from '@glimmer/validator';\nimport { check, CheckBlockSymbolTable, CheckHandle, CheckNullable, CheckOr } from '@glimmer/debug';\nimport { setLocalDebugType, unwrap } from '@glimmer/debug-util';\nimport { createDebugAliasRef, UNDEFINED_REFERENCE, valueForRef } from '@glimmer/reference';\nimport { dict, EMPTY_STRING_ARRAY, emptyArray, enumerate } from '@glimmer/util';\nimport { CONSTANT_TAG } from '@glimmer/validator';\nimport { $sp } from '@glimmer/vm';\n\nimport type { EvaluationStack } from './stack';\n\nimport { CheckCompilableBlock, CheckReference, CheckScope } from '../compiled/opcodes/-debug-strip';\n\n/*\n  The calling convention is:\n\n  * 0-N block arguments at the bottom\n  * 0-N positional arguments next (left-to-right)\n  * 0-N named arguments next\n*/\n\nexport class VMArgumentsImpl implements VMArguments {\n  private stack: Nullable<EvaluationStack> = null;\n  public positional = new PositionalArgumentsImpl();\n  public named = new NamedArgumentsImpl();\n  public blocks = new BlockArgumentsImpl();\n\n  constructor() {\n    setLocalDebugType('args', this);\n  }\n\n  empty(stack: EvaluationStack): this {\n    let base = stack.registers[$sp] + 1;\n\n    this.named.empty(stack, base);\n    this.positional.empty(stack, base);\n    this.blocks.empty(stack, base);\n\n    return this;\n  }\n\n  setup(\n    stack: EvaluationStack,\n    names: readonly string[],\n    blockNames: readonly string[],\n    positionalCount: number,\n    atNames: boolean\n  ) {\n    this.stack = stack;\n\n    /*\n           | ... | blocks      | positional  | named |\n           | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |\n     index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |\n                   ^             ^             ^  ^\n                 bbase         pbase       nbase  sp\n    */\n\n    let named = this.named;\n    let namedCount = names.length;\n    let namedBase = stack.registers[$sp] - namedCount + 1;\n\n    named.setup(stack, namedBase, namedCount, names, atNames);\n\n    let positional = this.positional;\n    let positionalBase = namedBase - positionalCount;\n\n    positional.setup(stack, positionalBase, positionalCount);\n\n    let blocks = this.blocks;\n    let blocksCount = blockNames.length;\n    let blocksBase = positionalBase - blocksCount * 3;\n\n    blocks.setup(stack, blocksBase, blocksCount, blockNames);\n  }\n\n  get base(): number {\n    return this.blocks.base;\n  }\n\n  get length(): number {\n    return this.positional.length + this.named.length + this.blocks.length * 3;\n  }\n\n  at(pos: number): Reference {\n    return this.positional.at(pos);\n  }\n\n  realloc(offset: number) {\n    let { stack } = this;\n    if (offset > 0 && stack !== null) {\n      let { positional, named } = this;\n      let newBase = positional.base + offset;\n      let length = positional.length + named.length;\n\n      for (let i = length - 1; i >= 0; i--) {\n        stack.copy(i + positional.base, i + newBase);\n      }\n\n      positional.base += offset;\n      named.base += offset;\n      stack.registers[$sp] += offset;\n    }\n  }\n\n  capture(): CapturedArguments {\n    let positional = this.positional.length === 0 ? EMPTY_POSITIONAL : this.positional.capture();\n    let named = this.named.length === 0 ? EMPTY_NAMED : this.named.capture();\n\n    return { named, positional } as CapturedArguments;\n  }\n\n  clear(): void {\n    let { stack, length } = this;\n    if (length > 0 && stack !== null) stack.pop(length);\n  }\n}\n\nconst EMPTY_REFERENCES = emptyArray<Reference>();\n\nexport class PositionalArgumentsImpl implements PositionalArguments {\n  public base = 0;\n  public length = 0;\n\n  private stack = null as Nullable<EvaluationStack>;\n\n  private _references: Nullable<readonly Reference[]> = null;\n\n  constructor() {\n    setLocalDebugType('args:positional', this);\n  }\n\n  empty(stack: EvaluationStack, base: number) {\n    this.stack = stack;\n    this.base = base;\n    this.length = 0;\n\n    this._references = EMPTY_REFERENCES;\n  }\n\n  setup(stack: EvaluationStack, base: number, length: number) {\n    this.stack = stack;\n    this.base = base;\n    this.length = length;\n\n    if (length === 0) {\n      this._references = EMPTY_REFERENCES;\n    } else {\n      this._references = null;\n    }\n  }\n\n  at(position: number): Reference {\n    let { base, length, stack } = this;\n\n    if (position < 0 || position >= length) {\n      return UNDEFINED_REFERENCE;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    return check(stack!.get(position, base), CheckReference);\n  }\n\n  capture(): CapturedPositionalArguments {\n    return this.references as CapturedPositionalArguments;\n  }\n\n  prepend(other: Reference[]) {\n    let additions = other.length;\n\n    if (additions > 0) {\n      let { base, length, stack } = this;\n\n      this.base = base = base - additions;\n      this.length = length + additions;\n\n      for (let i = 0; i < additions; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        stack!.set(other[i], i, base);\n      }\n\n      this._references = null;\n    }\n  }\n\n  private get references(): readonly Reference[] {\n    let references = this._references;\n\n    if (!references) {\n      let { stack, base, length } = this;\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      references = this._references = stack!.slice<Reference>(base, base + length);\n    }\n\n    return references;\n  }\n}\n\nexport class NamedArgumentsImpl implements NamedArguments {\n  public base = 0;\n  public length = 0;\n\n  declare private stack: EvaluationStack;\n\n  private _references: Nullable<readonly Reference[]> = null;\n\n  private _names: Nullable<readonly string[]> = EMPTY_STRING_ARRAY;\n  private _atNames: Nullable<readonly string[]> = EMPTY_STRING_ARRAY;\n\n  constructor() {\n    setLocalDebugType('args:named', this);\n  }\n\n  empty(stack: EvaluationStack, base: number) {\n    this.stack = stack;\n    this.base = base;\n    this.length = 0;\n\n    this._references = EMPTY_REFERENCES;\n    this._names = EMPTY_STRING_ARRAY;\n    this._atNames = EMPTY_STRING_ARRAY;\n  }\n\n  setup(\n    stack: EvaluationStack,\n    base: number,\n    length: number,\n    names: readonly string[],\n    atNames: boolean\n  ) {\n    this.stack = stack;\n    this.base = base;\n    this.length = length;\n\n    if (length === 0) {\n      this._references = EMPTY_REFERENCES;\n      this._names = EMPTY_STRING_ARRAY;\n      this._atNames = EMPTY_STRING_ARRAY;\n    } else {\n      this._references = null;\n\n      if (atNames) {\n        this._names = null;\n        this._atNames = names;\n      } else {\n        this._names = names;\n        this._atNames = null;\n      }\n    }\n  }\n\n  get names(): readonly string[] {\n    let names = this._names;\n\n    if (!names) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      names = this._names = this._atNames!.map(this.toSyntheticName);\n    }\n\n    return names;\n  }\n\n  get atNames(): readonly string[] {\n    let atNames = this._atNames;\n\n    if (!atNames) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      atNames = this._atNames = this._names!.map(this.toAtName);\n    }\n\n    return atNames;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get(name: string, atNames = false): Reference {\n    let { base, stack } = this;\n\n    let names = atNames ? this.atNames : this.names;\n\n    let idx = names.indexOf(name);\n\n    if (idx === -1) {\n      return UNDEFINED_REFERENCE;\n    }\n\n    let ref = stack.get<Reference>(idx, base);\n\n    if (import.meta.env.DEV) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      return createDebugAliasRef!(atNames ? name : `@${name}`, ref);\n    } else {\n      return ref;\n    }\n  }\n\n  capture(): CapturedNamedArguments {\n    let { names, references } = this;\n    let map = dict<Reference>();\n\n    for (const [i, name] of enumerate(names)) {\n      if (import.meta.env.DEV) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        map[name] = createDebugAliasRef!(`@${name}`, unwrap(references[i]));\n      } else {\n        map[name] = unwrap(references[i]);\n      }\n    }\n\n    return map as CapturedNamedArguments;\n  }\n\n  merge(other: Record<string, Reference>) {\n    let keys = Object.keys(other);\n\n    if (keys.length > 0) {\n      let { names, length, stack } = this;\n      let newNames = names.slice();\n\n      for (const name of keys) {\n        let idx = newNames.indexOf(name);\n\n        if (idx === -1) {\n          length = newNames.push(name);\n          stack.push(other[name]);\n        }\n      }\n\n      this.length = length;\n      this._references = null;\n      this._names = newNames;\n      this._atNames = null;\n    }\n  }\n\n  private get references(): readonly Reference[] {\n    let references = this._references;\n\n    if (!references) {\n      let { base, length, stack } = this;\n      references = this._references = stack.slice<Reference>(base, base + length);\n    }\n\n    return references;\n  }\n\n  private toSyntheticName(this: void, name: string): string {\n    return name.slice(1);\n  }\n\n  private toAtName(this: void, name: string): string {\n    return `@${name}`;\n  }\n}\n\nfunction toSymbolName(name: string): string {\n  return `&${name}`;\n}\n\nconst EMPTY_BLOCK_VALUES = emptyArray<BlockValue>();\n\nexport class BlockArgumentsImpl implements BlockArguments {\n  declare private stack: EvaluationStack;\n  private internalValues: Nullable<readonly BlockValue[]> = null;\n  private _symbolNames: Nullable<readonly string[]> = null;\n\n  public internalTag: Nullable<Tag> = null;\n  public names: readonly string[] = EMPTY_STRING_ARRAY;\n\n  public length = 0;\n  public base = 0;\n\n  constructor() {\n    setLocalDebugType('args:blocks', this);\n  }\n\n  empty(stack: EvaluationStack, base: number) {\n    this.stack = stack;\n    this.names = EMPTY_STRING_ARRAY;\n    this.base = base;\n    this.length = 0;\n    this._symbolNames = null;\n\n    this.internalTag = CONSTANT_TAG;\n    this.internalValues = EMPTY_BLOCK_VALUES;\n  }\n\n  setup(stack: EvaluationStack, base: number, length: number, names: readonly string[]) {\n    this.stack = stack;\n    this.names = names;\n    this.base = base;\n    this.length = length;\n    this._symbolNames = null;\n\n    if (length === 0) {\n      this.internalTag = CONSTANT_TAG;\n      this.internalValues = EMPTY_BLOCK_VALUES;\n    } else {\n      this.internalTag = null;\n      this.internalValues = null;\n    }\n  }\n\n  get values(): readonly BlockValue[] {\n    let values = this.internalValues;\n\n    if (!values) {\n      let { base, length, stack } = this;\n      values = this.internalValues = stack.slice<BlockValue>(base, base + length * 3);\n    }\n\n    return values;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get(name: string): Nullable<ScopeBlock> {\n    let idx = this.names.indexOf(name);\n\n    if (idx === -1) {\n      return null;\n    }\n\n    let { base, stack } = this;\n\n    let table = check(stack.get(idx * 3, base), CheckNullable(CheckBlockSymbolTable));\n    let scope = check(stack.get(idx * 3 + 1, base), CheckNullable(CheckScope));\n    let handle = check(\n      stack.get(idx * 3 + 2, base),\n      CheckNullable(CheckOr(CheckHandle, CheckCompilableBlock))\n    );\n\n    return handle === null ? null : ([handle, scope, table] as ScopeBlock);\n  }\n\n  capture(): CapturedBlockArguments {\n    return new CapturedBlockArgumentsImpl(this.names, this.values);\n  }\n\n  get symbolNames(): readonly string[] {\n    let symbolNames = this._symbolNames;\n\n    if (symbolNames === null) {\n      symbolNames = this._symbolNames = this.names.map(toSymbolName);\n    }\n\n    return symbolNames;\n  }\n}\n\nclass CapturedBlockArgumentsImpl implements CapturedBlockArguments {\n  public length: number;\n\n  constructor(\n    public names: readonly string[],\n    public values: readonly Nullable<BlockValue>[]\n  ) {\n    this.length = names.length;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get(name: string): Nullable<ScopeBlock> {\n    let idx = this.names.indexOf(name);\n\n    if (idx === -1) return null;\n\n    return [\n      this.values[idx * 3 + 2] as CompilableBlock,\n      this.values[idx * 3 + 1] as Scope,\n      this.values[idx * 3] as BlockSymbolTable,\n    ];\n  }\n}\n\nexport function createCapturedArgs(named: Dict<Reference>, positional: Reference[]) {\n  return {\n    named,\n    positional,\n  } as CapturedArguments;\n}\n\nexport function reifyNamed(named: CapturedNamedArguments) {\n  let reified = dict();\n\n  for (const [key, value] of Object.entries(named)) {\n    reified[key] = valueForRef(value);\n  }\n\n  return reified;\n}\n\nexport function reifyPositional(positional: CapturedPositionalArguments) {\n  return positional.map(valueForRef);\n}\n\nexport function reifyArgs(args: CapturedArguments) {\n  return {\n    named: reifyNamed(args.named),\n    positional: reifyPositional(args.positional),\n  };\n}\n\nconst ARGUMENT_ERROR = Symbol('ARGUMENT_ERROR');\n\nexport function isArgumentError(arg: unknown): arg is ArgumentError {\n  return (\n    arg !== null &&\n    typeof arg === 'object' &&\n    (arg as { [ARGUMENT_ERROR]: boolean })[ARGUMENT_ERROR]\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ArgumentErrorImpl(error: any) {\n  return {\n    [ARGUMENT_ERROR]: true,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    error,\n  };\n}\n\nexport function reifyNamedDebug(named: CapturedNamedArguments) {\n  let reified = dict();\n  for (const [key, value] of Object.entries(named)) {\n    try {\n      reified[key] = valueForRef(value);\n    } catch (e) {\n      reified[key] = ArgumentErrorImpl(e);\n    }\n  }\n\n  return reified;\n}\n\nexport function reifyPositionalDebug(positional: CapturedPositionalArguments) {\n  return positional.map((p) => {\n    try {\n      return valueForRef(p);\n    } catch (e) {\n      return ArgumentErrorImpl(e);\n    }\n  });\n}\n\nexport function reifyArgsDebug(args: CapturedArguments) {\n  let named = reifyNamedDebug(args.named);\n  let positional = reifyPositionalDebug(args.positional);\n  return {\n    named,\n    positional,\n  };\n}\n\nexport const EMPTY_NAMED = Object.freeze(Object.create(null)) as CapturedNamedArguments;\nexport const EMPTY_POSITIONAL = EMPTY_REFERENCES as CapturedPositionalArguments;\nexport const EMPTY_ARGS = createCapturedArgs(EMPTY_NAMED, EMPTY_POSITIONAL);\n","import type { Reference } from '@glimmer/reference';\nimport { createComputeRef, valueForRef } from '@glimmer/reference';\n\nexport function createConcatRef(partsRefs: Reference[]) {\n  return createComputeRef(() => {\n    const parts: string[] = [];\n\n    for (const ref of partsRefs) {\n      const value = valueForRef(ref);\n\n      if (value !== null && value !== undefined) {\n        parts.push(castToString(value));\n      }\n    }\n\n    if (parts.length > 0) {\n      return parts.join('');\n    }\n\n    return null;\n  });\n}\n\nfunction castToString(value: string | object) {\n  if (typeof value === 'string') {\n    return value;\n  } else if (typeof value.toString !== 'function') {\n    return '';\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n  return String(value);\n}\n","import type {\n  CapturedPositionalArguments,\n  CurriedType,\n  Helper,\n  HelperDefinitionState,\n  Initializable,\n  ScopeBlock,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport {\n  CURRIED_HELPER,\n  decodeHandle,\n  VM_CONCAT_OP,\n  VM_CURRY_OP,\n  VM_DYNAMIC_HELPER_OP,\n  VM_GET_BLOCK_OP,\n  VM_GET_DYNAMIC_VAR_OP,\n  VM_GET_PROPERTY_OP,\n  VM_GET_VARIABLE_OP,\n  VM_HAS_BLOCK_OP,\n  VM_HAS_BLOCK_PARAMS_OP,\n  VM_HELPER_OP,\n  VM_IF_INLINE_OP,\n  VM_LOG_OP,\n  VM_NOT_OP,\n  VM_ROOT_SCOPE_OP,\n  VM_SET_BLOCK_OP,\n  VM_SET_VARIABLE_OP,\n  VM_SPREAD_BLOCK_OP,\n} from '@glimmer/constants';\nimport {\n  check,\n  CheckBlockSymbolTable,\n  CheckHandle,\n  CheckMaybe,\n  CheckNullable,\n  CheckOr,\n} from '@glimmer/debug';\nimport { debugToString, localAssert } from '@glimmer/debug-util';\nimport { _hasDestroyableChildren, associateDestroyableChild, destroy } from '@glimmer/destroyable';\nimport { debugAssert, toBool } from '@glimmer/global-context';\nimport { getInternalHelperManager } from '@glimmer/manager';\nimport {\n  childRefFor,\n  createComputeRef,\n  FALSE_REFERENCE,\n  TRUE_REFERENCE,\n  UNDEFINED_REFERENCE,\n  valueForRef,\n} from '@glimmer/reference';\nimport { assign, isIndexable } from '@glimmer/util';\nimport { $v0 } from '@glimmer/vm';\n\nimport { isCurriedType, resolveCurriedValue } from '../../curried-value';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport createCurryRef from '../../references/curry-value';\nimport { reifyPositional } from '../../vm/arguments';\nimport { createConcatRef } from '../expressions/concat';\nimport {\n  CheckArguments,\n  CheckCapturedArguments,\n  CheckCompilableBlock,\n  CheckHelper,\n  CheckReference,\n  CheckScope,\n  CheckScopeBlock,\n  CheckUndefinedReference,\n} from './-debug-strip';\n\nAPPEND_OPCODES.add(VM_CURRY_OP, (vm, { op1: type, op2: _isStrict }) => {\n  let stack = vm.stack;\n\n  let definition = check(stack.pop(), CheckReference);\n  let capturedArgs = check(stack.pop(), CheckCapturedArguments);\n\n  let owner = vm.getOwner();\n  let resolver = vm.context.resolver;\n\n  let isStrict = false;\n\n  if (import.meta.env.DEV) {\n    // strict check only happens in import.meta.env.DEV builds, no reason to load it otherwise\n    isStrict = vm.constants.getValue<boolean>(decodeHandle(_isStrict));\n  }\n\n  vm.loadValue(\n    $v0,\n    createCurryRef(type as CurriedType, definition, owner, capturedArgs, resolver, isStrict)\n  );\n});\n\nAPPEND_OPCODES.add(VM_DYNAMIC_HELPER_OP, (vm) => {\n  let stack = vm.stack;\n  let ref = check(stack.pop(), CheckReference);\n  let args = check(stack.pop(), CheckArguments).capture();\n\n  let helperRef: Initializable<Reference>;\n  let initialOwner = vm.getOwner();\n\n  let helperInstanceRef = createComputeRef(() => {\n    if (helperRef !== undefined) {\n      destroy(helperRef);\n    }\n\n    let definition = valueForRef(ref);\n\n    if (isCurriedType(definition, CURRIED_HELPER)) {\n      let { definition: resolvedDef, owner, positional, named } = resolveCurriedValue(definition);\n\n      let helper = resolveHelper(resolvedDef, ref);\n\n      if (named !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        args.named = assign({}, ...named, args.named);\n      }\n\n      if (positional !== undefined) {\n        args.positional = positional.concat(args.positional) as CapturedPositionalArguments;\n      }\n\n      helperRef = helper(args, owner);\n\n      associateDestroyableChild(helperInstanceRef, helperRef);\n    } else if (isIndexable(definition)) {\n      let helper = resolveHelper(definition, ref);\n      helperRef = helper(args, initialOwner);\n\n      if (_hasDestroyableChildren(helperRef)) {\n        associateDestroyableChild(helperInstanceRef, helperRef);\n      }\n    } else {\n      helperRef = UNDEFINED_REFERENCE;\n    }\n  });\n\n  let helperValueRef = createComputeRef(() => {\n    valueForRef(helperInstanceRef);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    return valueForRef(helperRef!);\n  });\n\n  vm.associateDestroyable(helperInstanceRef);\n  vm.loadValue($v0, helperValueRef);\n});\n\nfunction resolveHelper(definition: HelperDefinitionState, ref: Reference): Helper {\n  let managerOrHelper = getInternalHelperManager(definition, true);\n  let helper;\n  if (managerOrHelper === null) {\n    helper = null;\n  } else {\n    helper =\n      typeof managerOrHelper === 'function'\n        ? managerOrHelper\n        : managerOrHelper.getHelper(definition);\n    localAssert(managerOrHelper, 'BUG: expected manager or helper');\n  }\n\n  debugAssert(\n    helper !== null,\n    () =>\n      `Expected a dynamic helper definition, but received an object or function that did not have a helper manager associated with it. The dynamic invocation was \\`{{${\n        ref.debugLabel\n      }}}\\` or \\`(${ref.debugLabel})\\`, and the incorrect definition is the value at the path \\`${\n        ref.debugLabel\n      }\\`, which was: ${debugToString?.(definition)}`\n  );\n\n  return helper;\n}\n\nAPPEND_OPCODES.add(VM_HELPER_OP, (vm, { op1: handle }) => {\n  let stack = vm.stack;\n  let helper = check(vm.constants.getValue(handle), CheckHelper);\n  let args = check(stack.pop(), CheckArguments);\n  let value = helper(args.capture(), vm.getOwner(), vm.dynamicScope());\n\n  if (_hasDestroyableChildren(value)) {\n    vm.associateDestroyable(value);\n  }\n\n  vm.loadValue($v0, value);\n});\n\nAPPEND_OPCODES.add(VM_GET_VARIABLE_OP, (vm, { op1: symbol }) => {\n  let expr = vm.referenceForSymbol(symbol);\n\n  vm.stack.push(expr);\n});\n\nAPPEND_OPCODES.add(VM_SET_VARIABLE_OP, (vm, { op1: symbol }) => {\n  let expr = check(vm.stack.pop(), CheckReference);\n  vm.scope().bindSymbol(symbol, expr);\n});\n\nAPPEND_OPCODES.add(VM_SET_BLOCK_OP, (vm, { op1: symbol }) => {\n  let handle = check(vm.stack.pop(), CheckCompilableBlock);\n  let scope = check(vm.stack.pop(), CheckScope);\n  let table = check(vm.stack.pop(), CheckBlockSymbolTable);\n\n  vm.scope().bindBlock(symbol, [handle, scope, table]);\n});\n\nAPPEND_OPCODES.add(VM_ROOT_SCOPE_OP, (vm, { op1: size }) => {\n  vm.pushRootScope(size, vm.getOwner());\n});\n\nAPPEND_OPCODES.add(VM_GET_PROPERTY_OP, (vm, { op1: _key }) => {\n  let key = vm.constants.getValue<string>(_key);\n  let expr = check(vm.stack.pop(), CheckReference);\n  vm.stack.push(childRefFor(expr, key));\n});\n\nAPPEND_OPCODES.add(VM_GET_BLOCK_OP, (vm, { op1: _block }) => {\n  let { stack } = vm;\n  let block = vm.scope().getBlock(_block);\n\n  stack.push(block);\n});\n\nAPPEND_OPCODES.add(VM_SPREAD_BLOCK_OP, (vm) => {\n  let { stack } = vm;\n  let block = check(stack.pop(), CheckNullable(CheckOr(CheckScopeBlock, CheckUndefinedReference)));\n\n  if (block && !isUndefinedReference(block)) {\n    let [handleOrCompilable, scope, table] = block;\n\n    stack.push(table);\n    stack.push(scope);\n    stack.push(handleOrCompilable);\n  } else {\n    stack.push(null);\n    stack.push(null);\n    stack.push(null);\n  }\n});\n\nfunction isUndefinedReference(input: ScopeBlock | Reference): input is Reference {\n  localAssert(\n    Array.isArray(input) || input === UNDEFINED_REFERENCE,\n    'a reference other than UNDEFINED_REFERENCE is illegal here'\n  );\n  return input === UNDEFINED_REFERENCE;\n}\n\nAPPEND_OPCODES.add(VM_HAS_BLOCK_OP, (vm) => {\n  let { stack } = vm;\n  let block = check(stack.pop(), CheckNullable(CheckOr(CheckScopeBlock, CheckUndefinedReference)));\n\n  if (block && !isUndefinedReference(block)) {\n    stack.push(TRUE_REFERENCE);\n  } else {\n    stack.push(FALSE_REFERENCE);\n  }\n});\n\nAPPEND_OPCODES.add(VM_HAS_BLOCK_PARAMS_OP, (vm) => {\n  // FIXME(mmun): should only need to push the symbol table\n  let block = vm.stack.pop();\n  let scope = vm.stack.pop();\n\n  check(block, CheckMaybe(CheckOr(CheckHandle, CheckCompilableBlock)));\n  check(scope, CheckMaybe(CheckScope));\n  let table = check(vm.stack.pop(), CheckMaybe(CheckBlockSymbolTable));\n\n  let hasBlockParams = table && table.parameters.length;\n  vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);\n});\n\nAPPEND_OPCODES.add(VM_CONCAT_OP, (vm, { op1: count }) => {\n  let out = new Array<Reference>(count);\n\n  for (let i = count; i > 0; i--) {\n    let offset = i - 1;\n    out[offset] = check(vm.stack.pop(), CheckReference);\n  }\n\n  vm.stack.push(createConcatRef(out));\n});\n\nAPPEND_OPCODES.add(VM_IF_INLINE_OP, (vm) => {\n  let condition = check(vm.stack.pop(), CheckReference);\n  let truthy = check(vm.stack.pop(), CheckReference);\n  let falsy = check(vm.stack.pop(), CheckReference);\n\n  vm.stack.push(\n    createComputeRef(() => {\n      if (toBool(valueForRef(condition))) {\n        return valueForRef(truthy);\n      } else {\n        return valueForRef(falsy);\n      }\n    })\n  );\n});\n\nAPPEND_OPCODES.add(VM_NOT_OP, (vm) => {\n  let ref = check(vm.stack.pop(), CheckReference);\n\n  vm.stack.push(\n    createComputeRef(() => {\n      return !toBool(valueForRef(ref));\n    })\n  );\n});\n\nAPPEND_OPCODES.add(VM_GET_DYNAMIC_VAR_OP, (vm) => {\n  let scope = vm.dynamicScope();\n  let stack = vm.stack;\n  let nameRef = check(stack.pop(), CheckReference);\n\n  stack.push(\n    createComputeRef(() => {\n      let name = String(valueForRef(nameRef));\n      return valueForRef(scope.get(name));\n    })\n  );\n});\n\nAPPEND_OPCODES.add(VM_LOG_OP, (vm) => {\n  let { positional } = check(vm.stack.pop(), CheckArguments).capture();\n\n  vm.loadValue(\n    $v0,\n    createComputeRef(() => {\n      // eslint-disable-next-line no-console\n      console.log(...reifyPositional(positional));\n    })\n  );\n});\n","import type {\n  CapturedArguments,\n  ClassicResolver,\n  CurriedType,\n  Dict,\n  Maybe,\n  Nullable,\n  Owner,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { CURRIED_COMPONENT } from '@glimmer/constants';\nimport { expect } from '@glimmer/debug-util';\nimport { createComputeRef, valueForRef } from '@glimmer/reference';\nimport { isIndexable } from '@glimmer/util';\n\nimport { curry, isCurriedType } from '../curried-value';\n\nexport default function createCurryRef(\n  type: CurriedType,\n  inner: Reference,\n  owner: Owner,\n  args: Nullable<CapturedArguments>,\n  resolver: Nullable<ClassicResolver>,\n  isStrict: boolean\n) {\n  let lastValue: Maybe<Dict> | string, curriedDefinition: object | string | null;\n\n  return createComputeRef(() => {\n    let value = valueForRef(inner) as Maybe<Dict> | string;\n\n    if (value === lastValue) {\n      return curriedDefinition;\n    }\n\n    if (isCurriedType(value, type)) {\n      curriedDefinition = args ? curry(type, value, owner, args) : args;\n    } else if (type === CURRIED_COMPONENT && typeof value === 'string' && value) {\n      // Only components should enter this path, as helpers and modifiers do not\n      // support string based resolution\n\n      if (import.meta.env.DEV) {\n        if (isStrict) {\n          throw new Error(\n            `Attempted to resolve a dynamic component with a string definition, \\`${value}\\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`\n          );\n        }\n\n        let resolvedDefinition =\n          expect(\n            resolver,\n            'BUG: expected resolver for curried component definitions'\n          ).lookupComponent?.(value, owner) ?? null;\n\n        if (!resolvedDefinition) {\n          throw new Error(\n            `Attempted to resolve \\`${value}\\`, which was expected to be a component, but nothing was found.`\n          );\n        }\n      }\n\n      curriedDefinition = curry(type, value, owner, args);\n    } else if (isIndexable(value)) {\n      curriedDefinition = curry(type, value, owner, args);\n    } else {\n      curriedDefinition = null;\n    }\n\n    lastValue = value;\n\n    return curriedDefinition;\n  });\n}\n","import type { SimpleText, UpdatingOpcode } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { valueForRef } from '@glimmer/reference';\n\nimport { isEmpty, isString } from '../../dom/normalize';\n\nexport default class DynamicTextContent implements UpdatingOpcode {\n  constructor(\n    public node: SimpleText,\n    private reference: Reference,\n    private lastValue: string\n  ) {}\n\n  evaluate() {\n    let value = valueForRef(this.reference);\n\n    let { lastValue } = this;\n\n    if (value === lastValue) return;\n\n    let normalized: string;\n\n    if (isEmpty(value)) {\n      normalized = '';\n    } else if (isString(value)) {\n      normalized = value;\n    } else {\n      normalized = String(value);\n    }\n\n    if (normalized !== lastValue) {\n      let textNode = this.node;\n      textNode.nodeValue = this.lastValue = normalized;\n    }\n  }\n}\n","import {\n  CURRIED_COMPONENT,\n  CURRIED_HELPER,\n  VM_APPEND_DOCUMENT_FRAGMENT_OP,\n  VM_APPEND_HTML_OP,\n  VM_APPEND_NODE_OP,\n  VM_APPEND_SAFE_HTML_OP,\n  VM_APPEND_TEXT_OP,\n  VM_CONTENT_TYPE_OP,\n  VM_DYNAMIC_CONTENT_TYPE_OP,\n} from '@glimmer/constants';\nimport {\n  check,\n  CheckDocumentFragment,\n  CheckNode,\n  CheckSafeString,\n  CheckString,\n} from '@glimmer/debug';\nimport { hasInternalComponentManager, hasInternalHelperManager } from '@glimmer/manager';\nimport { isConstRef, valueForRef } from '@glimmer/reference';\nimport { isIndexable } from '@glimmer/util';\nimport { ContentType } from '@glimmer/vm';\n\nimport { isCurriedType } from '../../curried-value';\nimport { isEmpty, isFragment, isNode, isSafeString, shouldCoerce } from '../../dom/normalize';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport DynamicTextContent from '../../vm/content/text';\nimport { CheckReference } from './-debug-strip';\nimport { AssertFilter } from './vm';\n\nfunction toContentType(value: unknown) {\n  if (shouldCoerce(value)) {\n    return ContentType.String;\n  } else if (\n    isCurriedType(value, CURRIED_COMPONENT) ||\n    hasInternalComponentManager(value as object)\n  ) {\n    return ContentType.Component;\n  } else if (isCurriedType(value, CURRIED_HELPER) || hasInternalHelperManager(value as object)) {\n    return ContentType.Helper;\n  } else if (isSafeString(value)) {\n    return ContentType.SafeString;\n  } else if (isFragment(value)) {\n    return ContentType.Fragment;\n  } else if (isNode(value)) {\n    return ContentType.Node;\n  } else {\n    return ContentType.String;\n  }\n}\n\nfunction toDynamicContentType(value: unknown) {\n  if (!isIndexable(value)) {\n    return ContentType.String;\n  }\n\n  if (isCurriedType(value, CURRIED_COMPONENT) || hasInternalComponentManager(value)) {\n    return ContentType.Component;\n  } else {\n    if (\n      import.meta.env.DEV &&\n      !isCurriedType(value, CURRIED_HELPER) &&\n      !hasInternalHelperManager(value)\n    ) {\n      throw new Error(\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n        `Attempted use a dynamic value as a component or helper, but that value did not have an associated component or helper manager. The value was: ${value}`\n      );\n    }\n\n    return ContentType.Helper;\n  }\n}\n\nAPPEND_OPCODES.add(VM_CONTENT_TYPE_OP, (vm) => {\n  let reference = check(vm.stack.peek(), CheckReference);\n\n  vm.stack.push(toContentType(valueForRef(reference)));\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new AssertFilter(reference, toContentType));\n  }\n});\n\nAPPEND_OPCODES.add(VM_DYNAMIC_CONTENT_TYPE_OP, (vm) => {\n  let reference = check(vm.stack.peek(), CheckReference);\n\n  vm.stack.push(toDynamicContentType(valueForRef(reference)));\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new AssertFilter(reference, toDynamicContentType));\n  }\n});\n\nAPPEND_OPCODES.add(VM_APPEND_HTML_OP, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let rawValue = valueForRef(reference);\n  let value = isEmpty(rawValue) ? '' : String(rawValue);\n\n  vm.tree().appendDynamicHTML(value);\n});\n\nAPPEND_OPCODES.add(VM_APPEND_SAFE_HTML_OP, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let rawValue = check(valueForRef(reference), CheckSafeString).toHTML();\n  let value = isEmpty(rawValue) ? '' : check(rawValue, CheckString);\n\n  vm.tree().appendDynamicHTML(value);\n});\n\nAPPEND_OPCODES.add(VM_APPEND_TEXT_OP, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let rawValue = valueForRef(reference);\n  let value = isEmpty(rawValue) ? '' : String(rawValue);\n\n  let node = vm.tree().appendDynamicText(value);\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new DynamicTextContent(node, reference, value));\n  }\n});\n\nAPPEND_OPCODES.add(VM_APPEND_DOCUMENT_FRAGMENT_OP, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let value = check(valueForRef(reference), CheckDocumentFragment);\n\n  vm.tree().appendDynamicFragment(value);\n});\n\nAPPEND_OPCODES.add(VM_APPEND_NODE_OP, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let value = check(valueForRef(reference), CheckNode);\n\n  vm.tree().appendDynamicNode(value);\n});\n","// Allow the contents of `debugCallback` without extra annotations\n/* eslint-disable @typescript-eslint/no-unused-expressions */\nimport type { DebuggerInfo, Scope } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { decodeHandle, VM_DEBUGGER_OP } from '@glimmer/constants';\nimport { unwrap } from '@glimmer/debug-util';\nimport { childRefFor, valueForRef } from '@glimmer/reference';\n\nimport { APPEND_OPCODES } from '../../opcodes';\n\nexport type DebugGet = (path: string) => unknown;\n\nexport type DebugCallback = (context: unknown, get: DebugGet) => void;\n\nfunction debugCallback(context: unknown, get: DebugGet): void {\n  // eslint-disable-next-line no-console\n  console.info('Use `context`, and `get(<path>)` to debug this template.');\n\n  // for example...\n  context === get('this');\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n}\n\nlet callback = debugCallback;\n\n// For testing purposes\nexport function setDebuggerCallback(cb: DebugCallback) {\n  callback = cb;\n}\n\nexport function resetDebuggerCallback() {\n  callback = debugCallback;\n}\n\nclass ScopeInspector {\n  #symbols: DebuggerInfo;\n\n  constructor(\n    private scope: Scope,\n    symbols: DebuggerInfo\n  ) {\n    this.#symbols = symbols;\n  }\n\n  get(path: string): Reference {\n    let { scope } = this;\n    let symbols = this.#symbols;\n\n    let parts = path.split('.');\n    let [head, ...tail] = path.split('.') as [string, ...string[]];\n\n    let ref: Reference;\n\n    if (head === 'this') {\n      ref = scope.getSelf();\n    } else if (symbols.locals[head]) {\n      ref = unwrap(scope.getSymbol(symbols.locals[head]));\n    } else {\n      ref = this.scope.getSelf();\n      tail = parts;\n    }\n\n    return tail.reduce((r, part) => childRefFor(r, part), ref);\n  }\n}\n\nAPPEND_OPCODES.add(VM_DEBUGGER_OP, (vm, { op1: _debugInfo }) => {\n  let debuggerInfo = vm.constants.getValue<DebuggerInfo>(decodeHandle(_debugInfo));\n  let inspector = new ScopeInspector(vm.scope(), debuggerInfo);\n  callback(valueForRef(vm.getSelf()), (path) => valueForRef(inspector.get(path)));\n});\n","import { VM_ENTER_LIST_OP, VM_EXIT_LIST_OP, VM_ITERATE_OP } from '@glimmer/constants';\nimport { check } from '@glimmer/debug';\nimport { createIteratorRef, valueForRef } from '@glimmer/reference';\n\nimport { APPEND_OPCODES } from '../../opcodes';\nimport { CheckIterator, CheckReference } from './-debug-strip';\nimport { AssertFilter } from './vm';\n\nAPPEND_OPCODES.add(VM_ENTER_LIST_OP, (vm, { op1: relativeStart, op2: elseTarget }) => {\n  let stack = vm.stack;\n  let listRef = check(stack.pop(), CheckReference);\n  let keyRef = check(stack.pop(), CheckReference);\n\n  let keyValue = valueForRef(keyRef);\n  // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n  let key = keyValue === null ? '@identity' : String(keyValue);\n\n  let iteratorRef = createIteratorRef(listRef, key);\n  let iterator = valueForRef(iteratorRef);\n\n  vm.updateWith(new AssertFilter(iteratorRef, (iterator) => iterator.isEmpty()));\n\n  if (iterator.isEmpty()) {\n    // TODO: Fix this offset, should be accurate\n    vm.lowlevel.goto(elseTarget + 1);\n  } else {\n    vm.enterList(iteratorRef, relativeStart);\n    vm.stack.push(iterator);\n  }\n});\n\nAPPEND_OPCODES.add(VM_EXIT_LIST_OP, (vm) => {\n  vm.exitList();\n});\n\nAPPEND_OPCODES.add(VM_ITERATE_OP, (vm, { op1: breaks }) => {\n  let stack = vm.stack;\n  let iterator = check(stack.peek(), CheckIterator);\n  let item = iterator.next();\n\n  if (item !== null) {\n    vm.registerItem(vm.enterItem(item));\n  } else {\n    vm.lowlevel.goto(breaks);\n  }\n});\n","import type { InternalComponentCapabilities, InternalComponentManager } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { setInternalComponentManager } from '@glimmer/manager';\nimport { NULL_REFERENCE } from '@glimmer/reference';\n\nconst CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  createCaller: false,\n  dynamicScope: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport class TemplateOnlyComponentManager implements InternalComponentManager {\n  getCapabilities(): InternalComponentCapabilities {\n    return CAPABILITIES;\n  }\n\n  getDebugName({ name }: TemplateOnlyComponentDefinition): string {\n    return name;\n  }\n\n  getSelf(): Reference {\n    return NULL_REFERENCE;\n  }\n\n  getDestroyable(): null {\n    return null;\n  }\n}\n\nexport const TEMPLATE_ONLY_COMPONENT_MANAGER = new TemplateOnlyComponentManager();\n\n// This is only exported for types, don't use this class directly\nexport class TemplateOnlyComponentDefinition {\n  constructor(\n    public moduleName = '@glimmer/component/template-only',\n    public name = '(unknown template-only component)'\n  ) {}\n\n  toString() {\n    return this.moduleName;\n  }\n}\n\nsetInternalComponentManager(\n  TEMPLATE_ONLY_COMPONENT_MANAGER,\n  TemplateOnlyComponentDefinition.prototype\n);\n\n/**\n  This utility function is used to declare a given component has no backing class. When the rendering engine detects this it\n  is able to perform a number of optimizations. Templates that are associated with `templateOnly()` will be rendered _as is_\n  without adding a wrapping `<div>` (or any of the other element customization behaviors of [@ember/component](/ember/release/classes/Component)).\n  Specifically, this means that the template will be rendered as \"outer HTML\".\n\n  In general, this method will be used by build time tooling and would not be directly written in an application. However,\n  at times it may be useful to use directly to leverage the \"outer HTML\" semantics mentioned above. For example, if an addon would like\n  to use these semantics for its templates but cannot be certain it will only be consumed by applications that have enabled the\n  `template-only-glimmer-components` optional feature.\n\n  @example\n\n  ```js\n  import { templateOnlyComponent } from '@glimmer/runtime';\n\n  export default templateOnlyComponent();\n  ```\n\n  @public\n  @method templateOnly\n  @param {String} moduleName the module name that the template only component represents, this will be used for debugging purposes\n  @category EMBER_GLIMMER_SET_COMPONENT_TEMPLATE\n*/\n\nexport function templateOnlyComponent(\n  moduleName?: string,\n  name?: string\n): TemplateOnlyComponentDefinition {\n  return new TemplateOnlyComponentDefinition(moduleName, name);\n}\n","import type {\n  Bounds,\n  Dict,\n  Namespace,\n  Nullable,\n  SimpleComment,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n  SimpleText,\n} from '@glimmer/interfaces';\nimport { INSERT_BEFORE_BEGIN, INSERT_BEFORE_END, NS_MATHML, NS_SVG } from '@glimmer/constants';\nimport { expect } from '@glimmer/debug-util';\n\nimport { ConcreteBounds } from '../bounds';\n\n// http://www.w3.org/TR/html/syntax.html#html-integration-point\nconst SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };\n\n// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes\n// TODO: Adjust SVG attributes\n\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\n// TODO: Adjust SVG elements\n\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\nexport const BLACKLIST_TABLE = Object.create(null) as Dict<1>;\n\nexport class DOMOperations {\n  declare protected uselessElement: SimpleElement; // Set by this.setupUselessElement() in constructor\n\n  constructor(protected document: SimpleDocument) {\n    this.setupUselessElement();\n  }\n\n  // split into separate method so that NodeDOMTreeConstruction\n  // can override it.\n  protected setupUselessElement() {\n    this.uselessElement = this.document.createElement('div');\n  }\n\n  createElement(tag: string, context?: SimpleElement): SimpleElement {\n    let isElementInSVGNamespace: boolean,\n      isHTMLIntegrationPoint: boolean,\n      isElementInMathMlNamespace: boolean,\n      ns: Namespace;\n\n    if (context) {\n      isElementInSVGNamespace = context.namespaceURI === NS_SVG || tag === 'svg';\n      isElementInMathMlNamespace = context.namespaceURI === NS_MATHML || tag === 'math';\n      isHTMLIntegrationPoint = !!(SVG_INTEGRATION_POINTS as Dict<number>)[context.tagName];\n    } else {\n      isElementInSVGNamespace = tag === 'svg';\n      isElementInMathMlNamespace = tag === 'math';\n      isHTMLIntegrationPoint = false;\n    }\n\n    if ((isElementInMathMlNamespace || isElementInSVGNamespace) && !isHTMLIntegrationPoint) {\n      // FIXME: This does not properly handle <font> with color, face, or\n      // size attributes, which is also disallowed by the spec. We should fix\n      // this.\n      if (BLACKLIST_TABLE[tag]) {\n        throw new Error(`Cannot create a ${tag} inside an SVG context`);\n      }\n      if (isElementInMathMlNamespace) {\n        ns = NS_MATHML;\n      } else {\n        ns = NS_SVG;\n      }\n\n      return this.document.createElementNS(ns, tag);\n    } else {\n      return this.document.createElement(tag);\n    }\n  }\n\n  insertBefore(parent: SimpleElement, node: SimpleNode, reference: Nullable<SimpleNode>) {\n    parent.insertBefore(node, reference);\n  }\n\n  insertHTMLBefore(parent: SimpleElement, nextSibling: Nullable<SimpleNode>, html: string): Bounds {\n    if (html === '') {\n      const comment = this.createComment('');\n      parent.insertBefore(comment, nextSibling);\n      return new ConcreteBounds(parent, comment, comment);\n    }\n\n    const prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n    let last: SimpleNode;\n\n    if (nextSibling === null) {\n      parent.insertAdjacentHTML(INSERT_BEFORE_END, html);\n      last = expect(parent.lastChild, 'bug in insertAdjacentHTML?');\n    } else if (nextSibling instanceof HTMLElement) {\n      nextSibling.insertAdjacentHTML('beforebegin', html);\n      last = expect(nextSibling.previousSibling, 'bug in insertAdjacentHTML?');\n    } else {\n      // Non-element nodes do not support insertAdjacentHTML, so add an\n      // element and call it on that element. Then remove the element.\n      //\n      // This also protects Edge, IE and Firefox w/o the inspector open\n      // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts\n      const { uselessElement } = this;\n\n      parent.insertBefore(uselessElement, nextSibling);\n      uselessElement.insertAdjacentHTML(INSERT_BEFORE_BEGIN, html);\n      last = expect(uselessElement.previousSibling, 'bug in insertAdjacentHTML?');\n      parent.removeChild(uselessElement);\n    }\n\n    const first = expect(prev ? prev.nextSibling : parent.firstChild, 'bug in insertAdjacentHTML?');\n    return new ConcreteBounds(parent, first, last);\n  }\n\n  createTextNode(text: string): SimpleText {\n    return this.document.createTextNode(text);\n  }\n\n  createComment(data: string): SimpleComment {\n    return this.document.createComment(data);\n  }\n}\n\nexport function moveNodesBefore(\n  source: SimpleNode,\n  target: SimpleElement,\n  nextSibling: Nullable<SimpleNode>\n): Bounds {\n  const first = expect(source.firstChild, 'source is empty');\n  let last: SimpleNode = first;\n  let current: Nullable<SimpleNode> = first;\n\n  while (current) {\n    const next: Nullable<SimpleNode> = current.nextSibling;\n\n    target.insertBefore(current, nextSibling);\n\n    last = current;\n    current = next;\n  }\n\n  return new ConcreteBounds(target, first, last);\n}\n","import type {\n  Bounds,\n  Nullable,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport { INSERT_AFTER_BEGIN, INSERT_BEFORE_END, NS_SVG } from '@glimmer/constants';\nimport { castToBrowser, localAssert, unwrap } from '@glimmer/debug-util';\nimport { clearElement } from '@glimmer/util';\n\nimport type { DOMOperations } from '../dom/operations';\n\nimport { moveNodesBefore } from '../dom/operations';\n\n// Patch:    insertAdjacentHTML on SVG Fix\n// Browsers: Safari, IE, Edge, Firefox ~33-34\n// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is\n//           present but throws an exception on IE and Edge. Old versions of\n//           Firefox create nodes in the incorrect namespace.\n// Fix:      Since IE and Edge silently fail to create SVG nodes using\n//           innerHTML, and because Firefox may create nodes in the incorrect\n//           namespace using innerHTML on SVG elements, an HTML-string wrapping\n//           approach is used. A pre/post SVG tag is added to the string, then\n//           that whole string is added to a div. The created nodes are plucked\n//           out and applied to the target location on DOM.\nexport function applySVGInnerHTMLFix(\n  document: Nullable<SimpleDocument>,\n  DOMClass: typeof DOMOperations,\n  svgNamespace: typeof NS_SVG\n): typeof DOMOperations {\n  if (!document) return DOMClass;\n\n  if (!shouldApplyFix(document, svgNamespace)) {\n    return DOMClass;\n  }\n\n  const div = document.createElement('div');\n\n  return class DOMChangesWithSVGInnerHTMLFix extends DOMClass {\n    override insertHTMLBefore(\n      parent: SimpleElement,\n      nextSibling: Nullable<SimpleNode>,\n      html: string\n    ): Bounds {\n      if (html === '') {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      if (parent.namespaceURI !== svgNamespace) {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      return fixSVG(parent, div, html, nextSibling);\n    }\n  };\n}\n\nfunction fixSVG(\n  parent: SimpleElement,\n  div: SimpleElement,\n  html: string,\n  reference: Nullable<SimpleNode>\n): Bounds {\n  localAssert(html !== '', 'html cannot be empty');\n\n  let source: SimpleNode;\n\n  // This is important, because descendants of the <foreignObject> integration\n  // point are parsed in the HTML namespace\n  if (parent.tagName.toUpperCase() === 'FOREIGNOBJECT') {\n    // IE, Edge: also do not correctly support using `innerHTML` on SVG\n    // namespaced elements. So here a wrapper is used.\n    const wrappedHtml = '<svg><foreignObject>' + html + '</foreignObject></svg>';\n\n    clearElement(div);\n    div.insertAdjacentHTML(INSERT_AFTER_BEGIN, wrappedHtml);\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    source = div.firstChild!.firstChild!;\n  } else {\n    // IE, Edge: also do not correctly support using `innerHTML` on SVG\n    // namespaced elements. So here a wrapper is used.\n    const wrappedHtml = '<svg>' + html + '</svg>';\n\n    clearElement(div);\n    div.insertAdjacentHTML(INSERT_AFTER_BEGIN, wrappedHtml);\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    source = div.firstChild!;\n  }\n\n  return moveNodesBefore(source, parent, reference);\n}\n\nfunction shouldApplyFix(document: SimpleDocument, svgNamespace: typeof NS_SVG) {\n  const svg = document.createElementNS(svgNamespace, 'svg');\n\n  try {\n    svg.insertAdjacentHTML(INSERT_BEFORE_END, '<circle></circle>');\n  } catch {\n    // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG\n    // Safari: Will throw, insertAdjacentHTML is not present on SVG\n  } finally {\n    // FF: Old versions will create a node in the wrong namespace\n    if (\n      svg.childNodes.length === 1 &&\n      castToBrowser(unwrap(svg.firstChild), 'SVG').namespaceURI === NS_SVG\n    ) {\n      // The test worked as expected, no fix required\n      // eslint-disable-next-line no-unsafe-finally\n      return false;\n    }\n\n    // eslint-disable-next-line no-unsafe-finally\n    return true;\n  }\n}\n","import type {\n  Bounds,\n  Nullable,\n  SimpleComment,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport { INSERT_BEFORE_END } from '@glimmer/constants';\n\nimport type { DOMOperations } from '../dom/operations';\n\n// Patch:    Adjacent text node merging fix\n// Browsers: IE, Edge, Firefox w/o inspector open\n// Reason:   These browsers will merge adjacent text nodes. For example given\n//           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers\n//           with proper behavior will populate div.childNodes with two items.\n//           These browsers will populate it with one merged node instead.\n// Fix:      Add these nodes to a wrapper element, then iterate the childNodes\n//           of that wrapper and move the nodes to their target location. Note\n//           that potential SVG bugs will have been handled before this fix.\n//           Note that this fix must only apply to the previous text node, as\n//           the base implementation of `insertHTMLBefore` already handles\n//           following text nodes correctly.\nexport function applyTextNodeMergingFix(\n  document: Nullable<SimpleDocument>,\n  DOMClass: typeof DOMOperations\n): typeof DOMOperations {\n  if (!document) return DOMClass;\n\n  if (!shouldApplyFix(document)) {\n    return DOMClass;\n  }\n\n  return class DOMChangesWithTextNodeMergingFix extends DOMClass {\n    private uselessComment: SimpleComment;\n\n    constructor(document: SimpleDocument) {\n      super(document);\n      this.uselessComment = document.createComment('');\n    }\n\n    override insertHTMLBefore(\n      parent: SimpleElement,\n      nextSibling: Nullable<SimpleNode>,\n      html: string\n    ): Bounds {\n      if (html === '') {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      let didSetUselessComment = false;\n\n      const nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n\n      if (nextPrevious && nextPrevious instanceof Text) {\n        didSetUselessComment = true;\n        parent.insertBefore(this.uselessComment, nextSibling);\n      }\n\n      const bounds = super.insertHTMLBefore(parent, nextSibling, html);\n\n      if (didSetUselessComment) {\n        parent.removeChild(this.uselessComment);\n      }\n\n      return bounds;\n    }\n  };\n}\n\nfunction shouldApplyFix(document: SimpleDocument) {\n  const mergingTextDiv = document.createElement('div');\n\n  mergingTextDiv.appendChild(document.createTextNode('first'));\n  mergingTextDiv.insertAdjacentHTML(INSERT_BEFORE_END, 'second');\n\n  if (mergingTextDiv.childNodes.length === 2) {\n    // It worked as expected, no fix required\n    return false;\n  }\n\n  return true;\n}\n","import type {\n  AttrNamespace,\n  ElementNamespace,\n  GlimmerTreeConstruction,\n  Nullable,\n  SimpleDocument,\n  SimpleElement,\n} from '@glimmer/interfaces';\nimport { NS_SVG } from '@glimmer/constants';\nimport { castToSimple } from '@glimmer/debug-util';\n\nimport { applySVGInnerHTMLFix } from '../compat/svg-inner-html-fix';\nimport { applyTextNodeMergingFix } from '../compat/text-node-merging-fix';\nimport { DOMOperations } from './operations';\n\nconst doc: Nullable<SimpleDocument> =\n  typeof document === 'undefined' ? null : castToSimple(document);\n\nexport class TreeConstruction extends DOMOperations implements GlimmerTreeConstruction {\n  createElementNS(namespace: ElementNamespace, tag: string): SimpleElement {\n    return this.document.createElementNS(namespace, tag);\n  }\n\n  setAttribute(\n    element: SimpleElement,\n    name: string,\n    value: string,\n    namespace: Nullable<AttrNamespace> = null\n  ) {\n    if (namespace) {\n      element.setAttributeNS(namespace, name, value);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n}\n\nlet appliedTreeConstruction = TreeConstruction;\nappliedTreeConstruction = applyTextNodeMergingFix(\n  doc,\n  appliedTreeConstruction\n) as typeof TreeConstruction;\nappliedTreeConstruction = applySVGInnerHTMLFix(\n  doc,\n  appliedTreeConstruction,\n  NS_SVG\n) as typeof TreeConstruction;\n\nexport const DOMTreeConstruction = appliedTreeConstruction;\nexport type DOMTreeConstruction = TreeConstruction;\n","import type {\n  GlimmerTreeChanges,\n  Nullable,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport { NS_SVG } from '@glimmer/constants';\nimport { castToSimple } from '@glimmer/debug-util';\n\nimport { applySVGInnerHTMLFix } from '../compat/svg-inner-html-fix';\nimport { applyTextNodeMergingFix } from '../compat/text-node-merging-fix';\nimport { BLACKLIST_TABLE, DOMOperations } from './operations';\n\n[\n  'b',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'center',\n  'code',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'hr',\n  'i',\n  'img',\n  'li',\n  'listing',\n  'main',\n  'meta',\n  'nobr',\n  'ol',\n  'p',\n  'pre',\n  'ruby',\n  's',\n  'small',\n  'span',\n  'strong',\n  'strike',\n  'sub',\n  'sup',\n  'table',\n  'tt',\n  'u',\n  'ul',\n  'var',\n].forEach((tag) => (BLACKLIST_TABLE[tag] = 1));\n\nconst WHITESPACE =\n  /[\\t\\n\\v\\f\\r \\xa0\\u{1680}\\u{180e}\\u{2000}-\\u{200a}\\u{2028}\\u{2029}\\u{202f}\\u{205f}\\u{3000}\\u{feff}]/u;\n\nconst doc: Nullable<SimpleDocument> =\n  typeof document === 'undefined' ? null : castToSimple(document);\n\nexport function isWhitespace(string: string) {\n  return WHITESPACE.test(string);\n}\n\nexport class DOMChangesImpl extends DOMOperations implements GlimmerTreeChanges {\n  protected namespace: Nullable<string>;\n\n  constructor(protected override document: SimpleDocument) {\n    super(document);\n    this.namespace = null;\n  }\n\n  setAttribute(element: SimpleElement, name: string, value: string) {\n    element.setAttribute(name, value);\n  }\n\n  removeAttribute(element: SimpleElement, name: string) {\n    element.removeAttribute(name);\n  }\n\n  insertAfter(element: SimpleElement, node: SimpleNode, reference: SimpleNode) {\n    this.insertBefore(element, node, reference.nextSibling);\n  }\n}\n\nlet helper = DOMChangesImpl;\n\nhelper = applyTextNodeMergingFix(doc, helper) as typeof DOMChangesImpl;\nhelper = applySVGInnerHTMLFix(doc, helper, NS_SVG) as typeof DOMChangesImpl;\n\nexport const DOMChanges = helper;\nexport { DOMTreeConstruction } from './api';\n","import type { Dict, SimpleElement } from '@glimmer/interfaces';\n\n/*\n * @method normalizeProperty\n * @param element {HTMLElement}\n * @param slotName {String}\n * @returns {Object} { name, type }\n */\nexport function normalizeProperty(element: SimpleElement, slotName: string) {\n  let type, normalized;\n\n  if (slotName in element) {\n    normalized = slotName;\n    type = 'prop';\n  } else {\n    let lower = slotName.toLowerCase();\n    if (lower in element) {\n      type = 'prop';\n      normalized = lower;\n    } else {\n      type = 'attr';\n      normalized = slotName;\n    }\n  }\n\n  if (\n    type === 'prop' &&\n    (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))\n  ) {\n    type = 'attr';\n  }\n\n  return { normalized, type };\n}\n\nexport function normalizePropertyValue(value: unknown): unknown {\n  if (value === '') {\n    return true;\n  }\n\n  return value;\n}\n\n// properties that MUST be set as attributes, due to:\n// * browser bug\n// * strange spec outlier\nconst ATTR_OVERRIDES: Dict<Dict> = {\n  INPUT: {\n    form: true,\n    // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false\n    // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false\n    // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true\n    autocorrect: true,\n    // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true\n    // Safari 9.1.3: 'list' in document.createElement('input') === false\n    list: true,\n  },\n\n  // element.form is actually a legitimate readOnly property, that is to be\n  // mutated, but must be mutated by setAttribute...\n  SELECT: { form: true },\n  OPTION: { form: true },\n  TEXTAREA: { form: true },\n  LABEL: { form: true },\n  FIELDSET: { form: true },\n  LEGEND: { form: true },\n  OBJECT: { form: true },\n  OUTPUT: { form: true },\n  BUTTON: { form: true },\n};\n\nfunction preferAttr(tagName: string, propName: string) {\n  let tag = ATTR_OVERRIDES[tagName.toUpperCase()];\n  return !!(tag && tag[propName.toLowerCase()]);\n}\n","import type {\n  ClassicResolver,\n  ComponentInstanceWithCreate,\n  Environment,\n  EnvironmentOptions,\n  GlimmerTreeChanges,\n  GlimmerTreeConstruction,\n  ModifierInstance,\n  Nullable,\n  RuntimeArtifacts,\n  RuntimeOptions,\n  Transaction,\n  TransactionSymbol,\n} from '@glimmer/interfaces';\nimport { expect, localAssert } from '@glimmer/debug-util';\nimport { ProgramImpl } from '@glimmer/program';\nimport { track, updateTag } from '@glimmer/validator';\n\nimport DebugRenderTree from './debug-render-tree';\nimport { DOMChangesImpl, DOMTreeConstruction } from './dom/helper';\nimport { isArgumentError } from './vm/arguments';\n\nexport const TRANSACTION: TransactionSymbol = Symbol('TRANSACTION') as TransactionSymbol;\n\nclass TransactionImpl implements Transaction {\n  public scheduledInstallModifiers: ModifierInstance[] = [];\n  public scheduledUpdateModifiers: ModifierInstance[] = [];\n  public createdComponents: ComponentInstanceWithCreate[] = [];\n  public updatedComponents: ComponentInstanceWithCreate[] = [];\n\n  didCreate(component: ComponentInstanceWithCreate) {\n    this.createdComponents.push(component);\n  }\n\n  didUpdate(component: ComponentInstanceWithCreate) {\n    this.updatedComponents.push(component);\n  }\n\n  scheduleInstallModifier(modifier: ModifierInstance) {\n    this.scheduledInstallModifiers.push(modifier);\n  }\n\n  scheduleUpdateModifier(modifier: ModifierInstance) {\n    this.scheduledUpdateModifiers.push(modifier);\n  }\n\n  commit() {\n    let { createdComponents, updatedComponents } = this;\n\n    for (const { manager, state } of createdComponents) {\n      manager.didCreate(state);\n    }\n\n    for (const { manager, state } of updatedComponents) {\n      manager.didUpdate(state);\n    }\n\n    let { scheduledInstallModifiers, scheduledUpdateModifiers } = this;\n\n    for (const { manager, state, definition } of scheduledInstallModifiers) {\n      let modifierTag = manager.getTag(state);\n\n      if (modifierTag !== null) {\n        let tag = track(\n          () => manager.install(state),\n          import.meta.env.DEV &&\n            `- While rendering:\\n  (instance of a \\`${\n              definition.resolvedName || manager.getDebugName(definition.state)\n            }\\` modifier)`\n        );\n        updateTag(modifierTag, tag);\n      } else {\n        manager.install(state);\n      }\n    }\n\n    for (const { manager, state, definition } of scheduledUpdateModifiers) {\n      let modifierTag = manager.getTag(state);\n\n      if (modifierTag !== null) {\n        let tag = track(\n          () => manager.update(state),\n          import.meta.env.DEV &&\n            `- While rendering:\\n  (instance of a \\`${\n              definition.resolvedName || manager.getDebugName(definition.state)\n            }\\` modifier)`\n        );\n        updateTag(modifierTag, tag);\n      } else {\n        manager.update(state);\n      }\n    }\n  }\n}\n\nexport class EnvironmentImpl implements Environment {\n  [TRANSACTION]: Nullable<TransactionImpl> = null;\n\n  declare protected appendOperations: GlimmerTreeConstruction;\n  protected updateOperations?: GlimmerTreeChanges | undefined;\n\n  // Delegate methods and values\n  public isInteractive: boolean;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isArgumentCaptureError: ((error: any) => boolean) | undefined;\n  debugRenderTree: DebugRenderTree<object> | undefined;\n\n  constructor(\n    options: EnvironmentOptions,\n    private delegate: EnvironmentDelegate\n  ) {\n    this.isInteractive = delegate.isInteractive;\n    this.debugRenderTree = this.delegate.enableDebugTooling ? new DebugRenderTree() : undefined;\n    this.isArgumentCaptureError = this.delegate.enableDebugTooling ? isArgumentError : undefined;\n    if (options.appendOperations) {\n      this.appendOperations = options.appendOperations;\n      this.updateOperations = options.updateOperations;\n    } else if (options.document) {\n      this.appendOperations = new DOMTreeConstruction(options.document);\n      this.updateOperations = new DOMChangesImpl(options.document);\n    } else if (import.meta.env.DEV) {\n      throw new Error('you must pass document or appendOperations to a new runtime');\n    }\n  }\n\n  getAppendOperations(): GlimmerTreeConstruction {\n    return this.appendOperations;\n  }\n\n  getDOM(): GlimmerTreeChanges {\n    return expect(\n      this.updateOperations,\n      'Attempted to get DOM updateOperations, but they were not provided by the environment. You may be attempting to rerender in an environment which does not support rerendering, such as SSR.'\n    );\n  }\n\n  begin() {\n    localAssert(\n      !this[TRANSACTION],\n      'A glimmer transaction was begun, but one already exists. You may have a nested transaction, possibly caused by an earlier runtime exception while rendering. Please check your console for the stack trace of any prior exceptions.'\n    );\n\n    this.debugRenderTree?.begin();\n\n    this[TRANSACTION] = new TransactionImpl();\n  }\n\n  private get transaction(): TransactionImpl {\n    return expect(this[TRANSACTION], 'must be in a transaction');\n  }\n\n  didCreate(component: ComponentInstanceWithCreate) {\n    this.transaction.didCreate(component);\n  }\n\n  didUpdate(component: ComponentInstanceWithCreate) {\n    this.transaction.didUpdate(component);\n  }\n\n  scheduleInstallModifier(modifier: ModifierInstance) {\n    if (this.isInteractive) {\n      this.transaction.scheduleInstallModifier(modifier);\n    }\n  }\n\n  scheduleUpdateModifier(modifier: ModifierInstance) {\n    if (this.isInteractive) {\n      this.transaction.scheduleUpdateModifier(modifier);\n    }\n  }\n\n  commit() {\n    let transaction = this.transaction;\n    this[TRANSACTION] = null;\n    transaction.commit();\n\n    this.debugRenderTree?.commit();\n\n    this.delegate.onTransactionCommit();\n  }\n}\n\nexport interface EnvironmentDelegate {\n  /**\n   * Used to determine the the environment is interactive (e.g. SSR is not\n   * interactive). Interactive environments schedule modifiers, among other things.\n   */\n  isInteractive: boolean;\n\n  /**\n   * Used to enable debug tooling\n   */\n  enableDebugTooling: boolean;\n\n  /**\n   * Callback to be called when an environment transaction commits\n   */\n  onTransactionCommit: () => void;\n}\n\nexport function runtimeOptions(\n  options: EnvironmentOptions,\n  delegate: EnvironmentDelegate,\n  artifacts: RuntimeArtifacts,\n  resolver: Nullable<ClassicResolver>\n): RuntimeOptions {\n  return {\n    env: new EnvironmentImpl(options, delegate),\n    program: new ProgramImpl(artifacts.constants, artifacts.heap),\n    resolver,\n  };\n}\n\nexport function inTransaction(env: Environment, block: () => void): void {\n  if (!env[TRANSACTION]) {\n    env.begin();\n    try {\n      block();\n    } finally {\n      env.commit();\n    }\n  } else {\n    block();\n  }\n}\n\nexport default EnvironmentImpl;\n","import type { Helper, HelperDefinitionState } from '@glimmer/interfaces';\nimport { setInternalHelperManager } from '@glimmer/manager';\n\nexport function internalHelper(helper: Helper): HelperDefinitionState {\n  return setInternalHelperManager(helper, {});\n}\n","import type { CapturedArguments } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { createComputeRef } from '@glimmer/reference';\n\nimport { reifyPositional } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\n/**\n   Use the `{{array}}` helper to create an array to pass as an option to your\n   components.\n\n   ```handlebars\n   <MyComponent @people={{array\n     'Tom Dale'\n     'Yehuda Katz'\n     this.myOtherPerson}}\n   />\n   ```\n    or\n   ```handlebars\n   {{my-component people=(array\n     'Tom Dale'\n     'Yehuda Katz'\n     this.myOtherPerson)\n   }}\n   ```\n\n   Would result in an object such as:\n\n   ```js\n   ['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]\n   ```\n\n   Where the 3rd item in the array is bound to updates of the `myOtherPerson` property.\n\n   @method array\n   @param {Array} options\n   @return {Array} Array\n   @public\n */\n\nexport const array = internalHelper(({ positional }: CapturedArguments): Reference<unknown[]> => {\n  return createComputeRef(() => reifyPositional(positional), null, 'array');\n});\n","import type { CapturedArguments } from '@glimmer/interfaces';\nimport { createComputeRef } from '@glimmer/reference';\n\nimport { reifyPositional } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\nconst isEmpty = (value: unknown): boolean => {\n  return value === null || value === undefined || typeof (value as object).toString !== 'function';\n};\n\nconst normalizeTextValue = (value: unknown): string => {\n  if (isEmpty(value)) {\n    return '';\n  }\n  return String(value);\n};\n\n/**\n  Concatenates the given arguments into a string.\n\n  Example:\n\n  ```handlebars\n  {{some-component name=(concat firstName \" \" lastName)}}\n\n  {{! would pass name=\"<first name value> <last name value>\" to the component}}\n  ```\n\n  or for angle bracket invocation, you actually don't need concat at all.\n\n  ```handlebars\n  <SomeComponent @name=\"{{firstName}} {{lastName}}\" />\n  ```\n\n  @public\n  @method concat\n*/\nexport const concat = internalHelper(({ positional }: CapturedArguments) => {\n  return createComputeRef(\n    () => reifyPositional(positional).map(normalizeTextValue).join(''),\n    null,\n    'concat'\n  );\n});\n","import type { AnyFn, CapturedArguments } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { check } from '@glimmer/debug';\nimport { buildUntouchableThis } from '@glimmer/debug-util';\nimport { createComputeRef, isInvokableRef, updateRef, valueForRef } from '@glimmer/reference';\n\nimport { reifyPositional } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\nconst context = buildUntouchableThis('`fn` helper');\n\n/**\n  The `fn` helper allows you to ensure a function that you are passing off\n  to another component, helper, or modifier has access to arguments that are\n  available in the template.\n\n  For example, if you have an `each` helper looping over a number of items, you\n  may need to pass a function that expects to receive the item as an argument\n  to a component invoked within the loop. Here's how you could use the `fn`\n  helper to pass both the function and its arguments together:\n\n    ```app/templates/components/items-listing.hbs\n  {{#each @items as |item|}}\n    <DisplayItem @item=item @select={{fn this.handleSelected item}} />\n  {{/each}}\n  ```\n\n  ```app/components/items-list.js\n  import Component from '@glimmer/component';\n  import { action } from '@ember/object';\n\n  export default class ItemsList extends Component {\n    handleSelected = (item) => {\n      // ...snip...\n    }\n  }\n  ```\n\n  In this case the `display-item` component will receive a normal function\n  that it can invoke. When it invokes the function, the `handleSelected`\n  function will receive the `item` and any arguments passed, thanks to the\n  `fn` helper.\n\n  Let's take look at what that means in a couple circumstances:\n\n  - When invoked as `this.args.select()` the `handleSelected` function will\n    receive the `item` from the loop as its first and only argument.\n  - When invoked as `this.args.select('foo')` the `handleSelected` function\n    will receive the `item` from the loop as its first argument and the\n    string `'foo'` as its second argument.\n\n  In the example above, we used an arrow function to ensure that\n  `handleSelected` is properly bound to the `items-list`, but let's explore what\n  happens if we left out the arrow function:\n\n  ```app/components/items-list.js\n  import Component from '@glimmer/component';\n\n  export default class ItemsList extends Component {\n    handleSelected(item) {\n      // ...snip...\n    }\n  }\n  ```\n\n  In this example, when `handleSelected` is invoked inside the `display-item`\n  component, it will **not** have access to the component instance. In other\n  words, it will have no `this` context, so please make sure your functions\n  are bound (via an arrow function or other means) before passing into `fn`!\n\n  See also [partial application](https://en.wikipedia.org/wiki/Partial_application).\n\n  @method fn\n  @public\n*/\nexport const fn = internalHelper(({ positional }: CapturedArguments) => {\n  let callbackRef = check(positional[0], assertCallbackIsFn);\n\n  return createComputeRef(\n    () => {\n      return (...invocationArgs: unknown[]) => {\n        let [fn, ...args] = reifyPositional(positional);\n\n        if (import.meta.env.DEV) assertCallbackIsFn(callbackRef);\n\n        if (isInvokableRef(callbackRef)) {\n          let value = args.length > 0 ? args[0] : invocationArgs[0];\n          return void updateRef(callbackRef, value);\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- @fixme\n          return (fn as AnyFn).call(context, ...args, ...invocationArgs);\n        }\n      };\n    },\n    null,\n    'fn'\n  );\n});\n\nfunction assertCallbackIsFn(callbackRef: Reference | undefined): asserts callbackRef is Reference {\n  if (\n    !(\n      callbackRef &&\n      (isInvokableRef(callbackRef) || typeof valueForRef(callbackRef) === 'function')\n    )\n  ) {\n    throw new Error(\n      `You must pass a function as the \\`fn\\` helper's first argument, you passed ${\n        callbackRef ? valueForRef(callbackRef) : callbackRef\n      }. While rendering:\\n\\n${callbackRef?.debugLabel}`\n    );\n  }\n}\n","/* eslint-disable @typescript-eslint/no-empty-object-type */\nexport default function buildUntouchableThis(source: string): null | object {\n  let context: null | object = null;\n  if (import.meta.env.DEV) {\n    let assertOnProperty = (property: string | number | symbol) => {\n      let access =\n        typeof property === 'symbol' || typeof property === 'number'\n          ? `[${String(property)}]`\n          : `.${property}`;\n\n      throw new Error(\n        `You accessed \\`this${access}\\` from a function passed to the ${source}, but the function itself was not bound to a valid \\`this\\` context. Consider updating to use a bound function (for instance, use an arrow function, \\`() => {}\\`).`\n      );\n    };\n\n    context = new Proxy(\n      {},\n      {\n        get(_target: {}, property: string | symbol) {\n          assertOnProperty(property);\n        },\n\n        set(_target: {}, property: string | symbol) {\n          assertOnProperty(property);\n\n          return false;\n        },\n\n        has(_target: {}, property: string | symbol) {\n          assertOnProperty(property);\n\n          return false;\n        },\n      }\n    );\n  }\n\n  return context;\n}\n","import type { CapturedArguments } from '@glimmer/interfaces';\nimport { getPath, setPath } from '@glimmer/global-context';\nimport { createComputeRef, UNDEFINED_REFERENCE, valueForRef } from '@glimmer/reference';\nimport { isDict } from '@glimmer/util';\n\nimport { internalHelper } from './internal-helper';\n\n/**\n  Dynamically look up a property on an object. The second argument to `{{get}}`\n  should have a string value, although it can be bound.\n\n  For example, these two usages are equivalent:\n\n  ```app/components/developer-detail.js\n  import Component from '@glimmer/component';\n  import { tracked } from '@glimmer/tracking';\n\n  export default class extends Component {\n    @tracked developer = {\n      name: \"Sandi Metz\",\n      language: \"Ruby\"\n    }\n  }\n  ```\n\n  ```handlebars\n  {{this.developer.name}}\n  {{get this.developer \"name\"}}\n  ```\n\n  If there were several facts about a person, the `{{get}}` helper can dynamically\n  pick one:\n\n  ```app/templates/application.hbs\n  <DeveloperDetail @factName=\"language\" />\n  ```\n\n  ```handlebars\n  {{get this.developer @factName}}\n  ```\n\n  For a more complex example, this template would allow the user to switch\n  between showing the user's height and weight with a click:\n\n  ```app/components/developer-detail.js\n  import Component from '@glimmer/component';\n  import { tracked } from '@glimmer/tracking';\n\n  export default class extends Component {\n    @tracked developer = {\n      name: \"Sandi Metz\",\n      language: \"Ruby\"\n    }\n\n    @tracked currentFact = 'name'\n\n    showFact = (fact) => {\n      this.currentFact = fact;\n    }\n  }\n  ```\n\n  ```app/components/developer-detail.js\n  {{get this.developer this.currentFact}}\n\n  <button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n  <button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n  ```\n\n  The `{{get}}` helper can also respect mutable values itself. For example:\n\n  ```app/components/developer-detail.js\n  <Input @value={{mut (get this.person this.currentFact)}} />\n\n  <button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n  <button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n  ```\n\n  Would allow the user to swap what fact is being displayed, and also edit\n  that fact via a two-way mutable binding.\n\n  @public\n  @method get\n */\nexport const get = internalHelper(({ positional }: CapturedArguments) => {\n  let sourceRef = positional[0] ?? UNDEFINED_REFERENCE;\n  let pathRef = positional[1] ?? UNDEFINED_REFERENCE;\n\n  return createComputeRef(\n    () => {\n      let source = valueForRef(sourceRef);\n\n      if (isDict(source)) {\n        return getPath(source, String(valueForRef(pathRef)));\n      }\n    },\n    (value) => {\n      let source = valueForRef(sourceRef);\n\n      if (isDict(source)) {\n        return setPath(source, String(valueForRef(pathRef)), value);\n      }\n    },\n    'get'\n  );\n});\n","import type { CapturedArguments, Dict } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { createComputeRef } from '@glimmer/reference';\n\nimport { reifyNamed } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\n/**\n   Use the `{{hash}}` helper to create a hash to pass as an option to your\n   components. This is specially useful for contextual components where you can\n   just yield a hash:\n\n   ```handlebars\n   {{yield (hash\n      name='Sarah'\n      title=office\n   )}}\n   ```\n\n   Would result in an object such as:\n\n   ```js\n   { name: 'Sarah', title: this.get('office') }\n   ```\n\n   Where the `title` is bound to updates of the `office` property.\n\n   Note that the hash is an empty object with no prototype chain, therefore\n   common methods like `toString` are not available in the resulting hash.\n   If you need to use such a method, you can use the `call` or `apply`\n   approach:\n\n   ```js\n   function toString(obj) {\n     return Object.prototype.toString.apply(obj);\n   }\n   ```\n\n   @method hash\n   @param {Object} options\n   @return {Object} Hash\n   @public\n */\nexport const hash = internalHelper(({ named }: CapturedArguments): Reference<Dict> => {\n  let ref = createComputeRef(\n    () => {\n      return reifyNamed(named);\n    },\n    null,\n    'hash'\n  );\n\n  // Setup the children so that templates can bypass getting the value of\n  // the reference and treat children lazily\n  let children = new Map();\n\n  for (let name in named) {\n    children.set(name, named[name]);\n  }\n\n  ref.children = children;\n\n  return ref;\n});\n","import type { Arguments, InternalHelperManager } from '@glimmer/interfaces';\nimport type { Cache } from '@glimmer/validator';\nimport { associateDestroyableChild, isDestroyed, isDestroying } from '@glimmer/destroyable';\nimport { getInternalHelperManager, hasDestroyable, hasValue } from '@glimmer/manager';\nimport { getOwner } from '@glimmer/owner';\nimport { createCache, getValue } from '@glimmer/validator';\n\nimport { EMPTY_ARGS, EMPTY_NAMED, EMPTY_POSITIONAL } from '../vm/arguments';\n\nlet ARGS_CACHES = import.meta.env.DEV\n  ? new WeakMap<SimpleArgsProxy, Cache<Partial<Arguments>>>()\n  : undefined;\n\nfunction getArgs(proxy: SimpleArgsProxy): Partial<Arguments> {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return getValue(import.meta.env.DEV ? ARGS_CACHES!.get(proxy)! : proxy.argsCache!)!;\n}\n\nclass SimpleArgsProxy {\n  argsCache?: Cache<Partial<Arguments>>;\n\n  constructor(\n    context: object,\n    computeArgs: (context: object) => Partial<Arguments> = () => EMPTY_ARGS\n  ) {\n    let argsCache = createCache(() => computeArgs(context));\n\n    if (import.meta.env.DEV) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      ARGS_CACHES!.set(this, argsCache);\n      Object.freeze(this);\n    } else {\n      this.argsCache = argsCache;\n    }\n  }\n\n  get named() {\n    return getArgs(this).named || EMPTY_NAMED;\n  }\n\n  get positional() {\n    return getArgs(this).positional || EMPTY_POSITIONAL;\n  }\n}\n\n////////////\n\nexport function invokeHelper(\n  context: object,\n  definition: object,\n  computeArgs?: (context: object) => Partial<Arguments>\n): Cache {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS usage\n  if (import.meta.env.DEV && (typeof context !== 'object' || context === null)) {\n    throw new Error(\n      `Expected a context object to be passed as the first parameter to invokeHelper, got ${context}`\n    );\n  }\n\n  const owner = getOwner(context);\n\n  const internalManager = getInternalHelperManager(definition);\n\n  if (import.meta.env.DEV && typeof internalManager === 'function') {\n    throw new Error(\n      'Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.'\n    );\n  }\n\n  const manager = (internalManager as InternalHelperManager<object>).getDelegateFor(owner);\n  let args = new SimpleArgsProxy(context, computeArgs);\n  let bucket = manager.createHelper(definition, args);\n\n  let cache: Cache;\n\n  if (hasValue(manager)) {\n    cache = createCache(() => {\n      if (import.meta.env.DEV && (isDestroying(cache) || isDestroyed(cache))) {\n        throw new Error(\n          `You attempted to get the value of a helper after the helper was destroyed, which is not allowed`\n        );\n      }\n\n      return manager.getValue(bucket);\n    });\n\n    associateDestroyableChild(context, cache);\n  } else {\n    throw new Error('TODO: unreachable, to be implemented with hasScheduledEffect');\n  }\n\n  if (hasDestroyable(manager)) {\n    let destroyable = manager.getDestroyable(bucket);\n\n    associateDestroyableChild(cache, destroyable);\n  }\n\n  return cache;\n}\n","import type {\n  CapturedArguments,\n  InternalModifierManager,\n  Owner,\n  SimpleElement,\n  UpdatableTag,\n} from '@glimmer/interfaces';\nimport {\n  check,\n  CheckBoolean,\n  CheckFunction,\n  CheckOr,\n  CheckString,\n  CheckUndefined,\n} from '@glimmer/debug';\nimport { buildUntouchableThis, localAssert } from '@glimmer/debug-util';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { setInternalModifierManager } from '@glimmer/manager';\nimport { valueForRef } from '@glimmer/reference';\nimport { createUpdatableTag } from '@glimmer/validator';\n\nimport { reifyNamed } from '../vm/arguments';\n\nconst untouchableContext = buildUntouchableThis('`on` modifier');\n\ninterface Listener {\n  eventName: string;\n  callback: EventListener;\n  userProvidedCallback: EventListener;\n  once: boolean | undefined;\n  passive: boolean | undefined;\n  capture: boolean | undefined;\n  options: AddEventListenerOptions | undefined;\n}\n\nexport class OnModifierState {\n  public tag = createUpdatableTag();\n  public element: Element;\n  public args: CapturedArguments;\n  public listener: Listener | null = null;\n\n  constructor(element: Element, args: CapturedArguments) {\n    this.element = element;\n    this.args = args;\n\n    registerDestructor(this, () => {\n      let { element, listener } = this;\n      if (listener) {\n        let { eventName, callback, options } = listener;\n        removeEventListener(element, eventName, callback, options);\n      }\n    });\n  }\n\n  // Update this.listener if needed\n  updateListener(): void {\n    let { element, args, listener } = this;\n\n    localAssert(\n      args.positional[0],\n      'You must pass a valid DOM event name as the first argument to the `on` modifier'\n    );\n\n    let eventName = check(\n      valueForRef(args.positional[0]),\n      CheckString,\n      () => 'You must pass a valid DOM event name as the first argument to the `on` modifier'\n    );\n\n    localAssert(\n      args.positional[1],\n      'You must pass a function as the second argument to the `on` modifier'\n    );\n\n    let userProvidedCallback = check(valueForRef(args.positional[1]), CheckFunction, (actual) => {\n      return `You must pass a function as the second argument to the \\`on\\` modifier; you passed ${\n        actual === null ? 'null' : typeof actual\n      }. While rendering:\\n\\n${args.positional[1]?.debugLabel ?? `{unlabeled value}`}`;\n    }) as EventListener;\n\n    if (import.meta.env.DEV && args.positional.length !== 2) {\n      throw new Error(\n        `You can only pass two positional arguments (event name and callback) to the \\`on\\` modifier, but you provided ${args.positional.length}. Consider using the \\`fn\\` helper to provide additional arguments to the \\`on\\` callback.`\n      );\n    }\n\n    let once: boolean | undefined = undefined;\n    let passive: boolean | undefined = undefined;\n    let capture: boolean | undefined = undefined;\n\n    if (import.meta.env.DEV) {\n      let { once: _once, passive: _passive, capture: _capture, ...extra } = reifyNamed(args.named);\n\n      once = check(_once, CheckOr(CheckBoolean, CheckUndefined), (actual) => {\n        return `You must pass a boolean or undefined as the \\`once\\` argument to the \\`on\\` modifier; you passed ${actual}. While rendering:\\n\\n${\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          args.named['once']!.debugLabel ?? `{unlabeled value}`\n        }`;\n      });\n\n      passive = check(_passive, CheckOr(CheckBoolean, CheckUndefined), (actual) => {\n        return `You must pass a boolean or undefined as the \\`passive\\` argument to the \\`on\\` modifier; you passed ${actual}. While rendering:\\n\\n${\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          args.named['passive']!.debugLabel ?? `{unlabeled value}`\n        }`;\n      });\n\n      capture = check(_capture, CheckOr(CheckBoolean, CheckUndefined), (actual) => {\n        return `You must pass a boolean or undefined as the \\`capture\\` argument to the \\`on\\` modifier; you passed ${actual}. While rendering:\\n\\n${\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          args.named['capture']!.debugLabel ?? `{unlabeled value}`\n        }`;\n      });\n\n      if (Object.keys(extra).length > 0) {\n        throw new Error(\n          `You can only \\`once\\`, \\`passive\\` or \\`capture\\` named arguments to the \\`on\\` modifier, but you provided ${Object.keys(\n            extra\n          ).join(', ')}.`\n        );\n      }\n    } else {\n      let { once: _once, passive: _passive, capture: _capture } = args.named;\n\n      if (_once) {\n        once = valueForRef(_once) as boolean | undefined;\n      }\n\n      if (_passive) {\n        passive = valueForRef(_passive) as boolean | undefined;\n      }\n\n      if (_capture) {\n        capture = valueForRef(_capture) as boolean | undefined;\n      }\n    }\n\n    let shouldUpdate = false;\n\n    if (listener === null) {\n      shouldUpdate = true;\n    } else {\n      shouldUpdate =\n        eventName !== listener.eventName ||\n        userProvidedCallback !== listener.userProvidedCallback ||\n        once !== listener.once ||\n        passive !== listener.passive ||\n        capture !== listener.capture;\n    }\n\n    let options: AddEventListenerOptions | undefined = undefined;\n\n    // we want to handle both `true` and `false` because both have a meaning:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=770208\n    if (shouldUpdate) {\n      if (once !== undefined || passive !== undefined || capture !== undefined) {\n        options = { once, passive, capture } as AddEventListenerOptions;\n      }\n    }\n\n    if (shouldUpdate) {\n      let callback = userProvidedCallback;\n\n      if (import.meta.env.DEV) {\n        callback = userProvidedCallback.bind(untouchableContext);\n\n        if (passive) {\n          let _callback = callback;\n\n          callback = (event) => {\n            event.preventDefault = () => {\n              throw new Error(\n                `You marked this listener as 'passive', meaning that you must not call 'event.preventDefault()': \\n\\n${\n                  userProvidedCallback.name || `{anonymous function}`\n                }`\n              );\n            };\n\n            return _callback(event);\n          };\n        }\n      }\n\n      this.listener = {\n        eventName,\n        callback,\n        userProvidedCallback,\n        once,\n        passive,\n        capture,\n        options,\n      };\n\n      if (listener) {\n        removeEventListener(element, listener.eventName, listener.callback, listener.options);\n      }\n\n      addEventListener(element, eventName, callback, options);\n    }\n  }\n}\n\nlet adds = 0;\nlet removes = 0;\n\nfunction removeEventListener(\n  element: Element,\n  eventName: string,\n  callback: EventListener,\n  options?: AddEventListenerOptions\n): void {\n  removes++;\n\n  element.removeEventListener(eventName, callback, options);\n}\n\nfunction addEventListener(\n  element: Element,\n  eventName: string,\n  callback: EventListener,\n  options?: AddEventListenerOptions\n): void {\n  adds++;\n  element.addEventListener(eventName, callback, options);\n}\n\n/**\n  The `{{on}}` modifier lets you easily add event listeners (it uses\n  [EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)\n  internally).\n\n  For example, if you'd like to run a function on your component when a `<button>`\n  in the components template is clicked you might do something like:\n\n  ```app/components/like-post.hbs\n  <button {{on 'click' this.saveLike}}>Like this post!</button>\n  ```\n\n  ```app/components/like-post.js\n  import Component from '@glimmer/component';\n  import { action } from '@ember/object';\n\n  export default class LikePostComponent extends Component {\n    saveLike = () => {\n      // someone likes your post!\n      // better send a request off to your server...\n    }\n  }\n  ```\n\n  ### Arguments\n\n  `{{on}}` accepts two positional arguments, and a few named arguments.\n\n  The positional arguments are:\n\n  - `event` -- the name to use when calling `addEventListener`\n  - `callback` -- the function to be passed to `addEventListener`\n\n  The named arguments are:\n\n  - capture -- a `true` value indicates that events of this type will be dispatched\n    to the registered listener before being dispatched to any EventTarget beneath it\n    in the DOM tree.\n  - once -- indicates that the listener should be invoked at most once after being\n    added. If true, the listener would be automatically removed when invoked.\n  - passive -- if `true`, indicates that the function specified by listener will never\n    call preventDefault(). If a passive listener does call preventDefault(), the user\n    agent will do nothing other than generate a console warning. See\n    [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)\n    to learn more.\n\n  The callback function passed to `{{on}}` will receive any arguments that are passed\n  to the event handler. Most commonly this would be the `event` itself.\n\n  If you would like to pass additional arguments to the function you should use\n  the `{{fn}}` helper.\n\n  For example, in our example case above if you'd like to pass in the post that\n  was being liked when the button is clicked you could do something like:\n\n  ```app/components/like-post.hbs\n  <button {{on 'click' (fn this.saveLike @post)}}>Like this post!</button>\n  ```\n\n  In this case, the `saveLike` function will receive two arguments: the click event\n  and the value of `@post`.\n\n  ### Function Context\n\n  In the example above, we used an arrow function to ensure that `likePost` is\n  properly bound to the `items-list`, but let's explore what happens if we\n  left out the arrow function:\n\n  ```app/components/like-post.js\n  import Component from '@glimmer/component';\n\n  export default class LikePostComponent extends Component {\n    saveLike() {\n      // ...snip...\n    }\n  }\n  ```\n\n  In this example, when the button is clicked `saveLike` will be invoked,\n  it will **not** have access to the component instance. In other\n  words, it will have no `this` context, so please make sure your functions\n  are bound (via an arrow function or other means) before passing into `on`!\n\n  @method on\n  @public\n*/\nclass OnModifierManager implements InternalModifierManager<OnModifierState> {\n  getDebugName(): string {\n    return 'on';\n  }\n\n  getDebugInstance(): unknown {\n    return null;\n  }\n\n  get counters(): { adds: number; removes: number } {\n    return { adds, removes };\n  }\n\n  create(\n    _owner: Owner,\n    element: SimpleElement | Element,\n    _state: object,\n    args: CapturedArguments\n  ): OnModifierState {\n    return new OnModifierState(element as Element, args);\n  }\n\n  getTag({ tag }: OnModifierState): UpdatableTag {\n    return tag;\n  }\n\n  install(state: OnModifierState): void {\n    state.updateListener();\n  }\n\n  update(state: OnModifierState): void {\n    state.updateListener();\n  }\n\n  getDestroyable(state: OnModifierState): OnModifierState {\n    return state;\n  }\n}\n\nexport const on = setInternalModifierManager(new OnModifierManager(), {});\n","import type { EvaluationContext, Nullable, RuntimeOp } from '@glimmer/interfaces';\nimport type { MachineRegister } from '@glimmer/vm';\nimport {\n  VM_INVOKE_STATIC_OP,\n  VM_INVOKE_VIRTUAL_OP,\n  VM_JUMP_OP,\n  VM_POP_FRAME_OP,\n  VM_PUSH_FRAME_OP,\n  VM_RETURN_OP,\n  VM_RETURN_TO_OP,\n} from '@glimmer/constants';\nimport { localAssert } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { $fp, $pc, $ra, $sp } from '@glimmer/vm';\n\nimport type { DebugState } from '../opcodes';\nimport type { VM } from './append';\n\nimport { APPEND_OPCODES } from '../opcodes';\n\nexport type LowLevelRegisters = [$pc: number, $ra: number, $sp: number, $fp: number];\n\nexport function initializeRegisters(): LowLevelRegisters {\n  return [0, -1, 0, 0];\n}\n\nexport function restoreRegisters(pc: number, sp: number): LowLevelRegisters {\n  return [pc, -1, sp, 0];\n}\n\nexport function initializeRegistersWithSP(sp: number): LowLevelRegisters {\n  return [0, -1, sp, 0];\n}\n\nexport function initializeRegistersWithPC(pc: number): LowLevelRegisters {\n  return [pc, -1, 0, 0];\n}\n\nexport interface VmStack {\n  readonly registers: LowLevelRegisters;\n\n  push(value: unknown): void;\n  get(position: number): number;\n  pop<T>(): T;\n\n  snapshot?(): unknown[];\n}\n\nexport interface Externs {\n  debugBefore: (opcode: RuntimeOp) => DebugState;\n  debugAfter: (state: DebugState) => void;\n}\n\nexport class LowLevelVM {\n  public currentOpSize = 0;\n  readonly registers: LowLevelRegisters;\n  readonly context: EvaluationContext;\n\n  constructor(\n    public stack: VmStack,\n    context: EvaluationContext,\n    public externs: Externs | undefined,\n    registers: LowLevelRegisters\n  ) {\n    this.context = context;\n    this.registers = registers;\n  }\n\n  fetchRegister(register: MachineRegister): number {\n    return this.registers[register];\n  }\n\n  loadRegister(register: MachineRegister, value: number) {\n    this.registers[register] = value;\n  }\n\n  setPc(pc: number): void {\n    localAssert(typeof pc === 'number' && !isNaN(pc), 'pc is set to a number');\n    this.registers[$pc] = pc;\n  }\n\n  // Start a new frame and save $ra and $fp on the stack\n  pushFrame() {\n    this.stack.push(this.registers[$ra]);\n    this.stack.push(this.registers[$fp]);\n    this.registers[$fp] = this.registers[$sp] - 1;\n  }\n\n  // Restore $ra, $sp and $fp\n  popFrame() {\n    this.registers[$sp] = this.registers[$fp] - 1;\n    this.registers[$ra] = this.stack.get(0);\n    this.registers[$fp] = this.stack.get(1);\n  }\n\n  pushSmallFrame() {\n    this.stack.push(this.registers[$ra]);\n  }\n\n  popSmallFrame() {\n    this.registers[$ra] = this.stack.pop();\n  }\n\n  // Jump to an address in `program`\n  goto(offset: number) {\n    this.setPc(this.target(offset));\n  }\n\n  target(offset: number) {\n    return this.registers[$pc] + offset - this.currentOpSize;\n  }\n\n  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n  call(handle: number) {\n    localAssert(handle < 0xffffffff, `Jumping to placeholder address`);\n\n    this.registers[$ra] = this.registers[$pc];\n    this.setPc(this.context.program.heap.getaddr(handle));\n  }\n\n  // Put a specific `program` address in $ra\n  returnTo(offset: number) {\n    this.registers[$ra] = this.target(offset);\n  }\n\n  // Return to the `program` address stored in $ra\n  return() {\n    this.setPc(this.registers[$ra]);\n  }\n\n  nextStatement(): Nullable<RuntimeOp> {\n    let { registers, context } = this;\n\n    let pc = registers[$pc];\n\n    localAssert(typeof pc === 'number', 'pc is a number');\n\n    if (pc === -1) {\n      return null;\n    }\n\n    // We have to save off the current operations size so that\n    // when we do a jump we can calculate the correct offset\n    // to where we are going. We can't simply ask for the size\n    // in a jump because we have have already incremented the\n    // program counter to the next instruction prior to executing.\n    let opcode = context.program.opcode(pc);\n    let operationSize = (this.currentOpSize = opcode.size);\n    this.registers[$pc] += operationSize;\n\n    return opcode;\n  }\n\n  evaluateOuter(opcode: RuntimeOp, vm: VM) {\n    if (LOCAL_DEBUG && this.externs) {\n      let {\n        externs: { debugBefore, debugAfter },\n      } = this;\n      let state = debugBefore(opcode);\n      this.evaluateInner(opcode, vm);\n      debugAfter(state);\n    } else {\n      this.evaluateInner(opcode, vm);\n    }\n  }\n\n  evaluateInner(opcode: RuntimeOp, vm: VM) {\n    if (opcode.isMachine) {\n      this.evaluateMachine(opcode, vm);\n    } else {\n      this.evaluateSyscall(opcode, vm);\n    }\n  }\n\n  evaluateMachine(opcode: RuntimeOp, vm: VM) {\n    switch (opcode.type) {\n      case VM_PUSH_FRAME_OP:\n        return void this.pushFrame();\n      case VM_POP_FRAME_OP:\n        return void this.popFrame();\n      case VM_INVOKE_STATIC_OP:\n        return void this.call(opcode.op1);\n      case VM_INVOKE_VIRTUAL_OP:\n        return void vm.call(this.stack.pop());\n      case VM_JUMP_OP:\n        return void this.goto(opcode.op1);\n      case VM_RETURN_OP:\n        return void vm.return();\n      case VM_RETURN_TO_OP:\n        return void this.returnTo(opcode.op1);\n    }\n  }\n\n  evaluateSyscall(opcode: RuntimeOp, vm: VM) {\n    APPEND_OPCODES.evaluate(vm, opcode, opcode.type);\n  }\n}\n","import type {\n  VmMachineInvokeStatic,\n  VmMachineInvokeVirtual,\n  VmMachineJump,\n  VmMachineOp,\n  VmMachinePopFrame,\n  VmMachinePushFrame,\n  VmMachineReturn,\n  VmMachineReturnTo,\n  VmMachineSize,\n} from '@glimmer/interfaces';\n\nexport const VM_PUSH_FRAME_OP = 0 satisfies VmMachinePushFrame;\nexport const VM_POP_FRAME_OP = 1 satisfies VmMachinePopFrame;\nexport const VM_INVOKE_VIRTUAL_OP = 2 satisfies VmMachineInvokeVirtual;\nexport const VM_INVOKE_STATIC_OP = 3 satisfies VmMachineInvokeStatic;\nexport const VM_JUMP_OP = 4 satisfies VmMachineJump;\nexport const VM_RETURN_OP = 5 satisfies VmMachineReturn;\nexport const VM_RETURN_TO_OP = 6 satisfies VmMachineReturnTo;\nexport const VM_MACHINE_SIZE = 7 satisfies VmMachineSize;\n\nexport function isMachineOp(value: number): value is VmMachineOp {\n  return value >= 0 && value <= 15;\n}\n","import type { Nullable, SimpleElement } from '@glimmer/interfaces';\n\nimport { isSafeString, normalizeStringValue } from '../dom/normalize';\n\nconst badProtocols = ['javascript:', 'vbscript:'];\n\nconst badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];\n\nconst badTagsForDataURI = ['EMBED'];\n\nconst badAttributes = ['href', 'src', 'background', 'action'];\n\nconst badAttributesForDataURI = ['src'];\n\nfunction has(array: Array<string>, item: string): boolean {\n  return array.indexOf(item) !== -1;\n}\n\nfunction checkURI(tagName: Nullable<string>, attribute: string): boolean {\n  return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);\n}\n\nfunction checkDataURI(tagName: Nullable<string>, attribute: string): boolean {\n  if (tagName === null) return false;\n  return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);\n}\n\nexport function requiresSanitization(tagName: string, attribute: string): boolean {\n  return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);\n}\n\ninterface NodeUrlParseResult {\n  protocol: string | null;\n}\n\ninterface NodeUrlModule {\n  parse(url: string): NodeUrlParseResult;\n}\n\ntype WeirdUrl = { parse: (typeof URL)['parse'] } | typeof URL | undefined | null;\n\nfunction findProtocolForURL() {\n  const weirdURL = URL as WeirdUrl;\n\n  if (\n    typeof weirdURL === 'object' &&\n    weirdURL !== null &&\n    // this is super annoying, TS thinks that URL **must** be a function so `URL.parse` check\n    // thinks it is `never` without this `as unknown as any`\n\n    typeof weirdURL.parse === 'function'\n  ) {\n    // In Ember-land the `fastboot` package sets the `URL` global to `require('url')`\n    // ultimately, this should be changed (so that we can either rely on the natural `URL` global\n    // that exists) but for now we have to detect the specific `FastBoot` case first\n    //\n    // a future version of `fastboot` will detect if this legacy URL setup is required (by\n    // inspecting Ember version) and if new enough, it will avoid shadowing the `URL` global\n    // constructor with `require('url')`.\n    let nodeURL = weirdURL as NodeUrlModule;\n\n    return (url: string) => {\n      let protocol = null;\n\n      if (typeof url === 'string') {\n        protocol = nodeURL.parse(url).protocol;\n      }\n\n      return protocol === null ? ':' : protocol;\n    };\n  } else if (typeof weirdURL === 'function') {\n    return (_url: string) => {\n      try {\n        let url = new weirdURL(_url);\n\n        return url.protocol;\n      } catch {\n        // any non-fully qualified url string will trigger an error (because there is no\n        // baseURI that we can provide; in that case we **know** that the protocol is\n        // \"safe\" because it isn't specifically one of the `badProtocols` listed above\n        // (and those protocols can never be the default baseURI)\n        return ':';\n      }\n    };\n  } else {\n    throw new Error(`@glimmer/runtime needs a valid \"globalThis.URL\"`);\n  }\n}\n\nlet _protocolForUrlImplementation: typeof protocolForUrl | undefined;\nfunction protocolForUrl(url: string): string {\n  if (!_protocolForUrlImplementation) {\n    _protocolForUrlImplementation = findProtocolForURL();\n  }\n  return _protocolForUrlImplementation(url);\n}\n\nexport function sanitizeAttributeValue(\n  element: SimpleElement,\n  attribute: string,\n  value: unknown\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (isSafeString(value)) {\n    return value.toHTML();\n  }\n\n  const tagName = element.tagName.toUpperCase();\n\n  let str = normalizeStringValue(value);\n\n  if (checkURI(tagName, attribute)) {\n    let protocol = protocolForUrl(str);\n    if (has(badProtocols, protocol)) {\n      return `unsafe:${str}`;\n    }\n  }\n\n  if (checkDataURI(tagName, attribute)) {\n    return `unsafe:${str}`;\n  }\n\n  return str;\n}\n","import type {\n  AttributeCursor,\n  AttributeOperation,\n  AttrNamespace,\n  Dict,\n  Environment,\n  Nullable,\n  SimpleElement,\n  TreeBuilder,\n} from '@glimmer/interfaces';\nimport { NS_SVG } from '@glimmer/constants';\nimport { castToBrowser } from '@glimmer/debug-util';\nimport { warnIfStyleNotTrusted } from '@glimmer/global-context';\n\nimport type { MutableKey } from '../element-builder';\n\nimport { normalizeStringValue } from '../../dom/normalize';\nimport { normalizeProperty } from '../../dom/props';\nimport { requiresSanitization, sanitizeAttributeValue } from '../../dom/sanitized-values';\n\nexport function dynamicAttribute(\n  element: SimpleElement,\n  attr: string,\n  namespace: Nullable<AttrNamespace>,\n  isTrusting = false\n): DynamicAttribute {\n  const { tagName, namespaceURI } = element;\n  const attribute = { element, name: attr, namespace };\n\n  if (import.meta.env.DEV && attr === 'style' && !isTrusting) {\n    return new DebugStyleAttributeManager(attribute);\n  }\n\n  if (namespaceURI === NS_SVG) {\n    return buildDynamicAttribute(tagName, attr, attribute);\n  }\n\n  const { type, normalized } = normalizeProperty(element, attr);\n\n  if (type === 'attr') {\n    return buildDynamicAttribute(tagName, normalized, attribute);\n  } else {\n    return buildDynamicProperty(tagName, normalized, attribute);\n  }\n}\n\nfunction buildDynamicAttribute(\n  tagName: string,\n  name: string,\n  attribute: AttributeCursor\n): DynamicAttribute {\n  if (requiresSanitization(tagName, name)) {\n    return new SafeDynamicAttribute(attribute);\n  } else {\n    return new SimpleDynamicAttribute(attribute);\n  }\n}\n\nfunction buildDynamicProperty(\n  tagName: string,\n  name: string,\n  attribute: AttributeCursor\n): DynamicAttribute {\n  if (requiresSanitization(tagName, name)) {\n    return new SafeDynamicProperty(name, attribute);\n  }\n\n  if (isUserInputValue(tagName, name)) {\n    return new InputValueDynamicAttribute(name, attribute);\n  }\n\n  if (isOptionSelected(tagName, name)) {\n    return new OptionSelectedDynamicAttribute(name, attribute);\n  }\n\n  return new DefaultDynamicProperty(name, attribute);\n}\n\nexport abstract class DynamicAttribute implements AttributeOperation {\n  constructor(public attribute: AttributeCursor) {}\n\n  abstract set(dom: TreeBuilder, value: unknown, env: Environment): void;\n  abstract update(value: unknown, env: Environment): void;\n}\n\nexport class SimpleDynamicAttribute extends DynamicAttribute {\n  set(dom: TreeBuilder, value: unknown, _env: Environment): void {\n    const normalizedValue = normalizeValue(value);\n\n    if (normalizedValue !== null) {\n      const { name, namespace } = this.attribute;\n      dom.__setAttribute(name, normalizedValue, namespace);\n    }\n  }\n\n  update(value: unknown, _env: Environment): void {\n    const normalizedValue = normalizeValue(value);\n    const { element, name } = this.attribute;\n\n    if (normalizedValue === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, normalizedValue);\n    }\n  }\n}\n\nexport class DefaultDynamicProperty extends DynamicAttribute {\n  constructor(\n    private normalizedName: string,\n    attribute: AttributeCursor\n  ) {\n    super(attribute);\n  }\n\n  value: unknown;\n  set(dom: TreeBuilder, value: unknown, _env: Environment): void {\n    if (value !== null && value !== undefined) {\n      this.value = value;\n      dom.__setProperty(this.normalizedName, value);\n    }\n  }\n\n  update(value: unknown, _env: Environment): void {\n    const { element } = this.attribute;\n\n    if (this.value !== value) {\n      (element as unknown as Element)[this.normalizedName as MutableKey<Element>] = this.value =\n        value as never;\n\n      if (value === null || value === undefined) {\n        this.removeAttribute();\n      }\n    }\n  }\n\n  protected removeAttribute() {\n    // TODO this sucks but to preserve properties first and to meet current\n    // semantics we must do this.\n    const { element, namespace } = this.attribute;\n\n    if (namespace) {\n      element.removeAttributeNS(namespace, this.normalizedName);\n    } else {\n      element.removeAttribute(this.normalizedName);\n    }\n  }\n}\n\nexport class SafeDynamicProperty extends DefaultDynamicProperty {\n  override set(dom: TreeBuilder, value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.set(dom, sanitized, env);\n  }\n\n  override update(value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.update(sanitized, env);\n  }\n}\n\nexport class SafeDynamicAttribute extends SimpleDynamicAttribute {\n  override set(dom: TreeBuilder, value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.set(dom, sanitized, env);\n  }\n\n  override update(value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.update(sanitized, env);\n  }\n}\n\nexport class InputValueDynamicAttribute extends DefaultDynamicProperty {\n  override set(dom: TreeBuilder, value: unknown) {\n    dom.__setProperty('value', normalizeStringValue(value));\n  }\n\n  override update(value: unknown) {\n    const input = castToBrowser(this.attribute.element, ['input', 'textarea']);\n    const currentValue = input.value;\n    const normalizedValue = normalizeStringValue(value);\n    if (currentValue !== normalizedValue) {\n      input.value = normalizedValue;\n    }\n  }\n}\n\nexport class OptionSelectedDynamicAttribute extends DefaultDynamicProperty {\n  override set(dom: TreeBuilder, value: unknown): void {\n    if (value !== null && value !== undefined && value !== false) {\n      dom.__setProperty('selected', true);\n    }\n  }\n\n  override update(value: unknown): void {\n    const option = castToBrowser(this.attribute.element, 'option');\n\n    if (value) {\n      option.selected = true;\n    } else {\n      option.selected = false;\n    }\n  }\n}\n\nfunction isOptionSelected(tagName: string, attribute: string) {\n  return tagName === 'OPTION' && attribute === 'selected';\n}\n\nfunction isUserInputValue(tagName: string, attribute: string) {\n  return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';\n}\n\nfunction normalizeValue(value: unknown): Nullable<string> {\n  if (\n    value === false ||\n    value === undefined ||\n    value === null ||\n    typeof (value as Dict).toString === 'undefined'\n  ) {\n    return null;\n  }\n  if (value === true) {\n    return '';\n  }\n  // onclick function etc in SSR\n  if (typeof value === 'function') {\n    return null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n  return String(value);\n}\n\nlet DebugStyleAttributeManager: {\n  new (attribute: AttributeCursor): AttributeOperation;\n};\n\nif (import.meta.env.DEV) {\n  DebugStyleAttributeManager = class extends SimpleDynamicAttribute {\n    override set(dom: TreeBuilder, value: unknown, env: Environment): void {\n      warnIfStyleNotTrusted(value);\n\n      super.set(dom, value, env);\n    }\n    override update(value: unknown, env: Environment): void {\n      warnIfStyleNotTrusted(value);\n\n      super.update(value, env);\n    }\n  };\n}\n","import type {\n  AppendingBlock,\n  AttrNamespace,\n  Bounds,\n  Cursor,\n  ElementOperations,\n  Environment,\n  GlimmerTreeChanges,\n  GlimmerTreeConstruction,\n  Maybe,\n  ModifierInstance,\n  Nullable,\n  ResettableBlock,\n  SimpleComment,\n  SimpleDocumentFragment,\n  SimpleElement,\n  SimpleNode,\n  SimpleText,\n  TreeBuilder,\n} from '@glimmer/interfaces';\nimport { expect, localAssert, setLocalDebugType } from '@glimmer/debug-util';\nimport { destroy, registerDestructor } from '@glimmer/destroyable';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { Stack } from '@glimmer/util';\n\nimport type { DynamicAttribute } from './attributes/dynamic';\n\nimport { clear, ConcreteBounds, CursorImpl } from '../bounds';\nimport { dynamicAttribute } from './attributes/dynamic';\n\nexport interface FirstNode {\n  debug?: { first: () => Nullable<SimpleNode> };\n  firstNode(): SimpleNode;\n}\n\nexport interface LastNode {\n  debug?: { last: () => Nullable<SimpleNode> };\n  lastNode(): SimpleNode;\n}\n\nclass First {\n  constructor(private node: SimpleNode) {}\n\n  firstNode(): SimpleNode {\n    return this.node;\n  }\n}\n\nclass Last {\n  constructor(private node: SimpleNode) {}\n\n  lastNode(): SimpleNode {\n    return this.node;\n  }\n}\n\nexport class Fragment implements Bounds {\n  private bounds: Bounds;\n\n  constructor(bounds: Bounds) {\n    this.bounds = bounds;\n  }\n\n  parentElement(): SimpleElement {\n    return this.bounds.parentElement();\n  }\n\n  firstNode(): SimpleNode {\n    return this.bounds.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    return this.bounds.lastNode();\n  }\n}\n\nexport class NewTreeBuilder implements TreeBuilder {\n  declare debug?: () => {\n    blocks: AppendingBlock[];\n    constructing: Nullable<SimpleElement>;\n    cursors: Cursor[];\n  };\n\n  public dom: GlimmerTreeConstruction;\n  public updateOperations: GlimmerTreeChanges;\n  public constructing: Nullable<SimpleElement> = null;\n  public operations: Nullable<ElementOperations> = null;\n  private env: Environment;\n\n  readonly cursors = new Stack<Cursor>();\n  private modifierStack = new Stack<Nullable<ModifierInstance[]>>();\n  private blockStack = new Stack<AppendingBlock>();\n\n  static forInitialRender(env: Environment, cursor: CursorImpl) {\n    return new this(env, cursor.element, cursor.nextSibling).initialize();\n  }\n\n  static resume(env: Environment, block: ResettableBlock): NewTreeBuilder {\n    let parentNode = block.parentElement();\n    let nextSibling = block.reset(env);\n\n    let stack = new this(env, parentNode, nextSibling).initialize();\n    stack.pushBlock(block);\n\n    return stack;\n  }\n\n  constructor(env: Environment, parentNode: SimpleElement, nextSibling: Nullable<SimpleNode>) {\n    this.pushElement(parentNode, nextSibling);\n    this.env = env;\n    this.dom = env.getAppendOperations();\n    this.updateOperations = env.getDOM();\n\n    if (LOCAL_DEBUG) {\n      this.debug = () => ({\n        blocks: this.blockStack.snapshot(),\n        constructing: this.constructing,\n        cursors: this.cursors.snapshot(),\n      });\n    }\n  }\n\n  protected initialize(): this {\n    this.pushAppendingBlock();\n    return this;\n  }\n\n  debugBlocks(): AppendingBlock[] {\n    return this.blockStack.toArray();\n  }\n\n  get element(): SimpleElement {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    return this.cursors.current!.element;\n  }\n\n  get nextSibling(): Nullable<SimpleNode> {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    return this.cursors.current!.nextSibling;\n  }\n\n  get hasBlocks() {\n    return this.blockStack.size > 0;\n  }\n\n  protected block(): AppendingBlock {\n    return expect(this.blockStack.current, 'Expected a current live block');\n  }\n\n  popElement() {\n    this.cursors.pop();\n    expect(this.cursors.current, \"can't pop past the last element\");\n  }\n\n  pushAppendingBlock(): AppendingBlock {\n    return this.pushBlock(new AppendingBlockImpl(this.element));\n  }\n\n  pushResettableBlock(): ResettableBlockImpl {\n    return this.pushBlock(new ResettableBlockImpl(this.element));\n  }\n\n  pushBlockList(list: AppendingBlock[]): AppendingBlockList {\n    return this.pushBlock(new AppendingBlockList(this.element, list));\n  }\n\n  protected pushBlock<T extends AppendingBlock>(block: T, isRemote = false): T {\n    let current = this.blockStack.current;\n\n    if (current !== null) {\n      if (!isRemote) {\n        current.didAppendBounds(block);\n      }\n    }\n\n    this.__openBlock();\n    this.blockStack.push(block);\n    return block;\n  }\n\n  popBlock(): AppendingBlock {\n    this.block().finalize(this);\n    this.__closeBlock();\n    return expect(this.blockStack.pop(), 'Expected popBlock to return a block');\n  }\n\n  __openBlock(): void {}\n  __closeBlock(): void {}\n\n  // todo return seems unused\n  openElement(tag: string): SimpleElement {\n    let element = this.__openElement(tag);\n    this.constructing = element;\n\n    return element;\n  }\n\n  __openElement(tag: string): SimpleElement {\n    return this.dom.createElement(tag, this.element);\n  }\n\n  flushElement(modifiers: Nullable<ModifierInstance[]>) {\n    let parent = this.element;\n    let element = expect(\n      this.constructing,\n      `flushElement should only be called when constructing an element`\n    );\n\n    this.__flushElement(parent, element);\n\n    this.constructing = null;\n    this.operations = null;\n\n    this.pushModifiers(modifiers);\n    this.pushElement(element, null);\n    this.didOpenElement(element);\n  }\n\n  __flushElement(parent: SimpleElement, constructing: SimpleElement) {\n    this.dom.insertBefore(parent, constructing, this.nextSibling);\n  }\n\n  closeElement(): Nullable<ModifierInstance[]> {\n    this.willCloseElement();\n    this.popElement();\n    return this.popModifiers();\n  }\n\n  pushRemoteElement(\n    element: SimpleElement,\n    guid: string,\n    insertBefore: Maybe<SimpleNode>\n  ): RemoteBlock {\n    return this.__pushRemoteElement(element, guid, insertBefore);\n  }\n\n  __pushRemoteElement(\n    element: SimpleElement,\n    _guid: string,\n    insertBefore: Maybe<SimpleNode>\n  ): RemoteBlock {\n    this.pushElement(element, insertBefore);\n\n    if (insertBefore === undefined) {\n      while (element.lastChild) {\n        element.removeChild(element.lastChild);\n      }\n    }\n\n    let block = new RemoteBlock(element);\n\n    return this.pushBlock(block, true);\n  }\n\n  popRemoteElement(): RemoteBlock {\n    const block = this.popBlock();\n    localAssert(block instanceof RemoteBlock, '[BUG] expecting a RemoteBlock');\n    this.popElement();\n    return block;\n  }\n\n  protected pushElement(element: SimpleElement, nextSibling: Maybe<SimpleNode> = null): void {\n    this.cursors.push(new CursorImpl(element, nextSibling));\n  }\n\n  private pushModifiers(modifiers: Nullable<ModifierInstance[]>): void {\n    this.modifierStack.push(modifiers);\n  }\n\n  private popModifiers(): Nullable<ModifierInstance[]> {\n    return this.modifierStack.pop();\n  }\n\n  didAppendBounds(bounds: Bounds): Bounds {\n    this.block().didAppendBounds(bounds);\n    return bounds;\n  }\n\n  didAppendNode<T extends SimpleNode>(node: T): T {\n    this.block().didAppendNode(node);\n    return node;\n  }\n\n  didOpenElement(element: SimpleElement): SimpleElement {\n    this.block().openElement(element);\n    return element;\n  }\n\n  willCloseElement(): void {\n    this.block().closeElement();\n  }\n\n  appendText(string: string): SimpleText {\n    return this.didAppendNode(this.__appendText(string));\n  }\n\n  __appendText(text: string): SimpleText {\n    let { dom, element, nextSibling } = this;\n    let node = dom.createTextNode(text);\n    dom.insertBefore(element, node, nextSibling);\n    return node;\n  }\n\n  __appendNode(node: SimpleNode): SimpleNode {\n    this.dom.insertBefore(this.element, node, this.nextSibling);\n    return node;\n  }\n\n  __appendFragment(fragment: SimpleDocumentFragment): Bounds {\n    let first = fragment.firstChild;\n\n    if (first) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      let ret = new ConcreteBounds(this.element, first, fragment.lastChild!);\n      this.dom.insertBefore(this.element, fragment, this.nextSibling);\n      return ret;\n    } else {\n      const comment = this.__appendComment('');\n      return new ConcreteBounds(this.element, comment, comment);\n    }\n  }\n\n  __appendHTML(html: string): Bounds {\n    return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);\n  }\n\n  appendDynamicHTML(value: string): void {\n    let bounds = this.trustedContent(value);\n    this.didAppendBounds(bounds);\n  }\n\n  appendDynamicText(value: string): SimpleText {\n    let node = this.untrustedContent(value);\n    this.didAppendNode(node);\n    return node;\n  }\n\n  appendDynamicFragment(value: SimpleDocumentFragment): void {\n    let bounds = this.__appendFragment(value);\n    this.didAppendBounds(bounds);\n  }\n\n  appendDynamicNode(value: SimpleNode): void {\n    let node = this.__appendNode(value);\n    let bounds = new ConcreteBounds(this.element, node, node);\n    this.didAppendBounds(bounds);\n  }\n\n  private trustedContent(value: string): Bounds {\n    return this.__appendHTML(value);\n  }\n\n  private untrustedContent(value: string): SimpleText {\n    return this.__appendText(value);\n  }\n\n  appendComment(string: string): SimpleComment {\n    return this.didAppendNode(this.__appendComment(string));\n  }\n\n  __appendComment(string: string): SimpleComment {\n    let { dom, element, nextSibling } = this;\n    let node = dom.createComment(string);\n    dom.insertBefore(element, node, nextSibling);\n    return node;\n  }\n\n  __setAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    this.dom.setAttribute(this.constructing!, name, value, namespace);\n  }\n\n  __setProperty(name: string, value: unknown): void {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    (this.constructing! as unknown as Element)[name as MutableKey<Element>] = value as never;\n  }\n\n  setStaticAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void {\n    this.__setAttribute(name, value, namespace);\n  }\n\n  setDynamicAttribute(\n    name: string,\n    value: unknown,\n    trusting: boolean,\n    namespace: Nullable<AttrNamespace>\n  ): DynamicAttribute {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    let element = this.constructing!;\n    let attribute = dynamicAttribute(element, name, namespace, trusting);\n    attribute.set(this, value, this.env);\n    return attribute;\n  }\n}\n\nexport class AppendingBlockImpl implements AppendingBlock {\n  declare debug?: { first: () => Nullable<SimpleNode>; last: () => Nullable<SimpleNode> };\n\n  protected first: Nullable<FirstNode> = null;\n  protected last: Nullable<LastNode> = null;\n  protected nesting = 0;\n\n  constructor(private parent: SimpleElement) {\n    setLocalDebugType('block:simple', this);\n\n    if (LOCAL_DEBUG) {\n      this.debug = {\n        first: () => this.first?.debug?.first() ?? null,\n        last: () => this.last?.debug?.last() ?? null,\n      };\n    }\n  }\n\n  parentElement() {\n    return this.parent;\n  }\n\n  firstNode(): SimpleNode {\n    let first = expect(\n      this.first,\n      'cannot call `firstNode()` while `AppendingBlock` is still initializing'\n    );\n\n    return first.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    let last = expect(\n      this.last,\n      'cannot call `lastNode()` while `AppendingBlock` is still initializing'\n    );\n\n    return last.lastNode();\n  }\n\n  openElement(element: SimpleElement) {\n    this.didAppendNode(element);\n    this.nesting++;\n  }\n\n  closeElement() {\n    this.nesting--;\n  }\n\n  didAppendNode(node: SimpleNode) {\n    if (this.nesting !== 0) return;\n\n    if (!this.first) {\n      this.first = new First(node);\n    }\n\n    this.last = new Last(node);\n  }\n\n  didAppendBounds(bounds: Bounds) {\n    if (this.nesting !== 0) return;\n\n    if (!this.first) {\n      this.first = bounds;\n    }\n\n    this.last = bounds;\n  }\n\n  finalize(stack: TreeBuilder) {\n    if (this.first === null) {\n      stack.appendComment('');\n    }\n  }\n}\n\nexport class RemoteBlock extends AppendingBlockImpl {\n  constructor(parent: SimpleElement) {\n    super(parent);\n\n    setLocalDebugType('block:remote', this);\n\n    registerDestructor(this, () => {\n      // In general, you only need to clear the root of a hierarchy, and should never\n      // need to clear any child nodes. This is an important constraint that gives us\n      // a strong guarantee that clearing a subtree is a single DOM operation.\n      //\n      // Because remote blocks are not normally physically nested inside of the tree\n      // that they are logically nested inside, we manually clear remote blocks when\n      // a logical parent is cleared.\n      //\n      // HOWEVER, it is currently possible for a remote block to be physically nested\n      // inside of the block it is logically contained inside of. This happens when\n      // the remote block is appended to the end of the application's entire element.\n      //\n      // The problem with that scenario is that Glimmer believes that it owns more of\n      // the DOM than it actually does. The code is attempting to write past the end\n      // of the Glimmer-managed root, but Glimmer isn't aware of that.\n      //\n      // The correct solution to that problem is for Glimmer to be aware of the end\n      // of the bounds that it owns, and once we make that change, this check could\n      // be removed.\n      //\n      // For now, a more targeted fix is to check whether the node was already removed\n      // and avoid clearing the node if it was. In most cases this shouldn't happen,\n      // so this might hide bugs where the code clears nested nodes unnecessarily,\n      // so we should eventually try to do the correct fix.\n      if (this.parentElement() === this.firstNode().parentNode) {\n        clear(this);\n      }\n    });\n  }\n}\n\nexport class ResettableBlockImpl extends AppendingBlockImpl implements ResettableBlock {\n  constructor(parent: SimpleElement) {\n    super(parent);\n    setLocalDebugType('block:resettable', this);\n  }\n\n  reset(): Nullable<SimpleNode> {\n    destroy(this);\n    let nextSibling = clear(this);\n\n    this.first = null;\n    this.last = null;\n    this.nesting = 0;\n\n    return nextSibling;\n  }\n}\n\n// FIXME: All the noops in here indicate a modelling problem\nexport class AppendingBlockList implements AppendingBlock {\n  constructor(\n    private readonly parent: SimpleElement,\n    public boundList: AppendingBlock[]\n  ) {\n    this.parent = parent;\n    this.boundList = boundList;\n  }\n\n  parentElement() {\n    return this.parent;\n  }\n\n  firstNode(): SimpleNode {\n    let head = expect(\n      this.boundList[0],\n      'cannot call `firstNode()` while `AppendingBlockList` is still initializing'\n    );\n\n    return head.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    let boundList = this.boundList;\n\n    let tail = expect(\n      boundList[boundList.length - 1],\n      'cannot call `lastNode()` while `AppendingBlockList` is still initializing'\n    );\n\n    return tail.lastNode();\n  }\n\n  openElement(_element: SimpleElement) {\n    localAssert(false, 'Cannot openElement directly inside a block list');\n  }\n\n  closeElement() {\n    localAssert(false, 'Cannot closeElement directly inside a block list');\n  }\n\n  didAppendNode(_node: SimpleNode) {\n    localAssert(false, 'Cannot create a new node directly inside a block list');\n  }\n\n  didAppendBounds(_bounds: Bounds) {}\n\n  finalize(_stack: TreeBuilder) {\n    localAssert(this.boundList.length > 0, 'boundsList cannot be empty');\n  }\n}\n\nexport function clientBuilder(env: Environment, cursor: CursorImpl): TreeBuilder {\n  return NewTreeBuilder.forInitialRender(env, cursor);\n}\n\nexport type MutableKey<T> = {\n  [P in keyof T]-?: (<U>() => U extends { [K in P]: T[P] } ? 1 : 2) extends <U>() => U extends {\n    -readonly [K in P]: T[P];\n  }\n    ? 1\n    : 2\n    ? P\n    : never;\n}[keyof T];\n","import type {\n  AppendingBlock,\n  Bounds,\n  DynamicScope,\n  Environment,\n  EvaluationContext,\n  ExceptionHandler,\n  GlimmerTreeChanges,\n  Nullable,\n  ResettableBlock,\n  Scope,\n  SimpleComment,\n  UpdatingOpcode,\n  UpdatingVM as IUpdatingVM,\n} from '@glimmer/interfaces';\nimport type { OpaqueIterationItem, OpaqueIterator, Reference } from '@glimmer/reference';\nimport { expect, unwrap } from '@glimmer/debug-util';\nimport { associateDestroyableChild, destroy, destroyChildren } from '@glimmer/destroyable';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { updateRef, valueForRef } from '@glimmer/reference';\nimport { logStep, Stack } from '@glimmer/util';\nimport { debug, resetTracking } from '@glimmer/validator';\n\nimport type { Closure } from './append';\nimport type { AppendingBlockList } from './element-builder';\n\nimport { clear, move as moveBounds } from '../bounds';\nimport { NewTreeBuilder } from './element-builder';\n\nexport class UpdatingVM implements IUpdatingVM {\n  public env: Environment;\n  public dom: GlimmerTreeChanges;\n  public alwaysRevalidate: boolean;\n\n  private frameStack: Stack<UpdatingVMFrame> = new Stack<UpdatingVMFrame>();\n\n  constructor(env: Environment, { alwaysRevalidate = false }) {\n    this.env = env;\n    this.dom = env.getDOM();\n    this.alwaysRevalidate = alwaysRevalidate;\n  }\n\n  execute(opcodes: UpdatingOpcode[], handler: ExceptionHandler) {\n    if (import.meta.env.DEV) {\n      let hasErrored = true;\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        debug.runInTrackingTransaction!(\n          () => this._execute(opcodes, handler),\n          '- While rendering:'\n        );\n\n        // using a boolean here to avoid breaking ergonomics of \"pause on uncaught exceptions\"\n        // which would happen with a `catch` + `throw`\n        hasErrored = false;\n      } finally {\n        if (hasErrored) {\n          // eslint-disable-next-line no-console\n          console.error(`\\n\\nError occurred:\\n\\n${resetTracking()}\\n\\n`);\n        }\n      }\n    } else {\n      this._execute(opcodes, handler);\n    }\n  }\n\n  private _execute(opcodes: UpdatingOpcode[], handler: ExceptionHandler) {\n    let { frameStack } = this;\n\n    this.try(opcodes, handler);\n\n    while (!frameStack.isEmpty()) {\n      let opcode = this.frame.nextStatement();\n\n      if (opcode === undefined) {\n        frameStack.pop();\n        continue;\n      }\n\n      opcode.evaluate(this);\n    }\n  }\n\n  private get frame() {\n    return expect(this.frameStack.current, 'bug: expected a frame');\n  }\n\n  goto(index: number) {\n    this.frame.goto(index);\n  }\n\n  try(ops: UpdatingOpcode[], handler: Nullable<ExceptionHandler>) {\n    this.frameStack.push(new UpdatingVMFrame(ops, handler));\n  }\n\n  throw() {\n    this.frame.handleException();\n    this.frameStack.pop();\n  }\n}\n\nexport interface VMState {\n  readonly pc: number;\n  readonly scope: Scope;\n  readonly dynamicScope: DynamicScope;\n  readonly stack: unknown[];\n}\n\nexport abstract class BlockOpcode implements UpdatingOpcode, Bounds {\n  public children: UpdatingOpcode[];\n\n  protected readonly bounds: AppendingBlock;\n\n  constructor(\n    protected state: Closure,\n    protected context: EvaluationContext,\n    bounds: AppendingBlock,\n    children: UpdatingOpcode[]\n  ) {\n    this.children = children;\n    this.bounds = bounds;\n  }\n\n  parentElement() {\n    return this.bounds.parentElement();\n  }\n\n  firstNode() {\n    return this.bounds.firstNode();\n  }\n\n  lastNode() {\n    return this.bounds.lastNode();\n  }\n\n  evaluate(vm: UpdatingVM) {\n    vm.try(this.children, null);\n  }\n}\n\nexport class TryOpcode extends BlockOpcode implements ExceptionHandler {\n  public type = 'try';\n\n  declare protected bounds: ResettableBlock; // Shadows property on base class\n\n  override evaluate(vm: UpdatingVM) {\n    vm.try(this.children, this);\n  }\n\n  handleException() {\n    let {\n      state,\n      bounds,\n      context: { env },\n    } = this;\n\n    destroyChildren(this);\n\n    let tree = NewTreeBuilder.resume(env, bounds);\n    let vm = state.evaluate(tree);\n\n    let children = (this.children = []);\n\n    let result = vm.execute((vm) => {\n      vm.updateWith(this);\n      vm.pushUpdating(children);\n    });\n\n    associateDestroyableChild(this, result.drop);\n  }\n}\n\nexport class ListItemOpcode extends TryOpcode {\n  public retained = false;\n  public index = -1;\n\n  constructor(\n    state: Closure,\n    context: EvaluationContext,\n    bounds: ResettableBlock,\n    public key: unknown,\n    public memo: Reference,\n    public value: Reference\n  ) {\n    super(state, context, bounds, []);\n  }\n\n  shouldRemove(): boolean {\n    return !this.retained;\n  }\n\n  reset() {\n    this.retained = false;\n  }\n}\n\nexport class ListBlockOpcode extends BlockOpcode {\n  public type = 'list-block';\n  declare public children: ListItemOpcode[];\n\n  private opcodeMap = new Map<unknown, ListItemOpcode>();\n  private marker: SimpleComment | null = null;\n  private lastIterator: OpaqueIterator;\n\n  declare protected readonly bounds: AppendingBlockList;\n\n  constructor(\n    state: Closure,\n    context: EvaluationContext,\n    bounds: AppendingBlockList,\n    children: ListItemOpcode[],\n    private iterableRef: Reference<OpaqueIterator>\n  ) {\n    super(state, context, bounds, children);\n    this.lastIterator = valueForRef(iterableRef);\n  }\n\n  initializeChild(opcode: ListItemOpcode) {\n    opcode.index = this.children.length - 1;\n    this.opcodeMap.set(opcode.key, opcode);\n  }\n\n  override evaluate(vm: UpdatingVM) {\n    let iterator = valueForRef(this.iterableRef);\n\n    if (this.lastIterator !== iterator) {\n      let { bounds } = this;\n      let { dom } = vm;\n\n      let marker = (this.marker = dom.createComment(''));\n      dom.insertAfter(\n        bounds.parentElement(),\n        marker,\n        expect(bounds.lastNode(), \"can't insert after an empty bounds\")\n      );\n\n      this.sync(iterator);\n\n      this.parentElement().removeChild(marker);\n      this.marker = null;\n      this.lastIterator = iterator;\n    }\n\n    // Run now-updated updating opcodes\n    super.evaluate(vm);\n  }\n\n  private sync(iterator: OpaqueIterator) {\n    let { opcodeMap: itemMap, children } = this;\n\n    let currentOpcodeIndex = 0;\n    let seenIndex = 0;\n\n    this.children = this.bounds.boundList = [];\n\n    while (true) {\n      let item = iterator.next();\n\n      if (item === null) break;\n\n      let opcode = children[currentOpcodeIndex];\n      let { key } = item;\n\n      // Items that have already been found and moved will already be retained,\n      // we can continue until we find the next unretained item\n      while (opcode !== undefined && opcode.retained) {\n        opcode = children[++currentOpcodeIndex];\n      }\n\n      if (opcode !== undefined && opcode.key === key) {\n        this.retainItem(opcode, item);\n        currentOpcodeIndex++;\n      } else if (itemMap.has(key)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        let itemOpcode = itemMap.get(key)!;\n\n        // The item opcode was seen already, so we should move it.\n        if (itemOpcode.index < seenIndex) {\n          this.moveItem(itemOpcode, item, opcode);\n        } else {\n          // Update the seen index, we are going to be moving this item around\n          // so any other items that come before it will likely need to move as\n          // well.\n          seenIndex = itemOpcode.index;\n\n          let seenUnretained = false;\n\n          // iterate through all of the opcodes between the current position and\n          // the position of the item's opcode, and determine if they are all\n          // retained.\n          for (let i = currentOpcodeIndex + 1; i < seenIndex; i++) {\n            if (!unwrap(children[i]).retained) {\n              seenUnretained = true;\n              break;\n            }\n          }\n\n          // If we have seen only retained opcodes between this and the matching\n          // opcode, it means that all the opcodes in between have been moved\n          // already, and we can safely retain this item's opcode.\n          if (!seenUnretained) {\n            this.retainItem(itemOpcode, item);\n            currentOpcodeIndex = seenIndex + 1;\n          } else {\n            this.moveItem(itemOpcode, item, opcode);\n            currentOpcodeIndex++;\n          }\n        }\n      } else {\n        this.insertItem(item, opcode);\n      }\n    }\n\n    for (const opcode of children) {\n      if (!opcode.retained) {\n        this.deleteItem(opcode);\n      } else {\n        opcode.reset();\n      }\n    }\n  }\n\n  private retainItem(opcode: ListItemOpcode, item: OpaqueIterationItem) {\n    if (LOCAL_DEBUG) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      logStep!('list-updates', ['retain', item.key]);\n    }\n\n    let { children } = this;\n\n    updateRef(opcode.memo, item.memo);\n    updateRef(opcode.value, item.value);\n    opcode.retained = true;\n\n    opcode.index = children.length;\n    children.push(opcode);\n  }\n\n  private insertItem(item: OpaqueIterationItem, before: ListItemOpcode | undefined) {\n    if (LOCAL_DEBUG) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      logStep!('list-updates', ['insert', item.key]);\n    }\n\n    let {\n      opcodeMap,\n      bounds,\n      state,\n      children,\n      context: { env },\n    } = this;\n    let { key } = item;\n    let nextSibling = before === undefined ? this.marker : before.firstNode();\n\n    let elementStack = NewTreeBuilder.forInitialRender(env, {\n      element: bounds.parentElement(),\n      nextSibling,\n    });\n\n    let vm = state.evaluate(elementStack);\n\n    vm.execute((vm) => {\n      let opcode = vm.enterItem(item);\n\n      opcode.index = children.length;\n      children.push(opcode);\n      opcodeMap.set(key, opcode);\n      associateDestroyableChild(this, opcode);\n    });\n  }\n\n  private moveItem(\n    opcode: ListItemOpcode,\n    item: OpaqueIterationItem,\n    before: ListItemOpcode | undefined\n  ) {\n    let { children } = this;\n\n    updateRef(opcode.memo, item.memo);\n    updateRef(opcode.value, item.value);\n    opcode.retained = true;\n\n    let currentSibling, nextSibling;\n\n    if (before === undefined) {\n      moveBounds(opcode, this.marker);\n    } else {\n      currentSibling = opcode.lastNode().nextSibling;\n      nextSibling = before.firstNode();\n\n      // Items are moved throughout the algorithm, so there are cases where the\n      // the items already happen to be siblings (e.g. an item in between was\n      // moved before this move happened). Check to see if they are siblings\n      // first before doing the move.\n      if (currentSibling !== nextSibling) {\n        moveBounds(opcode, nextSibling);\n      }\n    }\n\n    opcode.index = children.length;\n    children.push(opcode);\n\n    if (LOCAL_DEBUG) {\n      let type = currentSibling && currentSibling === nextSibling ? 'move-retain' : 'move';\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      logStep!('list-updates', [type, item.key]);\n    }\n  }\n\n  private deleteItem(opcode: ListItemOpcode) {\n    if (LOCAL_DEBUG) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      logStep!('list-updates', ['delete', opcode.key]);\n    }\n\n    destroy(opcode);\n    clear(opcode);\n    this.opcodeMap.delete(opcode.key);\n  }\n}\n\nclass UpdatingVMFrame {\n  private current = 0;\n\n  constructor(\n    private ops: UpdatingOpcode[],\n    private exceptionHandler: Nullable<ExceptionHandler>\n  ) {}\n\n  goto(index: number) {\n    this.current = index;\n  }\n\n  nextStatement(): UpdatingOpcode | undefined {\n    return this.ops[this.current++];\n  }\n\n  handleException() {\n    if (this.exceptionHandler) {\n      this.exceptionHandler.handleException();\n    }\n  }\n}\n","import type {\n  AppendingBlock,\n  Environment,\n  RenderResult,\n  SimpleElement,\n  SimpleNode,\n  UpdatingOpcode,\n} from '@glimmer/interfaces';\nimport { unreachable } from '@glimmer/debug-util';\nimport { associateDestroyableChild, registerDestructor } from '@glimmer/destroyable';\n\nimport { clear } from '../bounds';\nimport { UpdatingVM } from './update';\n\nexport default class RenderResultImpl implements RenderResult {\n  constructor(\n    public env: Environment,\n    private updating: UpdatingOpcode[],\n    private bounds: AppendingBlock,\n    readonly drop: object\n  ) {\n    associateDestroyableChild(this, drop);\n    registerDestructor(this, () => clear(this.bounds));\n  }\n\n  rerender({ alwaysRevalidate = false } = { alwaysRevalidate: false }) {\n    let { env, updating } = this;\n    let vm = new UpdatingVM(env, { alwaysRevalidate });\n    vm.execute(updating, this);\n  }\n\n  parentElement(): SimpleElement {\n    return this.bounds.parentElement();\n  }\n\n  firstNode(): SimpleNode {\n    return this.bounds.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    return this.bounds.lastNode();\n  }\n\n  handleException() {\n    unreachable(`this should never happen`);\n  }\n}\n","import { localAssert } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { $fp, $pc, $sp } from '@glimmer/vm';\n\nimport type { LowLevelRegisters } from './low-level';\n\nimport { initializeRegistersWithSP } from './low-level';\n\nexport interface EvaluationStack {\n  readonly registers: LowLevelRegisters;\n\n  push(value: unknown): void;\n  dup(position?: number): void;\n  copy(from: number, to: number): void;\n  pop<T>(n?: number): T;\n  peek<T>(offset?: number): T;\n  get<T>(offset: number, base?: number): T;\n  set(value: unknown, offset: number, base?: number): void;\n  slice<T = unknown>(start: number, end: number): T[];\n  capture(items: number): unknown[];\n  reset(): void;\n\n  snapshot?(): unknown[];\n}\n\nexport default class EvaluationStackImpl implements EvaluationStack {\n  static restore(snapshot: unknown[], pc: number): EvaluationStackImpl {\n    const stack = new this(snapshot.slice(), initializeRegistersWithSP(snapshot.length - 1));\n\n    localAssert(typeof pc === 'number', 'pc is a number');\n\n    stack.registers[$pc] = pc;\n    stack.registers[$sp] = snapshot.length - 1;\n    stack.registers[$fp] = -1;\n\n    return stack;\n  }\n\n  readonly registers: LowLevelRegisters;\n\n  // fp -> sp\n  constructor(\n    private stack: unknown[] = [],\n    registers: LowLevelRegisters\n  ) {\n    this.registers = registers;\n\n    if (LOCAL_DEBUG) {\n      this.snapshot = () => {\n        const fpRegister = this.registers[$fp];\n        const fp = fpRegister === -1 ? 0 : fpRegister;\n        return this.stack.slice(fp, this.registers[$sp] + 1);\n      };\n      Object.seal(this);\n    }\n  }\n\n  push(value: unknown): void {\n    this.stack[++this.registers[$sp]] = value;\n  }\n\n  dup(position = this.registers[$sp]): void {\n    this.stack[++this.registers[$sp]] = this.stack[position];\n  }\n\n  copy(from: number, to: number): void {\n    this.stack[to] = this.stack[from];\n  }\n\n  pop<T>(n = 1): T {\n    let top = this.stack[this.registers[$sp]] as T;\n    this.registers[$sp] -= n;\n    return top;\n  }\n\n  peek<T>(offset = 0): T {\n    return this.stack[this.registers[$sp] - offset] as T;\n  }\n\n  get<T>(offset: number, base = this.registers[$fp]): T {\n    return this.stack[base + offset] as T;\n  }\n\n  set(value: unknown, offset: number, base = this.registers[$fp]) {\n    this.stack[base + offset] = value;\n  }\n\n  slice<T = unknown>(start: number, end: number): T[] {\n    return this.stack.slice(start, end) as T[];\n  }\n\n  capture(items: number): unknown[] {\n    let end = this.registers[$sp] + 1;\n    let start = end - items;\n    return this.stack.slice(start, end);\n  }\n\n  reset() {\n    this.stack.length = 0;\n  }\n\n  declare snapshot?: (this: EvaluationStackImpl) => unknown[];\n\n  static {\n    if (LOCAL_DEBUG) {\n      EvaluationStackImpl.prototype.snapshot = function () {\n        return this.stack.slice(this.registers[$fp], this.registers[$sp] + 1);\n      };\n    }\n  }\n}\n","import type {\n  BlockMetadata,\n  CompilableTemplate,\n  DebugStacks,\n  DebugTemplates,\n  DebugVmSnapshot,\n  DebugVmTrace,\n  Destroyable,\n  DynamicScope,\n  Environment,\n  EvaluationContext,\n  Owner,\n  Program,\n  ProgramConstants,\n  RenderResult,\n  RichIteratorResult,\n  Scope,\n  SyscallRegisters,\n  TreeBuilder,\n  UpdatingOpcode,\n} from '@glimmer/interfaces';\nimport type { OpaqueIterationItem, OpaqueIterator, Reference } from '@glimmer/reference';\nimport type { MachineRegister, Register, SyscallRegister } from '@glimmer/vm';\nimport { dev, expect, unwrapHandle } from '@glimmer/debug-util';\nimport { associateDestroyableChild } from '@glimmer/destroyable';\nimport { assertGlobalContextWasSet } from '@glimmer/global-context';\nimport { LOCAL_DEBUG, LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\nimport { createIteratorItemRef, UNDEFINED_REFERENCE } from '@glimmer/reference';\nimport { LOCAL_LOGGER, reverse, Stack } from '@glimmer/util';\nimport { beginTrackFrame, endTrackFrame, resetTracking } from '@glimmer/validator';\nimport { $pc, isLowLevelRegister } from '@glimmer/vm';\n\nimport type { ScopeOptions } from '../scope';\nimport type { AppendingBlockList } from './element-builder';\nimport type { EvaluationStack } from './stack';\nimport type { BlockOpcode } from './update';\n\nimport {\n  BeginTrackFrameOpcode,\n  EndTrackFrameOpcode,\n  JumpIfNotModifiedOpcode,\n} from '../compiled/opcodes/vm';\nimport { externs } from '../opcodes';\nimport { ScopeImpl } from '../scope';\nimport { VMArgumentsImpl } from './arguments';\nimport { LowLevelVM } from './low-level';\nimport RenderResultImpl from './render-result';\nimport EvaluationStackImpl from './stack';\nimport { ListBlockOpcode, ListItemOpcode, TryOpcode } from './update';\n\nclass Stacks {\n  declare debug?: () => DebugStacks;\n  readonly drop: object = {};\n\n  readonly scope = new Stack<Scope>();\n  readonly dynamicScope = new Stack<DynamicScope>();\n  readonly updating = new Stack<UpdatingOpcode[]>();\n  readonly cache = new Stack<JumpIfNotModifiedOpcode>();\n  readonly list = new Stack<ListBlockOpcode>();\n  readonly destroyable = new Stack<object>();\n\n  constructor(scope: Scope, dynamicScope: DynamicScope) {\n    this.scope.push(scope);\n    this.dynamicScope.push(dynamicScope);\n    this.destroyable.push(this.drop);\n\n    if (LOCAL_DEBUG) {\n      this.debug = (): DebugStacks => {\n        return {\n          scope: this.scope.snapshot(),\n          dynamicScope: this.dynamicScope.snapshot(),\n          updating: this.updating.snapshot(),\n          cache: this.cache.snapshot(),\n          list: this.list.snapshot(),\n          destroyable: this.destroyable.snapshot(),\n        };\n      };\n    }\n  }\n}\n\ntype Handle = number;\n\nlet DebugTemplatesImpl: undefined | (new () => DebugTemplates);\n\nif (LOCAL_DEBUG) {\n  DebugTemplatesImpl = class DebugTemplatesImpl implements DebugTemplates {\n    readonly #templates: Map<Handle, BlockMetadata> = new Map();\n    #active: Handle[] = [];\n\n    willCall(handle: Handle): void {\n      this.#active.push(handle);\n    }\n\n    return(): void {\n      this.#active.pop();\n    }\n\n    get active(): BlockMetadata | null {\n      const current = this.#active.at(-1);\n      return current ? (this.#templates.get(current) ?? null) : null;\n    }\n\n    register(handle: Handle, metadata: BlockMetadata): void {\n      this.#templates.set(handle, metadata);\n    }\n  };\n}\n\nexport class VM {\n  readonly #stacks: Stacks;\n  readonly args: VMArgumentsImpl;\n  readonly lowlevel: LowLevelVM;\n\n  readonly debug?: () => DebugVmSnapshot;\n  readonly trace?: () => DebugVmTrace;\n\n  get stack(): EvaluationStack {\n    return this.lowlevel.stack as EvaluationStack;\n  }\n\n  /* Registers */\n\n  get pc(): number {\n    return this.lowlevel.fetchRegister($pc);\n  }\n\n  #registers: SyscallRegisters = [null, null, null, null, null, null, null, null, null];\n\n  /**\n   * Fetch a value from a syscall register onto the stack.\n   *\n   * ## Opcodes\n   *\n   * - Append: `Fetch`\n   *\n   * ## State changes\n   *\n   * [!] push Eval Stack <- $register\n   */\n  fetch(register: SyscallRegister): void {\n    let value = this.fetchValue(register);\n\n    this.stack.push(value);\n  }\n\n  /**\n   * Load a value from the stack into a syscall register.\n   *\n   * ## Opcodes\n   *\n   * - Append: `Load`\n   *\n   * ## State changes\n   *\n   * [!] pop Eval Stack -> `value`\n   * [$] $register <- `value`\n   */\n  load(register: SyscallRegister) {\n    let value = this.stack.pop();\n\n    this.loadValue(register, value);\n  }\n\n  /**\n   * Load a value into a syscall register.\n   *\n   * ## State changes\n   *\n   * [$] $register <- `value`\n   *\n   * @utility\n   */\n  loadValue<T>(register: SyscallRegister, value: T): void {\n    this.#registers[register] = value;\n  }\n\n  /**\n   * Fetch a value from a register (machine or syscall).\n   *\n   * ## State changes\n   *\n   * [ ] get $register\n   *\n   * @utility\n   */\n  fetchValue(register: MachineRegister): number;\n  fetchValue<T>(register: Register): T;\n  fetchValue(register: Register | MachineRegister): unknown {\n    if (isLowLevelRegister(register)) {\n      return this.lowlevel.fetchRegister(register);\n    }\n\n    return this.#registers[register];\n  }\n\n  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n  call(handle: number | null) {\n    if (handle !== null) {\n      if (LOCAL_DEBUG) {\n        dev(this.trace).willCall(handle);\n      }\n\n      this.lowlevel.call(handle);\n    }\n  }\n\n  // Return to the `program` address stored in $ra\n  return() {\n    if (LOCAL_DEBUG) {\n      dev(this.trace).return();\n    }\n\n    this.lowlevel.return();\n  }\n\n  readonly #tree: TreeBuilder;\n  readonly context: EvaluationContext;\n\n  constructor(\n    { scope, dynamicScope, stack, pc }: ClosureState,\n    context: EvaluationContext,\n    tree: TreeBuilder\n  ) {\n    if (import.meta.env.DEV) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      assertGlobalContextWasSet!();\n    }\n\n    let evalStack = EvaluationStackImpl.restore(stack, pc);\n\n    this.#tree = tree;\n    this.context = context;\n\n    this.#stacks = new Stacks(scope, dynamicScope);\n\n    this.args = new VMArgumentsImpl();\n    this.lowlevel = new LowLevelVM(evalStack, context, externs(this), evalStack.registers);\n\n    if (LOCAL_DEBUG) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      const templates = new DebugTemplatesImpl!();\n\n      this.trace = () => templates;\n\n      this.debug = () => ({\n        context,\n\n        trace: templates,\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        elements: this.tree().debug!(),\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        stacks: this.#stacks.debug!(),\n\n        template: templates.active,\n        scope: this.scope().snapshot(),\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        stack: this.lowlevel.stack.snapshot!(),\n        registers: [\n          ...this.lowlevel.registers,\n          ...sliceTuple(this.#registers, this.lowlevel.registers),\n        ],\n      });\n    }\n\n    this.pushUpdating();\n  }\n\n  static initial(context: EvaluationContext, options: InitialVmState) {\n    let scope = ScopeImpl.root(\n      options.owner,\n      options.scope ?? { self: UNDEFINED_REFERENCE, size: 0 }\n    );\n\n    const state = closureState(\n      context.program.heap.getaddr(options.handle),\n      scope,\n      options.dynamicScope\n    );\n\n    return new VM(state, context, options.tree);\n  }\n\n  compile(block: CompilableTemplate): number {\n    let handle = unwrapHandle(block.compile(this.context));\n\n    if (LOCAL_DEBUG) {\n      dev(this.trace).register(handle, block.meta);\n    }\n\n    return handle;\n  }\n\n  get constants(): ProgramConstants {\n    return this.context.program.constants;\n  }\n\n  get program(): Program {\n    return this.context.program;\n  }\n\n  get env(): Environment {\n    return this.context.env;\n  }\n\n  private captureClosure(args: number, pc = this.lowlevel.fetchRegister($pc)): ClosureState {\n    return {\n      pc,\n      scope: this.scope(),\n      dynamicScope: this.dynamicScope(),\n      stack: this.stack.capture(args),\n    };\n  }\n\n  capture(args: number, pc = this.lowlevel.fetchRegister($pc)): Closure {\n    return new Closure(this.captureClosure(args, pc), this.context);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `BeginComponentTransaction`\n   *\n   * ## State Changes\n   *\n   * [ ] create `guard` (`JumpIfNotModifiedOpcode`)\n   * [ ] create `tracker` (`BeginTrackFrameOpcode`)\n   * [!] push Updating Stack <- `guard`\n   * [!] push Updating Stack <- `tracker`\n   * [!] push Cache Stack <- `guard`\n   * [!] push Tracking Stack\n   */\n  beginCacheGroup(name?: string) {\n    let opcodes = this.updating();\n    let guard = new JumpIfNotModifiedOpcode();\n\n    opcodes.push(guard);\n    opcodes.push(new BeginTrackFrameOpcode(name));\n    this.#stacks.cache.push(guard);\n\n    beginTrackFrame(name);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `CommitComponentTransaction`\n   *\n   * ## State Changes\n   *\n   * Create a new `EndTrackFrameOpcode` (`end`)\n   *\n   * [!] pop CacheStack -> `guard`\n   * [!] pop Tracking Stack -> `tag`\n   * [ ] create `end` (`EndTrackFrameOpcode`) with `guard`\n   * [-] consume `tag`\n   */\n  commitCacheGroup() {\n    let opcodes = this.updating();\n    let guard = expect(this.#stacks.cache.pop(), 'VM BUG: Expected a cache group');\n\n    let tag = endTrackFrame();\n    opcodes.push(new EndTrackFrameOpcode(guard));\n\n    guard.finalize(tag, opcodes.length);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `Enter`\n   *\n   * ## State changes\n   *\n   * [!] push Element Stack as `block`\n   * [ ] create `try` (`TryOpcode`) with `block`, capturing `args` from the Eval Stack\n   *\n   * Did Enter (`try`):\n   * [-] associate destroyable `try`\n   * [!] push Destroyable Stack <- `try`\n   * [!] push Updating List <- `try`\n   * [!] push Updating Stack <- `try.children`\n   */\n  enter(args: number) {\n    let updating: UpdatingOpcode[] = [];\n\n    let state = this.capture(args);\n    let block = this.tree().pushResettableBlock();\n\n    let tryOpcode = new TryOpcode(state, this.context, block, updating);\n\n    this.didEnter(tryOpcode);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `Iterate`\n   * - Update: `ListBlock`\n   *\n   * ## State changes\n   *\n   * Create a new ref for the iterator item (`value`).\n   * Create a new ref for the iterator key (`key`).\n   *\n   * [ ] create `valueRef` (`Reference`) from `value`\n   * [ ] create `keyRef` (`Reference`) from `key`\n   * [!] push Eval Stack <- `valueRef`\n   * [!] push Eval Stack <- `keyRef`\n   * [!] push Element Stack <- `UpdatableBlock` as `block`\n   * [ ] capture `closure` with *2* items from the Eval Stack\n   * [ ] create `iteration` (`ListItemOpcode`) with `closure`, `block`, `key`, `keyRef` and `valueRef`\n   *\n   * Did Enter (`iteration`):\n   * [-] associate destroyable `iteration`\n   * [!] push Destroyable Stack <- `iteration`\n   * [!] push Updating List <- `iteration`\n   * [!] push Updating Stack <- `iteration.children`\n   */\n  enterItem({ key, value, memo }: OpaqueIterationItem): ListItemOpcode {\n    let { stack } = this;\n\n    let valueRef = createIteratorItemRef(value);\n    let memoRef = createIteratorItemRef(memo);\n\n    stack.push(valueRef);\n    stack.push(memoRef);\n\n    let state = this.capture(2);\n    let block = this.tree().pushResettableBlock();\n\n    let opcode = new ListItemOpcode(state, this.context, block, key, memoRef, valueRef);\n    this.didEnter(opcode);\n\n    return opcode;\n  }\n\n  registerItem(opcode: ListItemOpcode) {\n    this.listBlock().initializeChild(opcode);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `EnterList`\n   *\n   * ## State changes\n   *\n   * [ ] capture `closure` with *0* items from the Eval Stack, and `$pc` from `offset`\n   * [ ] create `updating` (empty `Array`)\n   * [!] push Element Stack <- `list` (`BlockList`) with `updating`\n   * [ ] create `list` (`ListBlockOpcode`) with `closure`, `list`, `updating` and `iterableRef`\n   * [!] push List Stack <- `list`\n   *\n   * Did Enter (`list`):\n   * [-] associate destroyable `list`\n   * [!] push Destroyable Stack <- `list`\n   * [!] push Updating List <- `list`\n   * [!] push Updating Stack <- `list.children`\n   */\n  enterList(iterableRef: Reference<OpaqueIterator>, offset: number) {\n    let updating: ListItemOpcode[] = [];\n\n    let addr = this.lowlevel.target(offset);\n    let state = this.capture(0, addr);\n    let list = this.tree().pushBlockList(updating) as AppendingBlockList;\n\n    let opcode = new ListBlockOpcode(state, this.context, list, updating, iterableRef);\n\n    this.#stacks.list.push(opcode);\n\n    this.didEnter(opcode);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `Enter`\n   * - Append: `Iterate`\n   * - Append: `EnterList`\n   * - Update: `ListBlock`\n   *\n   * ## State changes\n   *\n   * [-] associate destroyable `opcode`\n   * [!] push Destroyable Stack <- `opcode`\n   * [!] push Updating List <- `opcode`\n   * [!] push Updating Stack <- `opcode.children`\n   *\n   */\n  private didEnter(opcode: BlockOpcode) {\n    this.associateDestroyable(opcode);\n    this.#stacks.destroyable.push(opcode);\n    this.updateWith(opcode);\n    this.pushUpdating(opcode.children);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `Exit`\n   * - Append: `ExitList`\n   *\n   * ## State changes\n   *\n   * [!] pop Destroyable Stack\n   * [!] pop Element Stack\n   * [!] pop Updating Stack\n   */\n  exit() {\n    this.#stacks.destroyable.pop();\n    this.#tree.popBlock();\n    this.popUpdating();\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `ExitList`\n   *\n   * ## State changes\n   *\n   * Pop List:\n   * [!] pop Destroyable Stack\n   * [!] pop Element Stack\n   * [!] pop Updating Stack\n   *\n   * [!] pop List Stack\n   */\n  exitList() {\n    this.exit();\n    this.#stacks.list.pop();\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `RootScope`\n   * - Append: `VirtualRootScope`\n   *\n   * ## State changes\n   *\n   * [!] push Scope Stack\n   */\n  pushRootScope(size: number, owner: Owner): Scope {\n    let scope = ScopeImpl.sized(owner, size);\n    this.#stacks.scope.push(scope);\n    return scope;\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `ChildScope`\n   *\n   * ## State changes\n   *\n   * [!] push Scope Stack <- `child` of current Scope\n   */\n  pushChildScope() {\n    this.#stacks.scope.push(this.scope().child());\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `Yield`\n   *\n   * ## State changes\n   *\n   * [!] push Scope Stack <- `scope`\n   */\n  pushScope(scope: Scope) {\n    this.#stacks.scope.push(scope);\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `PopScope`\n   *\n   * ## State changes\n   *\n   * [!] pop Scope Stack\n   */\n  popScope() {\n    this.#stacks.scope.pop();\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `PushDynamicScope`\n   *\n   * ## State changes:\n   *\n   * [!] push Dynamic Scope Stack <- child of current Dynamic Scope\n   */\n  pushDynamicScope(): DynamicScope {\n    let child = this.dynamicScope().child();\n    this.#stacks.dynamicScope.push(child);\n    return child;\n  }\n\n  /**\n   * ## Opcodes\n   *\n   * - Append: `BindDynamicScope`\n   *\n   * ## State changes:\n   *\n   * [!] pop Dynamic Scope Stack `names.length` times\n   */\n  bindDynamicScope(names: string[]) {\n    let scope = this.dynamicScope();\n\n    for (const name of reverse(names)) {\n      scope.set(name, this.stack.pop<Reference>());\n    }\n  }\n\n  /**\n   * ## State changes\n   *\n   * - [!] push Updating Stack\n   *\n   * @utility\n   */\n  pushUpdating(list: UpdatingOpcode[] = []): void {\n    this.#stacks.updating.push(list);\n  }\n\n  /**\n   * ## State changes\n   *\n   * [!] pop Updating Stack\n   *\n   * @utility\n   */\n  popUpdating(): UpdatingOpcode[] {\n    return expect(this.#stacks.updating.pop(), \"can't pop an empty stack\");\n  }\n\n  /**\n   * ## State changes\n   *\n   * [!] push Updating List\n   *\n   * @utility\n   */\n  updateWith(opcode: UpdatingOpcode) {\n    this.updating().push(opcode);\n  }\n\n  private listBlock(): ListBlockOpcode {\n    return expect(this.#stacks.list.current, 'expected a list block');\n  }\n\n  /**\n   * ## State changes\n   *\n   * [-] associate destroyable `child`\n   *\n   * @utility\n   */\n  associateDestroyable(child: Destroyable): void {\n    let parent = expect(this.#stacks.destroyable.current, 'Expected destructor parent');\n    associateDestroyableChild(parent, child);\n  }\n\n  private updating(): UpdatingOpcode[] {\n    return expect(\n      this.#stacks.updating.current,\n      'expected updating opcode on the updating opcode stack'\n    );\n  }\n\n  /**\n   * Get Tree Builder\n   */\n  tree(): TreeBuilder {\n    return this.#tree;\n  }\n\n  /**\n   * Get current Scope\n   */\n  scope(): Scope {\n    return expect(this.#stacks.scope.current, 'expected scope on the scope stack');\n  }\n\n  /**\n   * Get current Dynamic Scope\n   */\n  dynamicScope(): DynamicScope {\n    return expect(\n      this.#stacks.dynamicScope.current,\n      'expected dynamic scope on the dynamic scope stack'\n    );\n  }\n\n  popDynamicScope() {\n    this.#stacks.dynamicScope.pop();\n  }\n\n  /// SCOPE HELPERS\n\n  getOwner(): Owner {\n    return this.scope().owner;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getSelf(): Reference<any> {\n    return this.scope().getSelf();\n  }\n\n  referenceForSymbol(symbol: number): Reference {\n    return this.scope().getSymbol(symbol);\n  }\n\n  /// EXECUTION\n\n  execute(initialize?: (vm: this) => void): RenderResult {\n    if (import.meta.env.DEV) {\n      let hasErrored = true;\n      try {\n        let value = this._execute(initialize);\n\n        // using a boolean here to avoid breaking ergonomics of \"pause on uncaught exceptions\"\n        // which would happen with a `catch` + `throw`\n        hasErrored = false;\n\n        return value;\n      } finally {\n        if (hasErrored) {\n          // If any existing blocks are open, due to an error or something like\n          // that, we need to close them all and clean things up properly.\n          let elements = this.tree();\n\n          while (elements.hasBlocks) {\n            elements.popBlock();\n          }\n\n          // eslint-disable-next-line no-console\n          console.error(`\\n\\nError occurred:\\n\\n${resetTracking()}\\n\\n`);\n        }\n      }\n    } else {\n      return this._execute(initialize);\n    }\n  }\n\n  private _execute(initialize?: (vm: this) => void): RenderResult {\n    if (LOCAL_TRACE_LOGGING) {\n      LOCAL_LOGGER.log(`EXECUTING FROM ${this.lowlevel.fetchRegister($pc)}`);\n    }\n\n    if (initialize) initialize(this);\n\n    let result: RichIteratorResult<null, RenderResult>;\n\n    do result = this.next();\n    while (!result.done);\n\n    return result.value;\n  }\n\n  next(): RichIteratorResult<null, RenderResult> {\n    let { env } = this;\n    let opcode = this.lowlevel.nextStatement();\n    let result: RichIteratorResult<null, RenderResult>;\n    if (opcode !== null) {\n      this.lowlevel.evaluateOuter(opcode, this);\n      result = { done: false, value: null };\n    } else {\n      // Unload the stack\n      this.stack.reset();\n\n      result = {\n        done: true,\n        value: new RenderResultImpl(\n          env,\n          this.popUpdating(),\n          this.#tree.popBlock(),\n          this.#stacks.drop\n        ),\n      };\n    }\n    return result;\n  }\n}\n\nfunction closureState(pc: number, scope: Scope, dynamicScope: DynamicScope): ClosureState {\n  return {\n    pc,\n    scope,\n    dynamicScope,\n    stack: [],\n  };\n}\n\nexport interface InitialVmState {\n  /**\n   * The address of the compiled template. This is converted into a\n   * pc when the VM is created.\n   */\n  handle: number;\n\n  /**\n   * Optionally, specify the root scope for the VM. If not specified,\n   * the VM will use a root scope with no `this` reference and no\n   * symbols.\n   */\n  scope?: ScopeOptions;\n  /**\n   *\n   */\n  tree: TreeBuilder;\n  dynamicScope: DynamicScope;\n  owner: Owner;\n}\n\nexport interface ClosureState {\n  /**\n   * The program counter that subsequent evaluations should start from.\n   */\n  readonly pc: number;\n\n  /**\n   * The current value of the VM's scope (which changes whenever a component is invoked or a block\n   * with block params is entered).\n   */\n  readonly scope: Scope;\n\n  /**\n   * The current value of the VM's dynamic scope\n   */\n  readonly dynamicScope: DynamicScope;\n\n  /**\n   * A number of stack elements captured during the initial evaluation, and which should be restored\n   * to the stack when the block is re-evaluated.\n   */\n  readonly stack: unknown[];\n}\n\n/**\n * A closure captures the state of the VM for a particular block of code that is necessary to\n * re-invoke the block in the future.\n *\n * In practice, this allows us to clear the previous render and \"replay\" the block's execution,\n * rendering content in the same position as the first render.\n */\nexport class Closure {\n  private state: ClosureState;\n  private context: EvaluationContext;\n\n  constructor(state: ClosureState, context: EvaluationContext) {\n    this.state = state;\n    this.context = context;\n  }\n\n  evaluate(tree: TreeBuilder): VM {\n    return new VM(this.state, this.context, tree);\n  }\n}\n\nfunction sliceTuple<T extends unknown[], Prefix extends unknown[]>(\n  tuple: T,\n  prefix: Prefix\n): T extends [...Prefix, ...infer Rest] ? Rest : never {\n  return tuple.slice(prefix.length) as T extends [...Prefix, ...infer Rest] ? Rest : never;\n}\n","import type {\n  CompilableProgram,\n  ComponentDefinitionState,\n  DynamicScope,\n  Environment,\n  EvaluationContext,\n  Owner,\n  RenderResult,\n  RichIteratorResult,\n  TemplateIterator,\n  TreeBuilder,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { dev, expect, unwrapHandle } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { childRefFor, createConstRef } from '@glimmer/reference';\nimport { debug } from '@glimmer/validator';\n\nimport { inTransaction } from './environment';\nimport { DynamicScopeImpl } from './scope';\nimport { VM } from './vm/append';\n\nclass TemplateIteratorImpl implements TemplateIterator {\n  constructor(private vm: VM) {}\n  next(): RichIteratorResult<null, RenderResult> {\n    return this.vm.next();\n  }\n\n  sync(): RenderResult {\n    if (import.meta.env.DEV) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      return debug.runInTrackingTransaction!(() => this.vm.execute(), '- While rendering:');\n    } else {\n      return this.vm.execute();\n    }\n  }\n}\n\nexport function renderSync(env: Environment, iterator: TemplateIterator): RenderResult {\n  let result: RenderResult;\n\n  inTransaction(env, () => (result = iterator.sync()));\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return result!;\n}\n\nexport function renderMain(\n  context: EvaluationContext,\n  owner: Owner,\n  self: Reference,\n  tree: TreeBuilder,\n  layout: CompilableProgram,\n  dynamicScope: DynamicScope = new DynamicScopeImpl()\n): TemplateIterator {\n  let handle = unwrapHandle(layout.compile(context));\n  let numSymbols = layout.symbolTable.symbols.length;\n\n  let vm = VM.initial(context, {\n    scope: {\n      self,\n      size: numSymbols,\n    },\n    dynamicScope,\n    tree,\n    handle,\n    owner,\n  });\n  return new TemplateIteratorImpl(vm);\n}\n\nfunction renderInvocation(\n  vm: VM,\n  context: EvaluationContext,\n  owner: Owner,\n  definition: ComponentDefinitionState,\n  args: Record<string, Reference>\n): TemplateIterator {\n  // Get a list of tuples of argument names and references, like\n  // [['title', reference], ['name', reference]]\n  const argList = Object.keys(args).map((key) => [key, args[key]] as const);\n\n  const blockNames = ['main', 'else', 'attrs'];\n  // Prefix argument names with `@` symbol\n  const argNames = argList.map(([name]) => `@${name}`);\n\n  let reified = vm.constants.component(definition, owner, undefined, '{ROOT}');\n\n  vm.lowlevel.pushFrame();\n\n  // Push blocks on to the stack, three stack values per block\n  for (let i = 0; i < 3 * blockNames.length; i++) {\n    vm.stack.push(null);\n  }\n\n  vm.stack.push(null);\n\n  // For each argument, push its backing reference on to the stack\n  argList.forEach(([, reference]) => {\n    vm.stack.push(reference);\n  });\n\n  // Configure VM based on blocks and args just pushed on to the stack.\n  vm.args.setup(vm.stack, argNames, blockNames, 0, true);\n\n  const compilable = expect(\n    reified.compilable,\n    'BUG: Expected the root component rendered with renderComponent to have an associated template, set with setComponentTemplate'\n  );\n  const layoutHandle = unwrapHandle(compilable.compile(context));\n  const invocation = { handle: layoutHandle, symbolTable: compilable.symbolTable };\n\n  // Needed for the Op.Main opcode: arguments, component invocation object, and\n  // component definition.\n  vm.stack.push(vm.args);\n  vm.stack.push(invocation);\n  vm.stack.push(reified);\n\n  if (LOCAL_DEBUG) {\n    dev(vm.trace).willCall(invocation.handle);\n  }\n\n  return new TemplateIteratorImpl(vm);\n}\n\nexport function renderComponent(\n  context: EvaluationContext,\n  tree: TreeBuilder,\n  owner: Owner,\n  definition: ComponentDefinitionState,\n  args: Record<string, unknown> = {},\n  dynamicScope: DynamicScope = new DynamicScopeImpl()\n): TemplateIterator {\n  let vm = VM.initial(context, { tree, handle: context.stdlib.main, dynamicScope, owner });\n  return renderInvocation(vm, context, owner, definition, recordToReference(args));\n}\n\nfunction recordToReference(record: Record<string, unknown>): Record<string, Reference> {\n  const root = createConstRef(record, 'args');\n\n  return Object.keys(record).reduce<Record<string, Reference>>((acc, key) => {\n    acc[key] = childRefFor(root, key);\n    return acc;\n  }, {});\n}\n","import type {\n  AttrNamespace,\n  Bounds,\n  Environment,\n  Maybe,\n  Nullable,\n  SimpleAttr,\n  SimpleComment,\n  SimpleElement,\n  SimpleNode,\n  SimpleText,\n  TreeBuilder,\n} from '@glimmer/interfaces';\nimport type { Stack } from '@glimmer/util';\nimport { COMMENT_NODE, ELEMENT_NODE, NS_SVG, TEXT_NODE } from '@glimmer/constants';\nimport { castToBrowser, castToSimple, expect, localAssert } from '@glimmer/debug-util';\n\nimport { ConcreteBounds, CursorImpl } from '../bounds';\nimport { NewTreeBuilder, RemoteBlock } from './element-builder';\n\nexport const SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';\n\nexport function isSerializationFirstNode(node: SimpleNode): boolean {\n  return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;\n}\n\nexport class RehydratingCursor extends CursorImpl {\n  candidate: Nullable<SimpleNode> = null;\n  openBlockDepth: number;\n  injectedOmittedNode = false;\n  constructor(\n    element: SimpleElement,\n    nextSibling: Nullable<SimpleNode>,\n    public readonly startingBlockDepth: number\n  ) {\n    super(element, nextSibling);\n    this.openBlockDepth = startingBlockDepth - 1;\n  }\n}\n\nexport class RehydrateTree extends NewTreeBuilder implements TreeBuilder {\n  private unmatchedAttributes: Nullable<SimpleAttr[]> = null;\n  declare cursors: Stack<RehydratingCursor>; // Hides property on base class\n  blockDepth = 0;\n  startingBlockOffset: number;\n\n  constructor(env: Environment, parentNode: SimpleElement, nextSibling: Nullable<SimpleNode>) {\n    super(env, parentNode, nextSibling);\n    if (nextSibling) throw new Error('Rehydration with nextSibling not supported');\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    let node = this.currentCursor!.element.firstChild;\n\n    while (node !== null) {\n      if (isOpenBlock(node)) {\n        break;\n      }\n      node = node.nextSibling;\n    }\n\n    localAssert(node, 'Must have opening comment for rehydration.');\n    this.candidate = node;\n    const startingBlockOffset = getBlockDepth(node);\n    if (startingBlockOffset !== 0) {\n      // We are rehydrating from a partial tree and not the root component\n      // We need to add an extra block before the first block to rehydrate correctly\n      // The extra block is needed since the renderComponent API creates a synthetic component invocation which generates the extra block\n      const newBlockDepth = startingBlockOffset - 1;\n      const newCandidate = this.dom.createComment(`%+b:${newBlockDepth}%`);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      node.parentNode!.insertBefore(newCandidate, this.candidate);\n      let closingNode = node.nextSibling;\n      while (closingNode !== null) {\n        if (isCloseBlock(closingNode) && getBlockDepth(closingNode) === startingBlockOffset) {\n          break;\n        }\n        closingNode = closingNode.nextSibling;\n      }\n\n      localAssert(closingNode, 'Must have closing comment for starting block comment');\n      const newClosingBlock = this.dom.createComment(`%-b:${newBlockDepth}%`);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      node.parentNode!.insertBefore(newClosingBlock, closingNode.nextSibling);\n      this.candidate = newCandidate;\n      this.startingBlockOffset = newBlockDepth;\n    } else {\n      this.startingBlockOffset = 0;\n    }\n  }\n\n  get currentCursor(): Nullable<RehydratingCursor> {\n    return this.cursors.current;\n  }\n\n  get candidate(): Nullable<SimpleNode> {\n    if (this.currentCursor) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      return this.currentCursor.candidate!;\n    }\n\n    return null;\n  }\n\n  set candidate(node: Nullable<SimpleNode>) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    const currentCursor = this.currentCursor!;\n\n    currentCursor.candidate = node;\n  }\n\n  disableRehydration(nextSibling: Nullable<SimpleNode>) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    const currentCursor = this.currentCursor!;\n\n    // rehydration will be disabled until we either:\n    // * hit popElement (and return to using the parent elements cursor)\n    // * hit closeBlock and the next sibling is a close block comment\n    //   matching the expected openBlockDepth\n    currentCursor.candidate = null;\n    currentCursor.nextSibling = nextSibling;\n  }\n\n  enableRehydration(candidate: Nullable<SimpleNode>) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    const currentCursor = this.currentCursor!;\n\n    currentCursor.candidate = candidate;\n    currentCursor.nextSibling = null;\n  }\n\n  override pushElement(\n    /** called from parent constructor before we initialize this */\n    this:\n      | RehydrateTree\n      | (NewTreeBuilder & Partial<Pick<RehydrateTree, 'blockDepth' | 'candidate'>>),\n    element: SimpleElement,\n    nextSibling: Maybe<SimpleNode> = null\n  ) {\n    const cursor = new RehydratingCursor(element, nextSibling, this.blockDepth || 0);\n\n    /**\n     * <div>   <---------------  currentCursor.element\n     *   <!--%+b:1%--> <-------  would have been removed during openBlock\n     *   <div> <---------------  currentCursor.candidate -> cursor.element\n     *     <!--%+b:2%--> <-----  currentCursor.candidate.firstChild -> cursor.candidate\n     *     Foo\n     *     <!--%-b:2%-->\n     *   </div>\n     *   <!--%-b:1%-->  <------  becomes currentCursor.candidate\n     */\n    if (this.candidate !== null) {\n      cursor.candidate = element.firstChild;\n      this.candidate = element.nextSibling;\n    }\n\n    this.cursors.push(cursor);\n  }\n\n  // clears until the end of the current container\n  // either the current open block or higher\n  private clearMismatch(candidate: SimpleNode) {\n    let current: Nullable<SimpleNode> = candidate;\n    const currentCursor = this.currentCursor;\n    if (currentCursor !== null) {\n      const openBlockDepth = currentCursor.openBlockDepth;\n      if (openBlockDepth >= currentCursor.startingBlockDepth) {\n        while (current) {\n          if (isCloseBlock(current)) {\n            const closeBlockDepth = getBlockDepthWithOffset(current, this.startingBlockOffset);\n            if (openBlockDepth >= closeBlockDepth) {\n              break;\n            }\n          }\n          current = this.remove(current);\n        }\n      } else {\n        while (current !== null) {\n          current = this.remove(current);\n        }\n      }\n      // current cursor parentNode should be openCandidate if element\n      // or openCandidate.parentNode if comment\n      this.disableRehydration(current);\n    }\n  }\n\n  override __openBlock(): void {\n    const { currentCursor } = this;\n    if (currentCursor === null) return;\n\n    const blockDepth = this.blockDepth;\n\n    this.blockDepth++;\n\n    const { candidate } = currentCursor;\n    if (candidate === null) return;\n\n    const { tagName } = currentCursor.element;\n\n    if (\n      isOpenBlock(candidate) &&\n      getBlockDepthWithOffset(candidate, this.startingBlockOffset) === blockDepth\n    ) {\n      this.candidate = this.remove(candidate);\n      currentCursor.openBlockDepth = blockDepth;\n    } else if (tagName !== 'TITLE' && tagName !== 'SCRIPT' && tagName !== 'STYLE') {\n      this.clearMismatch(candidate);\n    }\n  }\n\n  override __closeBlock(): void {\n    const { currentCursor } = this;\n    if (currentCursor === null) return;\n\n    // openBlock is the last rehydrated open block\n    const openBlockDepth = currentCursor.openBlockDepth;\n\n    // this currently is the expected next open block depth\n    this.blockDepth--;\n\n    const { candidate } = currentCursor;\n\n    let isRehydrating = false;\n\n    if (candidate !== null) {\n      isRehydrating = true;\n      //assert(\n      //  openBlockDepth === this.blockDepth,\n      //  'when rehydrating, openBlockDepth should match this.blockDepth here'\n      //);\n\n      if (\n        isCloseBlock(candidate) &&\n        getBlockDepthWithOffset(candidate, this.startingBlockOffset) === openBlockDepth\n      ) {\n        const nextSibling = this.remove(candidate);\n        this.candidate = nextSibling;\n        currentCursor.openBlockDepth--;\n      } else {\n        // close the block and clear mismatch in parent container\n        // we will be either at the end of the element\n        // or at the end of our containing block\n        this.clearMismatch(candidate);\n        isRehydrating = false;\n      }\n    }\n\n    if (!isRehydrating) {\n      // check if nextSibling matches our expected close block\n      // if so, we remove the close block comment and\n      // restore rehydration after clearMismatch disabled\n      const nextSibling = currentCursor.nextSibling;\n      if (\n        nextSibling !== null &&\n        isCloseBlock(nextSibling) &&\n        getBlockDepthWithOffset(nextSibling, this.startingBlockOffset) === this.blockDepth\n      ) {\n        // restore rehydration state\n        const candidate = this.remove(nextSibling);\n        this.enableRehydration(candidate);\n\n        currentCursor.openBlockDepth--;\n      }\n    }\n  }\n\n  override __appendNode(node: SimpleNode): SimpleNode {\n    const { candidate } = this;\n\n    // This code path is only used when inserting precisely one node. It needs more\n    // comparison logic, but we can probably lean on the cases where this code path\n    // is actually used.\n    if (candidate) {\n      return candidate;\n    } else {\n      return super.__appendNode(node);\n    }\n  }\n\n  override __appendHTML(html: string): Bounds {\n    const candidateBounds = this.markerBounds();\n\n    if (candidateBounds) {\n      const first = candidateBounds.firstNode();\n\n      const last = candidateBounds.lastNode();\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      const newBounds = new ConcreteBounds(this.element, first.nextSibling!, last.previousSibling!);\n\n      const possibleEmptyMarker = this.remove(first);\n      this.remove(last);\n\n      if (possibleEmptyMarker !== null && isEmpty(possibleEmptyMarker)) {\n        this.candidate = this.remove(possibleEmptyMarker);\n\n        if (this.candidate !== null) {\n          this.clearMismatch(this.candidate);\n        }\n      }\n\n      return newBounds;\n    } else {\n      return super.__appendHTML(html);\n    }\n  }\n\n  protected remove(node: SimpleNode): Nullable<SimpleNode> {\n    const element = expect(node.parentNode, `cannot remove a detached node`) as SimpleElement;\n    const next = node.nextSibling;\n    element.removeChild(node);\n    return next;\n  }\n\n  private markerBounds(): Nullable<Bounds> {\n    const _candidate = this.candidate;\n\n    if (_candidate && isMarker(_candidate)) {\n      const first = _candidate;\n      let last = expect(first.nextSibling, `BUG: serialization markers must be paired`);\n\n      while (!isMarker(last)) {\n        last = expect(last.nextSibling, `BUG: serialization markers must be paired`);\n      }\n\n      return new ConcreteBounds(this.element, first, last);\n    } else {\n      return null;\n    }\n  }\n\n  override __appendText(string: string): SimpleText {\n    const { candidate } = this;\n\n    if (candidate) {\n      if (isTextNode(candidate)) {\n        if (candidate.nodeValue !== string) {\n          candidate.nodeValue = string;\n        }\n        this.candidate = candidate.nextSibling;\n\n        return candidate;\n      } else if (isSeparator(candidate)) {\n        this.candidate = this.remove(candidate);\n\n        return this.__appendText(string);\n      } else if (isEmpty(candidate) && string === '') {\n        this.candidate = this.remove(candidate);\n\n        return this.__appendText(string);\n      } else {\n        this.clearMismatch(candidate);\n\n        return super.__appendText(string);\n      }\n    } else {\n      return super.__appendText(string);\n    }\n  }\n\n  override __appendComment(string: string): SimpleComment {\n    const _candidate = this.candidate;\n    if (_candidate && isComment(_candidate)) {\n      if (_candidate.nodeValue !== string) {\n        _candidate.nodeValue = string;\n      }\n\n      this.candidate = _candidate.nextSibling;\n      return _candidate;\n    } else if (_candidate) {\n      this.clearMismatch(_candidate);\n    }\n\n    return super.__appendComment(string);\n  }\n\n  override __openElement(tag: string): SimpleElement {\n    const _candidate = this.candidate;\n\n    if (_candidate && isElement(_candidate) && isSameNodeType(_candidate, tag)) {\n      this.unmatchedAttributes = [].slice.call(_candidate.attributes);\n      return _candidate;\n    } else if (_candidate) {\n      if (isElement(_candidate) && _candidate.tagName === 'TBODY') {\n        this.pushElement(_candidate, null);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        this.currentCursor!.injectedOmittedNode = true;\n        return this.__openElement(tag);\n      }\n      this.clearMismatch(_candidate);\n    }\n\n    return super.__openElement(tag);\n  }\n\n  override __setAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void {\n    const unmatched = this.unmatchedAttributes;\n\n    if (unmatched) {\n      const attr = findByName(unmatched, name);\n      if (attr) {\n        if (attr.value !== value) {\n          attr.value = value;\n        }\n        unmatched.splice(unmatched.indexOf(attr), 1);\n        return;\n      }\n    }\n\n    return super.__setAttribute(name, value, namespace);\n  }\n\n  override __setProperty(name: string, value: string): void {\n    const unmatched = this.unmatchedAttributes;\n\n    if (unmatched) {\n      const attr = findByName(unmatched, name);\n      if (attr) {\n        if (attr.value !== value) {\n          attr.value = value;\n        }\n        unmatched.splice(unmatched.indexOf(attr), 1);\n        return;\n      }\n    }\n\n    return super.__setProperty(name, value);\n  }\n\n  override __flushElement(parent: SimpleElement, constructing: SimpleElement): void {\n    const { unmatchedAttributes: unmatched } = this;\n    if (unmatched) {\n      for (const attr of unmatched) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        this.constructing!.removeAttribute(attr.name);\n      }\n      this.unmatchedAttributes = null;\n    } else {\n      super.__flushElement(parent, constructing);\n    }\n  }\n\n  override willCloseElement() {\n    const { candidate, currentCursor } = this;\n\n    if (candidate !== null) {\n      this.clearMismatch(candidate);\n    }\n\n    if (currentCursor && currentCursor.injectedOmittedNode) {\n      this.popElement();\n    }\n\n    super.willCloseElement();\n  }\n\n  getMarker(element: HTMLElement, guid: string): Nullable<SimpleNode> {\n    const marker = element.querySelector(`script[glmr=\"${guid}\"]`);\n    if (marker) {\n      return castToSimple(marker);\n    }\n    return null;\n  }\n\n  override __pushRemoteElement(\n    element: SimpleElement,\n    cursorId: string,\n    insertBefore: Maybe<SimpleNode>\n  ): RemoteBlock {\n    const marker = this.getMarker(castToBrowser(element, 'HTML'), cursorId);\n\n    localAssert(\n      !marker || marker.parentNode === element,\n      `expected remote element marker's parent node to match remote element`\n    );\n\n    // when insertBefore is not present, we clear the element\n    if (insertBefore === undefined) {\n      while (element.firstChild !== null && element.firstChild !== marker) {\n        this.remove(element.firstChild);\n      }\n      insertBefore = null;\n    }\n\n    const cursor = new RehydratingCursor(element, null, this.blockDepth);\n    this.cursors.push(cursor);\n\n    if (marker === null) {\n      this.disableRehydration(insertBefore);\n    } else {\n      this.candidate = this.remove(marker);\n    }\n\n    const block = new RemoteBlock(element);\n    return this.pushBlock(block, true);\n  }\n\n  override didAppendBounds(bounds: Bounds): Bounds {\n    super.didAppendBounds(bounds);\n    if (this.candidate) {\n      const last = bounds.lastNode();\n      this.candidate = last.nextSibling;\n    }\n    return bounds;\n  }\n}\n\nfunction isTextNode(node: SimpleNode): node is SimpleText {\n  return node.nodeType === TEXT_NODE;\n}\n\nfunction isComment(node: SimpleNode): node is SimpleComment {\n  return node.nodeType === COMMENT_NODE;\n}\n\nfunction isOpenBlock(node: SimpleNode): node is SimpleComment {\n  return node.nodeType === COMMENT_NODE && node.nodeValue.lastIndexOf('%+b:', 0) === 0;\n}\n\nfunction isCloseBlock(node: SimpleNode): node is SimpleComment {\n  return node.nodeType === COMMENT_NODE && node.nodeValue.lastIndexOf('%-b:', 0) === 0;\n}\n\nfunction getBlockDepth(node: SimpleComment): number {\n  return parseInt(node.nodeValue.slice(4), 10);\n}\n\nfunction getBlockDepthWithOffset(node: SimpleComment, offset: number): number {\n  return getBlockDepth(node) - offset;\n}\n\nfunction isElement(node: SimpleNode): node is SimpleElement {\n  return node.nodeType === ELEMENT_NODE;\n}\n\nfunction isMarker(node: SimpleNode): boolean {\n  return node.nodeType === COMMENT_NODE && node.nodeValue === '%glmr%';\n}\n\nfunction isSeparator(node: SimpleNode): boolean {\n  return node.nodeType === COMMENT_NODE && node.nodeValue === '%|%';\n}\n\nfunction isEmpty(node: SimpleNode): boolean {\n  return node.nodeType === COMMENT_NODE && node.nodeValue === '% %';\n}\n\nfunction isSameNodeType(candidate: SimpleElement, tag: string) {\n  if (candidate.namespaceURI === NS_SVG) {\n    return candidate.tagName === tag;\n  }\n  return candidate.tagName === tag.toUpperCase();\n}\n\nfunction findByName(array: SimpleAttr[], name: string): SimpleAttr | undefined {\n  for (const attr of array) {\n    if (attr.name === name) return attr;\n  }\n\n  return undefined;\n}\n\nexport function rehydrationBuilder(env: Environment, cursor: CursorImpl): TreeBuilder {\n  return RehydrateTree.forInitialRender(env, cursor);\n}\n"],"names":["NS_MATHML","NS_SVG","INSERT_AFTER_BEGIN","INSERT_BEFORE_END","castToSimple","node","nodeType","isDocument","unwrapHandle","handle","error","errors","Error","problem","span","start","end","unwrapTemplate","template","result","SIGN_BIT","decodeImmediate","num","decodePositive","decodeNegative","forEach","x","encodeNegative","encodePositive","validate","value","$s0","$s1","$sp","$fp","$ra","$pc","$t0","$t1","$v0","expected","APPEND_OPCODES","constructor","evaluateOpcode","Array","fill","add","name","evaluate","kind","this","syscall","vm","opcode","type","operation","isMachine","lowlevel","TYPE","Symbol","INNER","OWNER","ARGS","RESOLVED","CURRIED_VALUES","WeakSet","isCurriedValue","has","isCurriedType","CurriedValue","inner","owner","args","resolved","resolveCurriedValue","curriedValue","positional","named","definition","currentWrapper","curriedArgs","curriedNamed","curriedPositional","length","undefined","concat","unshift","curry","spec","DynamicScopeImpl","bucket","assign","get","key","set","reference","child","ScopeImpl","root","self","size","refs","UNDEFINED_REFERENCE","init","sized","slots","callerScope","snapshot","slice","getSelf","getSymbol","symbol","getBlock","block","bind","bindSelf","bindSymbol","bindBlock","bindCallerScope","scope","getCallerScope","index","RangeError","CursorImpl","element","nextSibling","ConcreteBounds","parentNode","first","last","parentElement","firstNode","lastNode","move","bounds","parent","current","next","insertBefore","clear","removeChild","hasCustomDebugRenderTreeLifecycle","manager","GUID","Ref","id","release","toString","label","DebugRenderTreeImpl","begin","reset","create","state","internalNode","Set","nodes","appendChild","enter","update","didRender","nodeFor","exit","willDestroy","commit","capture","captureRefs","roots","stack","toArray","ref","delete","isEmpty","pop","push","captured","captureNode","instance","captureTemplate","captureBounds","children","reifyArgsDebug","Stack","WeakMap","normalizeStringValue","String","isIndexable","isSafeString","isString","pushChildScope","popScope","pushDynamicScope","popDynamicScope","op1","other","constants","getValue","createConstRef","primitive","NULL_REFERENCE","TRUE_REFERENCE","FALSE_REFERENCE","createPrimitiveRef","register","op2","offset","position","fetchValue","dup","count","load","CheckSyscallRegister","fetch","_names","names","getArray","bindDynamicScope","_table","compile","table","pushFrame","pushScope","invokingScope","locals","parameters","localsCount","i","at","call","target","Boolean","valueForRef","isConstRef","goto","updateWith","Assert","comparison","peek","valueRef","createComputeRef","toBool","throw","AssertFilter","filter","JumpIfNotModifiedOpcode","finalize","tag","didModify","lastRevision","alwaysRevalidate","validateTag","consumeTag","valueForTag","CONSTANT_TAG","INITIAL","BeginTrackFrameOpcode","debugLabel","beginTrackFrame","EndTrackFrameOpcode","endTrackFrame","text","tree","appendText","appendComment","openElement","tagName","elementRef","insertBeforeRef","guidRef","guid","pushRemoteElement","associateDestroyable","env","debugRenderTree","createCapturedArgs","registerDestructor","popRemoteElement","operations","modifiers","flush","loadValue","flushElement","closeElement","modifier","scheduleInstallModifier","d","getDestroyable","isInteractive","getOwner","constructing","capturedArgs","addModifier","getTag","UpdateModifierOpcode","outerPositional","outerNamed","initialOwner","instanceRef","hostDefinition","resolvedDefinition","curriedOwner","Object","getInternalModifierManager","resolvedName","UpdateDynamicModifierOpcode","lastUpdated","scheduleUpdateModifier","CURRENT_TAG","newInstance","destroyable","destroy","associateDestroyableChild","_name","_value","op3","_namespace","namespace","setStaticAttribute","_trusting","trusting","attribute","setDynamicAttribute","UpdateDynamicAttributeOpcode","initialized","updateRef","capabilities","lookup","_isStrict","component","resolver","lookupComponent","resolvedComponent","resolveComponent","context","_blockNames","flags","positionalCount","atNames","blockNames","EMPTY_STRING_ARRAY","setup","empty","resolvedValue","merge","realloc","prepend","managerHasCapability","InternalComponentCapabilities","prepareArgs","blocks","values","preparedArgs","keys","createInstance","dynamicScope","hasDefaultBlock","createArgs","createCaller","updateHook","UpdateComponentOpcode","beginCacheGroup","pushAppendingBlock","ComponentElementOperations","setAttribute","deferred","classes","attributes","getDebugName","getDebugInstance","DebugRenderTreeUpdateOpcode","DebugRenderTreeDidRenderOpcode","attr","setDeferredAttr","mergeClasses","dict","every","c","allStringClasses","join","list","ret","symbolName","blockName","symbols","indexOf","didCreateElement","selfRef","moduleName","compilable","dynamicLayout","getDynamicLayout","getDebugCustomRenderTree","debugName","getTagName","wrapped","defaultTemplate","asWrappedLayout","asLayout","symbolTable","invocation","hasSubOwner","pushRootScope","callerNames","atName","enumerate","symbolNames","popBlock","EMPTY_ARGS","reverse","didRenderLayout","didCreate","DidUpdateLayoutOpcode","commitCacheGroup","_vm","didUpdateLayout","didUpdate","REFERENCE","VMArgumentsImpl","PositionalArgumentsImpl","NamedArgumentsImpl","BlockArgumentsImpl","base","registers","namedCount","namedBase","positionalBase","blocksCount","blocksBase","pos","newBase","copy","EMPTY_POSITIONAL","EMPTY_NAMED","EMPTY_REFERENCES","emptyArray","_references","references","additions","_atNames","map","toSyntheticName","toAtName","idx","newNames","toSymbolName","EMPTY_BLOCK_VALUES","internalValues","_symbolNames","internalTag","CapturedBlockArgumentsImpl","reifyNamed","reified","entries","reifyPositional","reifyArgs","ARGUMENT_ERROR","isArgumentError","arg","ArgumentErrorImpl","e","reifyNamedDebug","p","freeze","castToString","resolveHelper","helper","managerOrHelper","getInternalHelperManager","getHelper","debugAssert","isUndefinedReference","input","lastValue","curriedDefinition","createCurryRef","isStrict","helperRef","helperInstanceRef","resolvedDef","_hasDestroyableChildren","helperValueRef","expr","referenceForSymbol","_key","childRefFor","_block","handleOrCompilable","hasBlockParams","out","partsRefs","parts","condition","truthy","falsy","nameRef","console","log","DynamicTextContent","normalized","nodeValue","toContentType","shouldCoerce","ContentType","hasInternalComponentManager","Component","hasInternalHelperManager","Helper","SafeString","isFragment","Fragment","isNode","Node","toDynamicContentType","debugCallback","info","rawValue","appendDynamicHTML","toHTML","appendDynamicText","appendDynamicFragment","appendDynamicNode","callback","setDebuggerCallback","cb","resetDebuggerCallback","ScopeInspector","path","split","head","tail","reduce","r","part","_debugInfo","debuggerInfo","inspector","relativeStart","elseTarget","listRef","keyRef","keyValue","iteratorRef","createIteratorRef","iterator","enterList","exitList","breaks","item","registerItem","enterItem","CAPABILITIES","dynamicTag","attributeHook","elementHook","TemplateOnlyComponentManager","getCapabilities","TEMPLATE_ONLY_COMPONENT_MANAGER","TemplateOnlyComponentDefinition","templateOnlyComponent","setInternalComponentManager","prototype","SVG_INTEGRATION_POINTS","foreignObject","desc","title","BLACKLIST_TABLE","DOMOperations","document","setupUselessElement","uselessElement","createElement","isElementInSVGNamespace","isHTMLIntegrationPoint","isElementInMathMlNamespace","ns","namespaceURI","createElementNS","insertHTMLBefore","html","comment","createComment","prev","previousSibling","lastChild","insertAdjacentHTML","HTMLElement","firstChild","createTextNode","data","applySVGInnerHTMLFix","DOMClass","svgNamespace","svg","childNodes","shouldApplyFix","div","super","source","toUpperCase","wrappedHtml","clearElement","moveNodesBefore","fixSVG","applyTextNodeMergingFix","mergingTextDiv","uselessComment","didSetUselessComment","nextPrevious","Text","doc","appliedTreeConstruction","setAttributeNS","DOMTreeConstruction","WHITESPACE","isWhitespace","string","test","DOMChangesImpl","removeAttribute","insertAfter","DOMChanges","normalizeProperty","slotName","lower","toLowerCase","propName","ATTR_OVERRIDES","preferAttr","INPUT","form","autocorrect","SELECT","OPTION","TEXTAREA","LABEL","FIELDSET","LEGEND","OBJECT","OUTPUT","BUTTON","TRANSACTION","TransactionImpl","createdComponents","updatedComponents","scheduledInstallModifiers","scheduledUpdateModifiers","modifierTag","track","install","updateTag","EnvironmentImpl","options","delegate","enableDebugTooling","DebugRenderTree","isArgumentCaptureError","appendOperations","updateOperations","getAppendOperations","getDOM","transaction","onTransactionCommit","runtimeOptions","artifacts","program","ProgramImpl","heap","inTransaction","internalHelper","setInternalHelperManager","array","normalizeTextValue","fn","callbackRef","invocationArgs","isInvokableRef","sourceRef","pathRef","isDict","getPath","setPath","hash","Map","getArgs","proxy","argsCache","SimpleArgsProxy","computeArgs","createCache","invokeHelper","getDelegateFor","cache","createHelper","hasValue","hasDestroyable","OnModifierState","createUpdatableTag","listener","eventName","removeEventListener","updateListener","once","passive","userProvidedCallback","_once","_passive","_capture","shouldUpdate","adds","addEventListener","removes","on","setInternalModifierManager","counters","_owner","_state","LowLevelVM","externs","currentOpSize","fetchRegister","loadRegister","setPc","pc","popFrame","pushSmallFrame","popSmallFrame","getaddr","returnTo","return","nextStatement","operationSize","evaluateOuter","evaluateInner","evaluateMachine","evaluateSyscall","badProtocols","badTags","badTagsForDataURI","badAttributes","badAttributesForDataURI","checkURI","checkDataURI","requiresSanitization","_protocolForUrlImplementation","sanitizeAttributeValue","str","protocol","url","weirdURL","URL","parse","nodeURL","_url","findProtocolForURL","dynamicAttribute","buildDynamicAttribute","SafeDynamicProperty","isUserInputValue","InputValueDynamicAttribute","isOptionSelected","OptionSelectedDynamicAttribute","DefaultDynamicProperty","buildDynamicProperty","SafeDynamicAttribute","SimpleDynamicAttribute","DynamicAttribute","dom","_env","normalizedValue","normalizeValue","__setAttribute","normalizedName","__setProperty","removeAttributeNS","sanitized","currentValue","selected","First","Last","NewTreeBuilder","forInitialRender","cursor","initialize","resume","pushBlock","cursors","modifierStack","blockStack","pushElement","debugBlocks","hasBlocks","popElement","AppendingBlockImpl","pushResettableBlock","ResettableBlockImpl","pushBlockList","AppendingBlockList","isRemote","didAppendBounds","__openBlock","__closeBlock","__openElement","__flushElement","pushModifiers","didOpenElement","willCloseElement","popModifiers","__pushRemoteElement","_guid","RemoteBlock","didAppendNode","__appendText","__appendNode","__appendFragment","fragment","__appendComment","__appendHTML","trustedContent","untrustedContent","nesting","boundList","_element","_node","_bounds","_stack","clientBuilder","UpdatingVM","frameStack","execute","opcodes","handler","_execute","try","frame","ops","UpdatingVMFrame","handleException","BlockOpcode","TryOpcode","destroyChildren","pushUpdating","drop","ListItemOpcode","memo","retained","shouldRemove","ListBlockOpcode","iterableRef","opcodeMap","marker","lastIterator","initializeChild","sync","itemMap","currentOpcodeIndex","seenIndex","retainItem","itemOpcode","moveItem","seenUnretained","insertItem","deleteItem","before","elementStack","currentSibling","moveBounds","exceptionHandler","RenderResultImpl","updating","rerender","EvaluationStackImpl","restore","from","to","n","top","items","Stacks","VM","stacks","isLowLevelRegister","evalStack","initial","closureState","captureClosure","Closure","guard","tryOpcode","didEnter","createIteratorItemRef","memoRef","listBlock","addr","popUpdating","done","TemplateIteratorImpl","renderSync","renderMain","layout","numSymbols","renderComponent","argList","argNames","renderInvocation","stdlib","main","record","acc","recordToReference","SERIALIZATION_FIRST_NODE_STRING","isSerializationFirstNode","RehydratingCursor","startingBlockDepth","candidate","injectedOmittedNode","openBlockDepth","RehydrateTree","unmatchedAttributes","blockDepth","currentCursor","isOpenBlock","startingBlockOffset","getBlockDepth","newBlockDepth","newCandidate","closingNode","isCloseBlock","newClosingBlock","disableRehydration","enableRehydration","clearMismatch","getBlockDepthWithOffset","remove","isRehydrating","candidateBounds","markerBounds","newBounds","possibleEmptyMarker","_candidate","isMarker","isElement","isSameNodeType","unmatched","findByName","splice","getMarker","querySelector","cursorId","lastIndexOf","parseInt","rehydrationBuilder"],"mappings":"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"}