import{scheduleRevalidate as t}from"@glimmer/global-context";const e={},n=0,i=1,s=NaN;let l=1;function r(){l++}const a=Symbol("TAG_COMPUTE");function o(t){return t[a]()}function u(t,e){return e>=t[a]()}Reflect.set(globalThis,"COMPUTE_SYMBOL",a);const c=Symbol("TAG_TYPE");let h;class f{static combine(t){switch(t.length){case 0:return m;case 1:return t[0];default:{let e=new f(2);return e.subtag=t,e}}}constructor(t){this.revision=1,this.lastChecked=1,this.lastValue=1,this.isUpdating=!1,this.subtag=null,this.subtagBufferCache=null,this[c]=t}[a](){let{lastChecked:t}=this;if(this.isUpdating)this.lastChecked=++l;else if(t!==l){this.isUpdating=!0,this.lastChecked=l;try{let{subtag:t,revision:e}=this;if(null!==t)if(Array.isArray(t))for(const n of t){let t=n[a]();e=Math.max(t,e)}else{let n=t[a]();n===this.subtagBufferCache?e=Math.max(e,this.lastValue):(this.subtagBufferCache=null,e=Math.max(e,n))}this.lastValue=e}finally{this.isUpdating=!1}}return this.lastValue}static updateTag(t,e){let n=t,i=e;i===m?n.subtag=null:(n.subtagBufferCache=i[a](),n.subtag=i)}static dirtyTag(e,n){e.revision=++l,t()}}const d=f.dirtyTag,g=f.updateTag;function p(){return new f(0)}function b(){return new f(1)}const m=new f(3);function y(t){return t===m}class v{[a](){return NaN}constructor(){this[c]=100}}const T=new v;class w{[a](){return l}constructor(){this[c]=101}}const S=new w,A=f.combine;let M=b(),k=b(),C=b();o(M),d(M),o(M),g(M,A([k,C])),o(M),d(k),o(M),d(C),o(M),g(M,C),o(M),d(C),o(M);const E=new WeakMap;function N(t,e,n){let i=void 0===n?E.get(t):n;if(void 0===i)return;let s=i.get(e);void 0!==s&&d(s,!0)}function R(t){let e=E.get(t);return void 0===e&&(e=new Map,E.set(t,e)),e}function U(t,e,n){let i=void 0===n?R(t):n,s=i.get(e);return void 0===s&&(s=b(),i.set(e,s)),s}class x{add(t){t!==m&&(this.tags.add(t),this.last=t)}combine(){let{tags:t}=this;return 0===t.size?m:1===t.size?this.last:A(Array.from(this.tags))}constructor(){this.tags=new Set,this.last=null}}let O=null;const V=[];function _(){V.push(O),O=new x}function B(){let t=O;return O=V.pop()||null,function(t){if(null==t)throw new Error("Expected value to be present");return t}(t).combine()}function G(){V.push(O),O=null}function I(){O=V.pop()||null}function L(){for(;V.length>0;)V.pop();O=null}function P(){return null!==O}function Y(t){null!==O&&O.add(t)}const z=Symbol("FN"),W=Symbol("LAST_VALUE"),D=Symbol("TAG"),F=Symbol("SNAPSHOT");function H(t){return{[z]:t,[W]:void 0,[D]:void 0,[F]:-1}}function j(t){let e=t[z],n=t[D],i=t[F];if(void 0!==n&&u(n,i))Y(n);else{_();try{t[W]=e()}finally{n=B(),t[D]=n,t[F]=o(n),Y(n)}}return t[W]}function q(t){return y(t[D])}function J(t){let e;_();try{t()}finally{e=B()}return e}function K(t){G();try{return t()}finally{I()}}function Q(t,e){let n=new WeakMap,i="function"==typeof e;return{getter:function(s){let l;return Y(U(s,t)),i&&!n.has(s)?(l=e.call(s),n.set(s,l)):l=n.get(s),l},setter:function(e,i){N(e,t),n.set(e,i)}}}const X=Symbol("GLIMMER_VALIDATOR_REGISTRATION");if(Reflect.has(globalThis,X))throw new Error("The `@glimmer/validator` library has been included twice in this application. It could be different versions of the package, or the same version included twice by mistake. `@glimmer/validator` depends on having a single copy of the package in use at any time in an application, even if they are the same version. You must dedupe your build to remove the duplicate packages in order to prevent this error.");Reflect.set(globalThis,X,!0);export{h as ALLOW_CYCLES,a as COMPUTE,n as CONSTANT,m as CONSTANT_TAG,S as CURRENT_TAG,w as CurrentTag,i as INITIAL,s as VOLATILE,T as VOLATILE_TAG,v as VolatileTag,_ as beginTrackFrame,G as beginUntrackFrame,r as bump,A as combine,Y as consumeTag,H as createCache,p as createTag,b as createUpdatableTag,e as debug,d as dirtyTag,N as dirtyTagFor,B as endTrackFrame,I as endUntrackFrame,j as getValue,q as isConst,y as isConstTag,P as isTracking,L as resetTracking,U as tagFor,R as tagMetaFor,J as track,Q as trackedData,K as untrack,g as updateTag,u as validateTag,o as valueForTag};
//# sourceMappingURL=index.js.map
