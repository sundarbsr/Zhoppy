{"version":3,"file":"ast-transform.js","sourceRoot":"","sources":["ast-transform.ts"],"names":[],"mappings":"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","sourcesContent":["import literal from './literal';\nimport getConfig from './get-config';\nimport dependencySatisfies from './dependency-satisfies';\nimport { maybeAttrs } from './macro-maybe-attrs';\nimport {\n  macroIfBlock,\n  macroIfExpression,\n  macroIfMustache,\n  macroUnlessBlock,\n  macroUnlessExpression,\n  macroUnlessMustache,\n} from './macro-condition';\nimport { failBuild } from './fail-build';\nimport { RewrittenPackageCache } from '@embroider/shared-internals';\n\nexport interface BuildPluginParams {\n  // Glimmer requires this on ast transforms.\n  name: string;\n\n  // this is the location of @embroider/macros itself. Glimmer requires this on\n  // ast transforms.\n  baseDir: string;\n\n  methodName: string;\n\n  firstTransformParams: FirstTransformParams;\n}\n\nexport interface FirstTransformParams {\n  // this is the location of the particular package (app or addon) that is\n  // depending on @embroider/macros *if* we're in a classic build. Under\n  // embroider the build is global and there's no single packageRoot.\n  packageRoot: string | undefined;\n\n  // this is the path to the topmost package\n  appRoot: string;\n\n  // this holds all the actual user configs that were sent into the macros\n  configs: { [packageRoot: string]: object };\n}\n\nexport function buildPlugin(params: BuildPluginParams) {\n  return {\n    name: params.name,\n    plugin:\n      params.methodName === 'makeFirstTransform'\n        ? makeFirstTransform(params.firstTransformParams)\n        : makeSecondTransform(),\n    baseDir: () => params.baseDir,\n  };\n}\n\nexport function makeFirstTransform(opts: FirstTransformParams) {\n  function embroiderFirstMacrosTransform(env: {\n    syntax: { builders: any };\n    meta: { moduleName: string };\n    filename: string;\n  }) {\n    if (!opts.packageRoot && !env.filename) {\n      throw new Error(`bug in @embroider/macros. Running without packageRoot but don't have filename.`);\n    }\n\n    let packageCache = RewrittenPackageCache.shared('embroider', opts.appRoot);\n\n    let scopeStack: string[][] = [];\n\n    // packageRoot is set when we run inside classic ember-cli. Otherwise we're in\n    // Embroider, where we can use absolute filenames.\n    const moduleName = opts.packageRoot ? env.meta.moduleName : env.filename;\n\n    return {\n      name: '@embroider/macros/first',\n\n      visitor: {\n        ...scopeVisitors(env, scopeStack),\n        SubExpression(node: any, walker: { parent: { node: any } }) {\n          if (node.path.type !== 'PathExpression') {\n            return;\n          }\n\n          if (inScope(scopeStack, headOf(node.path))) {\n            return;\n          }\n\n          if (node.path.original === 'macroGetOwnConfig') {\n            return literal(\n              getConfig(node, opts.configs, opts.packageRoot, moduleName, true, packageCache),\n              env.syntax.builders\n            );\n          }\n          if (node.path.original === 'macroGetConfig') {\n            return literal(\n              getConfig(node, opts.configs, opts.packageRoot, moduleName, false, packageCache),\n              env.syntax.builders\n            );\n          }\n          if (node.path.original === 'macroDependencySatisfies') {\n            const staticValue = literal(\n              dependencySatisfies(node, opts.packageRoot, moduleName, packageCache),\n              env.syntax.builders\n            );\n            // If this is a macro expression by itself, then turn it into a macroCondition for the second pass to prune.\n            // Otherwise assume it's being composed with another macro and evaluate it as a literal\n            if (walker.parent.node.path.original === 'if') {\n              return env.syntax.builders.sexpr('macroCondition', [staticValue]);\n            }\n            return staticValue;\n          }\n        },\n        MustacheStatement(node: any) {\n          if (node.path.type !== 'PathExpression') {\n            return;\n          }\n\n          if (inScope(scopeStack, headOf(node.path))) {\n            return;\n          }\n          if (node.path.original === 'macroGetOwnConfig') {\n            return env.syntax.builders.mustache(\n              literal(\n                getConfig(node, opts.configs, opts.packageRoot, moduleName, true, packageCache),\n                env.syntax.builders\n              )\n            );\n          }\n          if (node.path.original === 'macroGetConfig') {\n            return env.syntax.builders.mustache(\n              literal(\n                getConfig(node, opts.configs, opts.packageRoot, moduleName, false, packageCache),\n                env.syntax.builders\n              )\n            );\n          }\n          if (node.path.original === 'macroDependencySatisfies') {\n            return env.syntax.builders.mustache(\n              literal(dependencySatisfies(node, opts.packageRoot, moduleName, packageCache), env.syntax.builders)\n            );\n          }\n        },\n      },\n    };\n  }\n  (embroiderFirstMacrosTransform as any).embroiderMacrosASTMarker = true;\n  (embroiderFirstMacrosTransform as any).parallelBabel = {\n    requireFile: __filename,\n    buildUsing: 'makeFirstTransform',\n    get params(): FirstTransformParams {\n      return opts;\n    },\n  };\n  return embroiderFirstMacrosTransform;\n}\n\nexport function makeSecondTransform() {\n  function embroiderSecondMacrosTransform(env: { syntax: { builders: any } }) {\n    let scopeStack: string[][] = [];\n    return {\n      name: '@embroider/macros/second',\n\n      visitor: {\n        ...scopeVisitors(env, scopeStack),\n        BlockStatement(node: any) {\n          if (node.path.type !== 'PathExpression') {\n            return;\n          }\n\n          if (inScope(scopeStack, headOf(node.path))) {\n            return;\n          }\n          if (node.path.original === 'if') {\n            return macroIfBlock(node);\n          }\n          if (node.path.original === 'unless') {\n            return macroUnlessBlock(node);\n          }\n        },\n        SubExpression(node: any) {\n          if (node.path.type !== 'PathExpression') {\n            return;\n          }\n\n          if (inScope(scopeStack, headOf(node.path))) {\n            return;\n          }\n          if (node.path.original === 'if') {\n            return macroIfExpression(node, env.syntax.builders);\n          }\n          if (node.path.original === 'unless') {\n            return macroUnlessExpression(node, env.syntax.builders);\n          }\n          if (node.path.original === 'macroFailBuild') {\n            failBuild(node);\n          }\n        },\n        ElementNode(node: any) {\n          node.modifiers = node.modifiers.filter((modifier: any) => {\n            if (\n              modifier.path.type === 'SubExpression' &&\n              modifier.path.path.type === 'PathExpression' &&\n              modifier.path.path.original === 'if'\n            ) {\n              modifier.path = macroIfExpression(modifier.path, env.syntax.builders);\n              if (modifier.path.type === 'UndefinedLiteral') {\n                return false;\n              }\n            }\n            if (\n              modifier.path.type === 'SubExpression' &&\n              modifier.path.path.type === 'PathExpression' &&\n              modifier.path.path.original === 'unless'\n            ) {\n              modifier.path = macroUnlessExpression(modifier.path, env.syntax.builders);\n              if (modifier.path.type === 'UndefinedLiteral') {\n                return false;\n              }\n            }\n            if (modifier.path.type !== 'PathExpression') {\n              return true;\n            }\n\n            if (inScope(scopeStack, headOf(node.path))) {\n              return true;\n            }\n            if (modifier.path.original === 'macroMaybeAttrs') {\n              maybeAttrs(node, modifier, env.syntax.builders);\n            } else {\n              return true;\n            }\n          });\n        },\n        MustacheStatement(node: any) {\n          if (node.path.type !== 'PathExpression') {\n            return;\n          }\n\n          if (inScope(scopeStack, headOf(node.path))) {\n            return;\n          }\n          if (node.path.original === 'if') {\n            return macroIfMustache(node, env.syntax.builders);\n          }\n          if (node.path.original === 'unless') {\n            return macroUnlessMustache(node, env.syntax.builders);\n          }\n          if (node.path.original === 'macroFailBuild') {\n            failBuild(node);\n          }\n        },\n      },\n    };\n  }\n  (embroiderSecondMacrosTransform as any).embroiderMacrosASTMarker = true;\n  (embroiderSecondMacrosTransform as any).parallelBabel = {\n    requireFile: __filename,\n    buildUsing: 'makeSecondTransform',\n    params: undefined,\n  };\n  return embroiderSecondMacrosTransform;\n}\n\nfunction inScope(scopeStack: string[][], name: string) {\n  for (let scope of scopeStack) {\n    if (scope.includes(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction headOf(path: any) {\n  if (!path) return;\n\n  return 'head' in path ? path.head.name : path.parts[0];\n}\n\nfunction scopeVisitors(env: any, scopeStack: string[][]) {\n  function enter(node: any) {\n    if (node.blockParams.length > 0) {\n      scopeStack.push(node.blockParams);\n    }\n  }\n  function exit(node: any) {\n    if (node.blockParams.length > 0) {\n      scopeStack.pop();\n    }\n  }\n\n  let hasTemplate = 'template' in env.syntax.builders;\n  if (hasTemplate) {\n    return {\n      Template: { enter, exit },\n      Block: { enter, exit },\n    };\n  } else {\n    return {\n      Program: { enter, exit },\n    };\n  }\n}\n"]}