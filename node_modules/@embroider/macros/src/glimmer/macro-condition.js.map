{"version":3,"file":"macro-condition.js","sourceRoot":"","sources":["macro-condition.ts"],"names":[],"mappings":"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","sourcesContent":["import evaluate from './evaluate';\n\nexport function macroIfBlock(node: any) {\n  let condition = node.params[0];\n\n  if (!condition || condition.type !== 'SubExpression' || condition.path.original !== 'macroCondition') {\n    return node;\n  }\n\n  if (condition.params.length !== 1) {\n    throw new Error(`macroCondition requires one arguments, you passed ${node.params.length}`);\n  }\n\n  let result = evaluate(condition.params[0]);\n  if (!result.confident) {\n    throw new Error(`argument to macroCondition must be statically analyzable`);\n  }\n\n  if (result.value) {\n    return node.program.body;\n  } else {\n    if (node.inverse) {\n      return node.inverse.body;\n    } else {\n      return [];\n    }\n  }\n}\n\nexport function macroIfExpression(node: any, builders: any) {\n  let condition = node.params[0];\n\n  if (!condition || condition.type !== 'SubExpression' || condition.path.original !== 'macroCondition') {\n    return node;\n  }\n\n  if (condition.params.length !== 1) {\n    throw new Error(`macroCondition requires one arguments, you passed ${node.params.length}`);\n  }\n\n  let result = evaluate(condition.params[0]);\n  if (!result.confident) {\n    throw new Error(`argument to macroCondition must be statically analyzable`);\n  }\n\n  if (result.value) {\n    return node.params[1];\n  } else {\n    return node.params[2] || builders.undefined();\n  }\n}\n\nexport function macroIfMustache(node: any, builders: any) {\n  let result = macroIfExpression(node, builders);\n\n  if (result === node) {\n    return node;\n  }\n\n  if (result.type === 'SubExpression') {\n    return builders.mustache(result.path, result.params, result.hash);\n  }\n\n  return builders.mustache(result);\n}\n\nexport function macroUnlessBlock(node: any) {\n  let condition = node.params[0];\n\n  if (!condition || condition.type !== 'SubExpression' || condition.path.original !== 'macroCondition') {\n    return node;\n  }\n\n  if (condition.params.length !== 1) {\n    throw new Error(`macroCondition requires one arguments, you passed ${node.params.length}`);\n  }\n\n  let result = evaluate(condition.params[0]);\n  if (!result.confident) {\n    throw new Error(`argument to macroCondition must be statically analyzable`);\n  }\n\n  if (result.value) {\n    if (node.inverse) {\n      return node.inverse.body;\n    } else {\n      return [];\n    }\n  } else {\n    return node.program.body;\n  }\n}\n\nexport function macroUnlessExpression(node: any, builders: any) {\n  let condition = node.params[0];\n\n  if (!condition || condition.type !== 'SubExpression' || condition.path.original !== 'macroCondition') {\n    return node;\n  }\n\n  if (condition.params.length !== 1) {\n    throw new Error(`macroCondition requires one arguments, you passed ${node.params.length}`);\n  }\n\n  let result = evaluate(condition.params[0]);\n  if (!result.confident) {\n    throw new Error(`argument to macroCondition must be statically analyzable`);\n  }\n\n  if (result.value) {\n    return node.params[2] || builders.undefined();\n  } else {\n    return node.params[1];\n  }\n}\n\nexport function macroUnlessMustache(node: any, builders: any) {\n  let result = macroUnlessExpression(node, builders);\n\n  if (result === node) {\n    return node;\n  }\n\n  if (result.type === 'SubExpression') {\n    return builders.mustache(result.path, result.params, result.hash);\n  }\n\n  return builders.mustache(result);\n}\n"]}