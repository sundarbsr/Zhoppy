{"version":3,"file":"symbols.js","sources":["../src/symbols.ts"],"sourcesContent":["import { getOrSetGlobal } from './-private';\n\n/*\n * @module @warp-drive/core-types\n */\nexport const RecordStore: '___(unique) Symbol(Store)' = getOrSetGlobal('Store', Symbol('Store'));\n\n/**\n * Symbol for the name of a resource, transformation\n * or derivation.\n *\n * ### With Resources\n *\n * This is an optional feature that can be used by\n * record implementations to provide a typescript\n * hint for the type of the resource.\n *\n * When used, EmberData and WarpDrive APIs can\n * take advantage of this to provide better type\n * safety and intellisense.\n *\n * ### With Derivations\n *\n * Required for derivations registered with\n * `store.registerDerivation(derivation)`.\n *\n * ```ts\n * function concat(record: object, options: ObjectValue | null, prop: string): string {}\n * concat[Name] = 'concat';\n * ```\n *\n * ### With Transforms\n *\n * Required for new-style transformations registered\n * with `store.registerTransform(transform)`.\n *\n * For legacy transforms, if not used,\n * `attr<Transform>('name')` will allow any string name.\n * `attr('name')` will always allow any string name.\n *\n * If used, `attr<Transform>('name')` will enforce\n * that the name is the same as the transform name.\n *\n * @type {Symbol}\n * @typedoc\n */\nexport const Type: '___(unique) Symbol($type)' = getOrSetGlobal('$type', Symbol('$type'));\n\n/**\n * Symbol for the type of a resource.\n *\n * This is an optional feature that can be used by\n * record implementations to provide a typescript\n * hint for the type of the resource.\n *\n * When used, EmberData and WarpDrive APIs can\n * take advantage of this to provide better type\n * safety and intellisense.\n *\n * @type {Symbol}\n * @typedoc\n */\nexport const ResourceType: '___(unique) Symbol($type)' = Type;\n\n/**\n * Symbol for the name of a transform.\n *\n * This is an optional feature that can be used by\n * transform implementations to provide a typescript\n * hint for the name of the transform.\n *\n * If not used, `attr<Transform>('name')` will\n * allow any string name. `attr('name')` will always\n * allow any string name.\n *\n * If used, `attr<Transform>('name')` will enforce\n * that the name is the same as the transform name.\n *\n * @type {Symbol}\n * @typedoc\n */\nexport const TransformName: '___(unique) Symbol($type)' = Type;\n\n/**\n * Symbol for use by builders to indicate the return type\n * generic to use for store.request()\n *\n * @type {Symbol}\n * @typedoc\n */\nexport const RequestSignature: '___(unique) Symbol(RequestSignature)' = getOrSetGlobal(\n  'RequestSignature',\n  Symbol('RequestSignature')\n);\n"],"names":["RecordStore","getOrSetGlobal","Symbol","Type","ResourceType","TransformName","RequestSignature"],"mappings":";;AAEA;AACA;AACA;AACO,MAAMA,WAAwC,GAAGC,cAAc,CAAC,OAAO,EAAEC,MAAM,CAAC,OAAO,CAAC;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,IAAiC,GAAGF,cAAc,CAAC,OAAO,EAAEC,MAAM,CAAC,OAAO,CAAC;;AAExF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAME,YAAyC,GAAGD;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAME,aAA0C,GAAGF;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMG,gBAAwD,GAAGL,cAAc,CACpF,kBAAkB,EAClBC,MAAM,CAAC,kBAAkB,CAC3B;;;;"}