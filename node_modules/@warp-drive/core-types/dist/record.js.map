{"version":3,"file":"record.js","sources":["../src/record.ts"],"sourcesContent":["/*\n * @module @warp-drive/core-types\n */\nimport type { Type } from './symbols';\n\n/**\n * Records may be anything, They don't even\n * have to be objects.\n *\n * Whatever they are, if they have a Type\n * property, that property will be used by EmberData\n * and WarpDrive to provide better type safety and\n * intellisense.\n *\n * @class TypedRecordInstance\n * @typedoc\n */\nexport interface TypedRecordInstance {\n  /**\n   * The type of the resource.\n   *\n   * This is an optional feature that can be used by\n   * record implementations to provide a typescript\n   * hint for the type of the resource.\n   *\n   * When used, EmberData and WarpDrive APIs can\n   * take advantage of this to provide better type\n   * safety and intellisense.\n   *\n   * @property {Type} [Type]\n   * @type {string}\n   * @typedoc\n   */\n  [Type]: string;\n}\n\n/**\n * A type utility that extracts the Type if available,\n * otherwise it returns never.\n *\n * @typedoc\n */\nexport type TypeFromInstance<T> = T extends TypedRecordInstance ? T[typeof Type] : never;\n\n/**\n * A type utility that extracts the Type if available,\n * otherwise it returns string\n *\n * @typedoc\n */\nexport type TypeFromInstanceOrString<T> = T extends TypedRecordInstance ? T[typeof Type] : string;\n\ntype IsUniqueSymbol<T> = T extends `___(unique) Symbol(${string})` ? true : false;\ntype Unpacked<T> = T extends (infer U)[] ? U : T;\ntype NONE = { __NONE: never };\n\ntype __InternalExtract<\n  MAX_DEPTH extends _DEPTHCOUNT,\n  T extends TypedRecordInstance,\n  V extends TypedRecordInstance,\n  IncludePrefix extends boolean,\n  Ignore,\n  Pre extends string,\n  DEPTH extends _DEPTHCOUNT,\n> =\n  // if we extend T, we return the leaf value\n  V extends T\n    ? IncludePrefix extends false\n      ? V[typeof Type]\n      : Pre\n    : // else if we are in Ignore we add the lead and exit\n      V extends Ignore\n      ? IncludePrefix extends false\n        ? V[typeof Type]\n        : Pre\n      : // else if we are at max depth, we return never\n        IS_MAX_DEPTH<DEPTH, MAX_DEPTH> extends true\n        ? Pre\n        : // else add T to Ignore and recurse\n          ExtractUnion<MAX_DEPTH, V, IncludePrefix, Ignore | T, Pre, INC_DEPTH<DEPTH>>;\n\ntype __ExtractIfRecord<\n  MAX_DEPTH extends _DEPTHCOUNT,\n  T extends TypedRecordInstance,\n  V,\n  IncludePrefix extends boolean,\n  Ignore,\n  Pre extends string,\n  DEPTH extends _DEPTHCOUNT,\n> = V extends TypedRecordInstance ? __InternalExtract<MAX_DEPTH, T, V, IncludePrefix, Ignore, Pre, DEPTH> : never;\n\ntype _ExtractUnion<\n  MAX_DEPTH extends _DEPTHCOUNT,\n  T extends TypedRecordInstance,\n  IncludePrefix extends boolean,\n  Ignore,\n  Pre,\n  DEPTH extends _DEPTHCOUNT,\n> = {\n  // for each string key in the record,\n  [K in keyof T]: IsUniqueSymbol<K> extends true\n    ? never\n    : K extends string\n      ? // we recursively extract any values that resolve to a TypedRecordInstance\n        __ExtractIfRecord<\n          MAX_DEPTH,\n          T,\n          Unpacked<Awaited<T[K]>>,\n          IncludePrefix,\n          Ignore,\n          Pre extends string ? `${Pre}.${K}` : K,\n          DEPTH\n        >\n      : never;\n  // then we return any value that is not 'never'\n}[keyof T];\n\n/**\n * A Utility that extracts either resource types or resource paths from a TypedRecordInstance.\n *\n * Its limitations are mostly around its intentional non-recursiveness. It presumes that APIs which\n * implement includes will not allow cyclical include paths, and will collapse includes by type.\n *\n * This follows closer to the JSON:API fields spec than to the includes spec in nature, but in\n * practice it is so impracticle for an API to allow z-algo include paths that this is probably\n * reasonable.\n *\n * We may need to revisit this in the future, opting to either make this restriction optional or\n * to allow for other strategies.\n *\n * There's a 90% chance this particular implementation belongs being in the JSON:API package instead\n * of core-types, but it's here for now.\n *\n * @typedoc\n */\ntype ExtractUnion<\n  MAX_DEPTH extends _DEPTHCOUNT,\n  T extends TypedRecordInstance,\n  IncludePrefix extends boolean = false,\n  Ignore = NONE,\n  Pre = NONE,\n  DEPTH extends _DEPTHCOUNT = 1,\n> = Exclude<\n  IncludePrefix extends true\n    ? // if we want to include prefix, we union with the prefix. Outer Exclude will filter any \"NONE\" types\n      _ExtractUnion<MAX_DEPTH, T, IncludePrefix, Ignore, Pre, DEPTH> | Pre\n    : // Else we just union the types.\n      _ExtractUnion<MAX_DEPTH, T, IncludePrefix, Ignore, Pre, DEPTH> | T[typeof Type],\n  NONE\n>;\n\ntype _DEPTHCOUNT = 1 | 2 | 3 | 4 | 5;\ntype INC_DEPTH<START extends _DEPTHCOUNT> = START extends 1 ? 2 : START extends 2 ? 3 : START extends 3 ? 4 : 5;\ntype IS_MAX_DEPTH<\n  DEPTH extends _DEPTHCOUNT,\n  MAX_DEPTH extends _DEPTHCOUNT = DEFAULT_MAX_DEPTH,\n> = DEPTH extends MAX_DEPTH ? true : false;\ntype DEFAULT_MAX_DEPTH = 3;\n/**\n * A utility that provides the union of all ResourceName for all potential\n * includes for the given TypedRecordInstance.\n *\n * @typedoc\n */\nexport type ExtractSuggestedCacheTypes<\n  T extends TypedRecordInstance,\n  MAX_DEPTH extends _DEPTHCOUNT = DEFAULT_MAX_DEPTH,\n> = ExtractUnion<MAX_DEPTH, T>; // ToPaths<ExpandIgnore<T, true>, false>;\n\n/**\n * A utility that provides the union type of all valid include paths for the given\n * TypedRecordInstance.\n *\n * Cyclical paths are filtered out.\n *\n * @typedoc\n */\nexport type Includes<T extends TypedRecordInstance, MAX_DEPTH extends _DEPTHCOUNT = DEFAULT_MAX_DEPTH> = ExtractUnion<\n  MAX_DEPTH,\n  T,\n  true\n>;\n\nexport type OpaqueRecordInstance = unknown;\n\nexport type _StringSatisfiesIncludes<T extends string, SET extends string, FT extends string> = T extends SET\n  ? FT\n  : T extends `${infer U},${infer V}`\n    ? U extends SET\n      ? _StringSatisfiesIncludes<V, Exclude<SET, U>, FT>\n      : never\n    : never;\n\nexport type StringSatisfiesIncludes<T extends string, SET extends string> = _StringSatisfiesIncludes<T, SET, T>;\n\nexport function createIncludeValidator<T extends TypedRecordInstance>() {\n  return function validateIncludes<U extends string>(includes: StringSatisfiesIncludes<U, Includes<T>>): U {\n    return includes;\n  };\n}\n"],"names":["createIncludeValidator","validateIncludes","includes"],"mappings":"AAAA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAoBA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAoEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwBA;AACA;AACA;AACA;AACA;AACA;;AAIgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAmBO,SAASA,sBAAsBA,GAAkC;AACtE,EAAA,OAAO,SAASC,gBAAgBA,CAAmBC,QAAiD,EAAK;AACvG,IAAA,OAAOA,QAAQ;GAChB;AACH;;;;"}